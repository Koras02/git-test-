{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"path\"","webpack:///./app/node_modules/graceful-fs/graceful-fs.js","webpack:///./app/node_modules/universalify/index.js","webpack:///./app/node_modules/fs-extra/lib/mkdirs/index.js","webpack:///external \"electron\"","webpack:///external \"fs\"","webpack:///external \"util\"","webpack:///./app/node_modules/fs-extra/lib/path-exists/index.js","webpack:///external \"stream\"","webpack:///./app/node_modules/winston/lib/winston/common.js","webpack:///external \"os\"","webpack:///./app/node_modules/source-map/lib/util.js","webpack:///./app/node_modules/winston/lib/winston/transports/transport.js","webpack:///./app/node_modules/colors/lib/colors.js","webpack:///external \"events\"","webpack:///./app/node_modules/winston/lib/winston.js","webpack:///./app/node_modules/fs-extra/lib/remove/index.js","webpack:///./app/node_modules/event-kit/lib/disposable.js","webpack:///external \"url\"","webpack:///./app/node_modules/fs-extra/lib/json/jsonfile.js","webpack:///./app/node_modules/fs-extra/lib/index.js","webpack:///./app/node_modules/winston/lib/winston/config.js","webpack:///external \"child_process\"","webpack:///./app/src/main-process/shell.ts","webpack:///./app/src/main-process/menu/ensure-item-ids.ts","webpack:///./app/src/main-process/menu/index.ts","webpack:///./app/src/main-process/now.ts","webpack:///./app/src/lib/fatal-error.ts","webpack:///./app/src/lib/window-state.ts","webpack:///./app/node_modules/event-kit/lib/event-kit.js","webpack:///./app/node_modules/source-map/lib/array-set.js","webpack:///./app/node_modules/source-map/lib/base64-vlq.js","webpack:///./app/node_modules/source-map/lib/source-map-generator.js","webpack:///./app/src/lib/source-map-support.ts","webpack:///./app/src/lib/logging/format-error.ts","webpack:///./app/node_modules/mkdirp/index.js","webpack:///./app/node_modules/jsonfile/index.js","webpack:///./app/node_modules/fs-extra/lib/copy/index.js","webpack:///./app/node_modules/fs-extra/lib/util/buffer.js","webpack:///./app/node_modules/fs-extra/lib/util/utimes.js","webpack:///./app/node_modules/fs-extra/lib/mkdirs/win32.js","webpack:///./app/node_modules/fs-extra/lib/copy-sync/index.js","webpack:///external \"assert\"","webpack:///./app/node_modules/fs-extra/lib/fs/index.js","webpack:///./app/src/lib/logging/get-log-path.ts","webpack:///./app/node_modules/winston/lib/winston/exception.js","webpack:///external \"zlib\"","webpack:///./app/node_modules/async/lib/async.js","webpack:///./app/src/main-process/log.ts","webpack:///./app/src/lib/helpers/non-fatal-exception.ts","webpack:///./app/src/main-process/menu/build-context-menu.ts","webpack:///./app/src/main-process/crash-window.ts","webpack:///./app/src/main-process/show-uncaught-exception.ts","webpack:///./app/src/main-process/exception-reporting.ts","webpack:///./app/src/lib/process/win32.ts","webpack:///./app/src/main-process/squirrel-updater.ts","webpack:///./app/src/lib/sanitize-ref-name.ts","webpack:///./app/src/lib/parse-app-url.ts","webpack:///./app/src/lib/shell.ts","webpack:///./app/src/main-process/menu/get-all-menu-items.ts","webpack:///./app/src/main-process/menu/crash-menu.ts","webpack:///./app/src/ui/lib/context-menu.ts","webpack:///./app/src/lib/feature-flag.ts","webpack:///./app/src/lib/truncate-with-ellipsis.ts","webpack:///./app/src/main-process/menu/build-default-menu.ts","webpack:///./app/node_modules/electron-window-state/index.js","webpack:///./app/src/models/app-menu.ts","webpack:///./app/node_modules/file-url/index.js","webpack:///./app/src/lib/path.ts","webpack:///./app/node_modules/event-kit/lib/composite-disposable.js","webpack:///./app/node_modules/event-kit/lib/emitter.js","webpack:///./app/src/main-process/app-window.ts","webpack:///external \"module\"","webpack:///./app/node_modules/source-map/lib/source-node.js","webpack:///./app/node_modules/source-map/lib/quick-sort.js","webpack:///./app/node_modules/source-map/lib/binary-search.js","webpack:///./app/node_modules/source-map/lib/source-map-consumer.js","webpack:///./app/node_modules/source-map/lib/mapping-list.js","webpack:///./app/node_modules/source-map/lib/base64.js","webpack:///./app/node_modules/source-map/source-map.js","webpack:///./app/node_modules/source-map-support/source-map-support.js","webpack:///./app/node_modules/file-uri-to-path/index.js","webpack:///./app/src/lib/logging/format-log-message.ts","webpack:///./app/node_modules/winston-daily-rotate-file/index.js","webpack:///./app/node_modules/fs-extra/lib/output/index.js","webpack:///./app/node_modules/fs-extra/lib/move/index.js","webpack:///./app/node_modules/fs-extra/lib/move-sync/index.js","webpack:///./app/node_modules/fs-extra/lib/json/output-json-sync.js","webpack:///./app/node_modules/fs-extra/lib/json/output-json.js","webpack:///./app/node_modules/fs-extra/lib/json/index.js","webpack:///./app/node_modules/fs-extra/lib/ensure/symlink-type.js","webpack:///./app/node_modules/fs-extra/lib/ensure/symlink-paths.js","webpack:///./app/node_modules/fs-extra/lib/ensure/symlink.js","webpack:///./app/node_modules/fs-extra/lib/ensure/link.js","webpack:///./app/node_modules/fs-extra/lib/ensure/file.js","webpack:///./app/node_modules/fs-extra/lib/ensure/index.js","webpack:///./app/node_modules/fs-extra/lib/remove/rimraf.js","webpack:///./app/node_modules/fs-extra/lib/empty/index.js","webpack:///./app/node_modules/fs-extra/lib/copy/copy.js","webpack:///./app/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js","webpack:///./app/node_modules/fs-extra/lib/mkdirs/mkdirs.js","webpack:///./app/node_modules/fs-extra/lib/copy-sync/copy-sync.js","webpack:///./app/node_modules/graceful-fs/clone.js","webpack:///./app/node_modules/graceful-fs/legacy-streams.js","webpack:///external \"constants\"","webpack:///./app/node_modules/graceful-fs/polyfills.js","webpack:///./app/node_modules/winston/lib/winston/logger.js","webpack:///./app/node_modules/winston/lib/winston/container.js","webpack:///./app/node_modules/stack-trace/lib/stack-trace.js","webpack:///./app/node_modules/winston/lib/winston/transports/memory.js","webpack:///external \"https\"","webpack:///external \"http\"","webpack:///./app/node_modules/winston/lib/winston/transports/http.js","webpack:///./app/node_modules/isstream/isstream.js","webpack:///./app/node_modules/winston/lib/winston/transports/file.js","webpack:///./app/node_modules/winston/lib/winston/config/syslog-config.js","webpack:///./app/node_modules/winston/lib/winston/config/npm-config.js","webpack:///./app/node_modules/winston/lib/winston/config/cli-config.js","webpack:///./app/node_modules/colors/lib/maps/random.js","webpack:///./app/node_modules/colors/lib/maps/rainbow.js","webpack:///./app/node_modules/colors/lib/maps/zebra.js","webpack:///./app/node_modules/colors/lib/maps/america.js","webpack:///./app/node_modules/colors/lib/custom/zalgo.js","webpack:///./app/node_modules/colors/lib/custom/trap.js","webpack:///./app/node_modules/colors/lib sync","webpack:///./app/node_modules/colors/lib/system/supports-colors.js","webpack:///./app/node_modules/colors/lib/styles.js","webpack:///./app/node_modules/colors/safe.js","webpack:///external \"string_decoder\"","webpack:///./app/node_modules/cycle/cycle.js","webpack:///external \"crypto\"","webpack:///./app/node_modules/winston/lib/winston/transports/console.js","webpack:///./app/node_modules/winston/lib/winston/transports.js","webpack:///./app/src/lib/logging/main/install.ts","webpack:///./app/src/main-process/main.ts"],"names":[],"mappings":"0BACA,cAMA,IACA,iBAGA,mBACA,CACA,IACA,aAIA,mCAGA,aAGA,OACA,OAIA,OAzBA,YA4BA,MAGA,uBACA,GACA,kCACA,CACA,gBACA,cAGA,OAGA,iBACA,sCAAiD,CACjD,UAGA,iBACA,YACA,qBAA2B,UAA0B,UACrD,YAAiC,CAAe,QAChD,EAEA,aADA,QAIA,mBAAsD,wCAA+D,SAGrH,MAIA,4BCnEA,kB,wBCAA,CA6FA,aAEA,cAkGA,UACA,UAEA,aAgEA,OACA,4CAEA,yCACA,UAEA,aAiBA,OACA,4CAEA,yCACA,UAEA,oBAwBA,oBAMA,2BACA,wBACA,wBAEA,aACA,mCACA,WAEA,IACA,EACA,OAfA,6BAEA,MAEA,UAaA,CA3OA,OAEA,gBACA,8BA4MA,cACA,eAEA,IA9MA,+BA+MA,cACA,gBAEA,UAjNA,WACA,wBACA,kBAMA,yBACA,wBACA,wBAEA,WACA,mCACA,WAEA,IACA,EACA,OAfA,6BAEA,MAEA,QAaA,UACA,YACA,2BACA,oBAMA,2BACA,wBACA,wBAEA,aACA,mCACA,WAEA,IACA,EACA,OAfA,6BAEA,MAEA,UAaA,UAEA,iBACA,4BACA,oBAMA,2BACA,wBACA,wBAEA,aACA,mCACA,WAEA,IACA,EACA,OAfA,6BAEA,MAEA,UAaA,WACA,aACA,uBACA,gBAWA,MACA,QAEA,8BACA,wBAGA,OACA,mCACA,WAEA,IACA,OAtBA,UACA,qBAIA,MAFA,UAIA,QAEA,IAeA,uCAKA,OACA,SACA,eACA,WAEA,SAEA,2CACA,uBAGA,eA2DA,OACA,0CAEA,MACA,aAEA,iBAEA,eACA,YACA,YAEA,OACA,EAEA,WAxEA,4CACA,uBAGA,eA4EA,OACA,0CAEA,MACA,iBAEA,eACA,YAEA,UACA,EAEA,wCAvFA,eACA,CACA,QACA,iBACA,CACA,GACA,EACA,cAEA,wDACA,eACA,CACA,QACA,iBACA,CACA,GACA,EACA,cAIA,qBACA,8CACA,eACA,CACA,QACA,iBACA,CACA,GACA,EACA,cAEA,qBACA,+CACA,eACA,CACA,QACA,iBACA,CACA,GACA,EACA,cAGA,0BAoDA,KAqBA,SApBA,SAsBA,aACA,yBACA,cACA,QAEA,YACA,iBAEA,kCACA,sBAEA,aAxVA,OACA,SACA,SAEA,SAGA,GACA,EAGA,6BACA,4CAEA,kCAEA,4BACA,yBACA,2BAIA,GACA,GAHA,aAaA,KATA,sBACA,iDACA,kBACA,wBACA,yCACA,oBACA,QAEA,cAGA,OACA,kCACA,eACA,CACA,QAOA,uBACA,gBACA,8BAGA,IAGA,IACA,mCACA,UACA,EAEA,CAIA,iCAHA,CAEA,WACG,IAEH,8BACA,aAEA,WACA,WACA,GAEA,CAIA,iCAHA,CAEA,WACG,IAEH,oDACA,iCACA,GACA,wCACA,EAEA,GAEA,YACA,oDACA,sBACA,OACA,6BC3FA,aAEA,0BACA,wCACA,0EAEA,8BACA,6BACA,SACA,SAEA,gBACA,sBACA,UAEA,EAAG,SAAW,SACd,QAEA,yBACA,wCACA,oCACA,uEAEA,wBADA,UACG,SAAW,SACd,yBCvBA,0BACA,mBACA,cAEA,UACA,CACA,SAEA,aACA,SACA,aACA,YACA,8BCbA,kB,yBCAA,kB,mBCAA,kB,yBCCA,0BACA,oBAMA,UACA,YACA,EANA,WACA,uCACA,2BAKA,yBCXA,kB,0BCMA,CAEA,QACA,OACA,SACA,SACA,YACA,qBACA,WAUA,IACA,2BACA,CAEA,KA8BA,4CA7BA,OACA,KAGA,qBACA,SACA,yDAOA,mDAGA,OACA,4BAIA,gHAEA,6CACA,kBACA,UACA,EAEA,IAOA,EACA,4BACA,iBACA,MACA,sBAAyB,UAAiB,MAE1C,GAOA,EACA,mBAIA,OAEA,kBAGA,OAOA,SAPY,WACZ,0DACA,MACA,IAEA,sBAGA,SAEA,wBACA,wBAGA,kBACA,sBACA,sBAEA,iBACA,wBAEA,GACA,wBAGA,+BAIA,+CALA,KAMA,QAiBA,EACA,iBACA,OACA,iCACA,YACA,4BACA,+BACA,6DACA,eAEA,yBADA,OAMA,OACA,8BACA,YAAc,CAEd,uBACA,aAOA,0BACA,sBACA,cAEA,aAMA,wCACA,wBACA,YAAc,CAGd,uBACA,aACA,2BAEA,KAAwB,kBACxB,SAA0B,sBACN,eAEpB,6BAEA,OACA,cACA,0BACA,iBAGA,oBACA,8BACA,mBAGA,0BACA,SACA,GAEA,OACA,iCAGA,2CACA,oBACA,mBAEA,WACA,EAKA,IACA,wCACA,qBAGA,4BAEA,2DACA,sBACA,SAGA,uBACA,gBACA,+BACA,0BACA,4CACA,WAEA,kBACA,uCACA,YAGA,OACA,sBAEA,cACA,2BACA,0CACO,yBACP,oDACO,cACP,MACA,iCACA,4CACA,0BACA,6BACA,wBACA,oCAKA,SACA,eACA,eACA,eAGA,gCAEA,MACA,eAKA,aACA,UAEA,wBACA,sCACA,EAOA,EACA,kBACA,8CACA,MAKA,EACA,iBACA,2CACA,GAKA,EACA,sBACA,mBACA,aAQA,EACA,yBAEA,IACA,yBAEA,YACA,yBAGA,YACA,WAEA,OACA,aAEA,YACA,WAGA,SACA,8BAGA,uBACA,uDAGA,oBACA,YACA,YAEA,SAAiB,EAAY,QAC7B,2BACA,SAEA,2BAA8C,OAAO,IACrD,qBACA,cACA,OAIA,SACA,GACA,0BACA,iBAGA,0BAGA,UACA,OAEA,KAEA,CACA,QAOA,EACA,wBACA,UACA,uBACA,UACA,QACA,KACA,IAEA,SACA,sBAGA,QACA,gCACA,GACA,oBACA,cACA,QAEA,yCAGA,aAIA,YAFA,kBAMA,4BACA,UACA,iBAIA,8CACA,CAEA,KAQA,SAJA,YAFA,kBAGA,aAKA,kCAEA,aAKA,eAHA,WAIA,MAEA,iBAGA,2BAGA,gBAGA,UAIc,sBAHd,kBACA,IAEA,EAAqB,IACrB,wBAEA,kBAKA,oBAHA,OAMA,aAEA,KAEA,KACA,GACA,EACA,GAMA,OACA,SAOA,EACA,gCACA,OACA,0BAEA,6EACA,sCACA,kBAEA,UAEA,MADA,UACG,gBACH,qBC9eA,kB,oBCgBA,CACA,iBACA,IACA,aACG,SACH,qBAEA,+BAEA,6BAMA,aACA,SAEA,kBAGA,UACA,UACA,UACA,UACA,UAEA,IAPA,KAUA,aACA,OACA,GAiBA,SAhBA,qBAEA,QACA,OACA,iBAEA,OACA,YAEA,QACA,gBAEA,QACA,YAEA,QAeA,aACA,IACA,OACA,UACA,OACA,KAEA,aACA,IACA,aAEA,wBACA,sBAA8C,IAAQ,KACtD,MACA,KACA,mBACK,GACL,SACK,IACL,MAIA,mBACA,OAEA,eACA,GAIA,sBAEA,KACA,iBAIA,UACA,OAGA,QA+GA,aACA,CACA,QAUA,CAmBA,aACA,IACA,GAGA,iBAEA,UACA,IAGA,YACA,wBACA,wBACA,yBACA,yBACA,yBACA,yBACA,yBACA,wBACA,uBAGA,qBAA2B,GAAQ,KACnC,OACA,qBAIA,SACA,QASA,CAsEA,eACA,OACA,OAGA,EACA,IAGA,GACA,CAKA,CAzWA,EAEA,eACA,mFAeA,aAsBA,EAYA,cA4CA,EAiBA,YA0CA,OAzCA,aACA,CACA,WAEA,KACA,WAEA,WACA,OAEA,sBAIA,WAEA,6BAEA,QAGA,aACA,SAIA,2BACA,cACA,OAGA,WAEA,2CAGA,mBACA,OAGA,SAGA,wBACA,8BACA,QAOA,EAiCA,WAhCA,aACA,CACA,WAGA,uBAMA,cACA,0BACA,oBACA,KACA,IAMA,sBACA,aACA,qBAGA,SACA,GAGA,iDACA,IAGA,gBACA,qBACA,cACA,gBAAC,IAsBD,kBAPA,WACA,OACA,MAIA,SAUA,oBAPA,WACA,OACA,cAIA,MAuEA,EAUA,2BAtCA,eACA,kBACA,aAIA,0BACA,aAIA,8BACA,eAIA,kCACA,gBAIA,6BACA,cAIA,cACA,WAwCA,sCA5BA,eACA,yBACA,oBAIA,6BACA,gBAIA,yBACA,OAIA,4BACA,aAIA,8BACA,eAIA,cACA,WA+CA,sCA5BA,aACA,yBACA,oBAIA,8BACA,gBAIA,yBACA,QAIA,6BACA,aAIA,+BACA,eAIA,iBACA,4BCvZA,SACA,QAQA,4BACA,qBAEA,WACA,iBACA,sBACA,+BACA,sBAOA,uBAEA,8BACA,6DACA,+CACA,mCAIA,EACA,eAOA,cACA,mCACA,CACA,QAMA,EACA,sCAMA,CA4BA,YAzBA,2BAGA,oBAGA,sBACA,MACA,8CAIA,yBACA,eACA,4CAKA,wBAGA,kBAEA,QASA,EACA,qCACA,CACA,QAUA,EACA,wCACA,aASA,KACA,sBACA,6BACA,WAEA,IAEA,OAfA,KAEA,cACA,OAGA,mBAUA,sBACA,oDAAyD,CACzD,qBC1GA,CAiCA,aACA,mBACA,kBACA,UACA,EAKA,SAFA,YACA,aAGA,CAgBA,YACA,OACA,cACA,0BACA,SACA,cAAmB,EAAa,IAChC,WAIA,oBACA,GAGA,wBAEA,YACA,SACA,SACA,6CAGA,MACA,SAEA,aACA,QACA,oBACA,iBACA,UACA,QACA,CAEA,MA3FA,SACA,YAEA,SAEA,oBACA,+BAEA,kBAEA,KACA,4CACA,eAEA,iCACA,oCACA,GAGA,+BACA,yBACA,KAEA,IACA,mCACA,IACA,uCAEA,wCACA,qBAcA,OACA,GAUA,gBATA,uCACA,uCACA,UACA,eACA,uBACA,UAEA,EACA,IAGA,mBAA4C,KAqC5C,sBACA,IACA,sBACA,sBACA,YACA,aACA,SAAK,SACL,CAEA,eADA,QAGA,KAEA,OAcA,mBACA,eACA,eACA,cACA,GAEA,EAWA,YAVA,eACA,UAEA,KACA,UACA,sBACA,oBACA,sBACA,uBAGA,iBACA,iBACA,YACA,UACA,CACA,MAEA,IArCA,UACA,OACA,GAQA,yCAPA,MACA,eACA,UACA,IAEA,EACA,K,iBCnJA,kB,0BCMA,CAEA,GAIA,KACA,iBAIA,QACA,eAIA,KACA,WACA,cACA,gBACA,kCACA,kBACA,eACA,qBAIA,UACA,6BACA,uBACA,kBAaA,UACA,gBAUA,6BACA,8BAMA,WAeA,6BAdA,CACA,MACA,QACA,SACA,MACA,SACA,QACA,UACA,aACA,SACA,MACA,mBACA,qBACA,YAEA,oBACA,gBACA,qBACA,UACA,CAOA,GACA,gBACA,CAWA,SAVA,iDACA,iCACA,wCAEA,qBACA,+BACA,iCAGA,eAOA,EACA,uBACA,iBACA,YACA,YAKA,EACA,gCACA,eACA,UACA,KACA,iBACA,GAEA,qDACA,iBACA,OACA,EAMA,IACA,sFACA,2BACA,eACA,OACA,KACA,iBACA,CACA,MAEA,GAMA,GACA,kCACA,eACA,OACA,cACA,+BAEA,kBACC,qBCjKD,0BACA,qBAEA,UACA,QACA,kBACA,mBCRA,WACA,IAEA,yBACA,cAYA,MACA,gBAEA,CAYA,mBAzBA,sCACA,OACA,4CAOA,gCAKA,MACA,gBACA,YACA,6CAEA,qCAEA,KAEA,GAIA,GAAC,2BCjCD,kB,wBCEA,0BACA,qBAEA,UAEA,cACA,yBACA,2BACA,2BACA,gCCXA,aAEA,iBACA,OAEA,KAEA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,KAIA,KACA,UACA,qCACA,wDACA,MAAY,kBAEZ,oBCrBA,CAmDA,aACA,4CAEA,GAOA,4BANA,kBACA,UAAmB,MAAiB,OACpC,cAEA,KACA,KA1DA,QAEA,KACA,aAEA,GACA,sBAEA,uBACA,CACA,QAEA,wBACA,yBAEA,QACA,sBACA,0BAAgD,OAAO,IACvD,QAGA,qCACA,sBACA,SAAmB,MAAqB,OACxC,QAEA,SACA,MAEA,UAGA,SACA,QAIA,EACA,aACA,aACA,WAIA,KACA,0BACA,0BACA,0CCvDA,kB,qFCAA,qBACA,QAEA,GASA,E,kBAAkC,WAY9B,SAEH,yCC1BkB,aACjB,OAAO,GAAS,IAAM,EAAS,OAAS,EAAS,MAClD,SAED,CAYE,aACA,EAAS,IACT,EAAU,GAAI,KAEd,KAAK,KAAc,QACjB,IAAI,GACJ,EAAI,EAAK,EAGT,MAGE,GACE,KAAc,GAAT,KAA4B,OAAG,KAAe,EACpD,SAAQ,EAGX,aACA,OAEA,OAAI,EAAK,QACP,MAAM,GAAkB,EAGxB,QAAc,IAAiB,EAChC,KACF,CACF,mDA5BD,E,6JCfA,SACA,SAEA,SACA,I,uECJA,WAOA,E,IAAgB,UACd,MAAM,GAAO,QACb,eAAiB,IAAV,GAAK,GAAY,EAAK,GAC9B,iCCT0B,aACzB,MAAM,IACP,gDAHD,WACA,EAIA,aAaA,EAIA,YAJsC,aACpC,MAAM,IACP,WAQD,E,YAAgD,aAC9C,OACE,KADE,IAKL,oCCxB8B,aAC7B,OAAI,GACF,eACK,cAAI,EACT,cACK,YAAI,EACT,cACS,YAAC,EACV,YAIH,SAFG,SAyCF,eAEA,GAAO,YAAY,KAAK,EACzB,yB,uCAhED,WACa,yBAAyB,uBAStC,EAcA,iBAIA,EA2BA,iCA1BE,WAEA,GAAO,GAAG,oBAAqB,IACR,IAQvB,kBAAO,GAAG,oBAAqB,IAA2B,IAE1D,aAAO,GAAG,WAAY,IAA2B,IACjD,gBAAO,GAAG,WAAY,IAA2B,IACjD,gBAAO,GAAG,aAAc,IAA2B,IACnD,aAAO,GAAG,UAAW,IAA2B,IAChD,aAAO,GAAG,OAAQ,IAA2B,IAC7C,aAAO,GAAG,OAAQ,IAIhB,CAAqB,IACtB,KACF,qBCrDD,WACA,aAEA,mBAEA,4BAEA,GAAC,8BCAD,CAUA,YACA,aACA,qCACA,KAIA,SAhBA,uBACA,iBAOA,wBASA,yBACA,WACA,cAAsC,OAAS,IAC/C,UAEA,QACA,QAOA,EACA,2BACA,+DACA,MAMA,EACA,6BACA,aACA,2CACA,sBACA,QACA,oBAIA,wBAEA,cAGA,UAMA,EACA,2BACA,CACA,sBAEA,eACA,kCAEA,OAMA,EACA,+BACA,MACA,iBACA,UACA,KAEA,QAAG,KACH,SACA,8BACA,oBAEA,OAEA,uBACA,uBAMA,EACA,0BACA,wBACA,mBAEA,0BACA,2BAMA,EACA,8BACA,oBACA,SAEA,6BCnFA,CA+BA,aACA,OACA,aACA,SACA,CAOA,CACA,aACA,UAEA,QADA,SAEA,CAEA,IAIA,SAvCA,MAGA,IAGA,SAGA,EAOA,IAwBA,oBACA,OACA,KAIA,KAFA,EAGA,KACA,IACA,OAGA,MAEA,WACG,gBAEH,KACA,QAKA,EACA,wBACA,SACA,SACA,IACA,IAEA,IACA,IACA,qBAGA,yEACA,OACA,0DAGA,SACA,KACA,QACA,KACA,IAEA,kBACA,OACA,wBCpIA,CAaA,aAEA,OAEA,iCACA,+CACA,sCACA,mCACA,kBACA,qBACA,4BACA,aAvBA,QACA,YACA,iBASA,YAcA,qBAMA,EACA,EACA,yBACA,SACA,mBACA,QACA,KAEA,eAiCA,gCAhCA,OACA,WACA,QACA,uBAIA,kBACA,4BACA,OACA,kCAGA,oBACA,QACA,sBAGA,gBACA,wBAIA,SACA,aACA,gCACA,SACA,oBACA,WAEA,qBACA,IAYA,EACA,YACA,sBACA,kBACA,qCACA,4BACA,0BAEA,WACA,sBAGA,0BACA,UACA,sBACA,sBAIA,QACA,UACA,oBACA,oBAIA,2BACA,iBACA,uBACA,+BACA,+BACA,OACA,SAEA,QAIA,EACA,YACA,8BACA,IACA,KACA,2CAGA,gBAGA,aAOA,kDACA,gBACA,sEAGA,cAXA,uDAEA,+BACK,kBAyBL,EACA,YACA,8BACA,IAEA,gBACA,IACA,sBAKA,4JACA,IACA,YAEA,YACA,cAIA,qBACA,QAGA,gDACA,uCAEA,6BACA,QACA,sBAEA,iBAEA,4BACA,OACA,8BAEA,SACA,kCAEA,0BACA,wBACA,OACA,wBAGA,MAEA,SACA,kBACA,UAGA,eACA,gBACA,UAGA,MAAK,EACL,WACA,gBAGA,sCACA,SACA,oBACA,UACA,cAEA,WACA,cAEA,oBAEA,sBAAK,EACL,KAYA,EACA,YACA,iBACA,iBAKA,gCACA,mCAOA,2QACA,wBACA,qBAIA,sBACA,6BACA,wBACA,uBAMA,mEACA,CACA,YACA,SACA,WAGA,SAKA,EACA,YACA,6BACA,WACA,IACA,IACA,IACA,IACA,IACA,IACA,oBAMA,kBAA0C,OAL1C,EACA,EACA,EAEA,EACmD,QACnD,MACA,OAEA,KACA,wBACA,IACA,sBACA,IAIA,gBACA,iDACA,IAEA,YACA,GAGA,eAEA,uBAEA,gBACA,2CACA,oBACA,KAGA,+BAEA,sBAEA,gBAEA,sBAEA,eACA,uCACA,kBACA,KAIA,MACA,IAEA,CACA,UAEA,YACA,qCACA,yBACA,UACA,uBAEA,MACA,cAEA,uBACA,gEACA,yBACA,oBACA,IAAK,EACL,KAIA,EACA,YACA,iBACA,OACA,cACA,+BACA,4BACA,wBAEA,sBAWA,MAVA,gCAEA,OACA,2CAEA,kBACA,6EAGA,cAKA,EACA,YACA,mBACA,4BACA,WAEA,qDC9Y2B,aAGzB,IAAI,CAAC,EAAwB,KAAK,KAAQ,EACxC,mBAIF,MAAI,EAAO,WACT,eAIF,WAAM,GAAgB,GAAT,CAqBb,cAAI,CAAC,EAIL,iBAEE,MAAM,GAAM,EAAgB,eAC5B,cAAO,CAAE,IAAK,EAAc,YAC7B,MAJD,CAIS,QAER,CACF,CAGD,CAeyC,eACvC,UAKA,SAAO,EAAQ,EAAO,IAAI,KAA0B,YAAjB,CAApB,IAAyC,KACzD,GAED,CA4BgC,aAC9B,IAAI,GAAS,EASV,mBAAC,EAAM,OAAS,IACjB,aAAS,EAIT,UAIH,OAJU,EAGT,K,uCAvIF,qBACA,OAEA,GAAM,EAAyC,EAC/C,IAAM,EAAmB,EAWzB,IAAM,EAA0B,CAAC,cAAe,WAkD1C,EAAgB,GAEtB,SAIA,GAKA,GAcA,EAcA,iBAdgB,UACd,GAAiB,QACf,aACA,OACA,4BAGF,2BAAM,GAGN,QAAiC,EACjC,oBACD,qBAMD,EAQA,sBARsC,WACpC,OACE,MAAM,EACN,aAAS,EACT,cAEH,sFClHD,UAEA,IAIA,E,YAA0C,aACxC,UAAQ,EAER,yBAAI,EACF,MAAO,EAAgB,GAAR,MAAa,EAAW,KAAhC,GAAqC,EAAM,MAElD,OAAO,EACK,GAAR,MAAa,EAAU,SAAK,EAAa,OACzC,MAAG,EAAU,SAAK,EAAa,OAEtC,oBChBD,CAMA,mBACA,CACA,sBACA,MAEA,SACA,wBAAgB,CAGhB,iBACA,SAEA,MACA,0BAEA,eAEA,0BACA,MAEA,kCACA,IACA,YACA,OAEA,iBACA,UACA,uCACA,GACA,OACA,UACA,GAKA,MACA,8BAGA,qBACA,SACA,OAGA,IACA,WAnDA,OACA,wBAEA,8BAkDA,wBACA,IACA,uBAAgB,CAGhB,iBACA,SAEA,MACA,0BAEA,eAEA,UAEA,cACA,GACA,iBACA,IACA,SACA,UACA,UACA,eACA,gBACA,SAKA,MACA,WACA,MACA,KACA,WACA,SACA,CACA,OACA,qBAGA,SAEA,CACA,2BC1FA,iBACA,CACA,UACA,MAGA,IACA,wBAGA,kBACA,WAEA,MACA,KACA,mBAGA,oCACA,YAEA,QAEA,QACA,MACA,4BACA,KAAK,SAEL,8BACA,QAEA,aAEA,KAEA,GACA,OACA,GAEA,eACA,MACA,GACA,wBAGA,qBAEA,MACA,KACA,mBAGA,WACA,SACA,2BACA,oBACA,QAAG,SACH,CACA,KAGA,yBAFA,qBAIA,KACA,EAEA,eACA,OAEA,KADA,sBAEA,aACA,aAEA,UACA,UAIA,0CAEA,yBACA,WAEA,mBACA,CACA,UACA,MAEA,SACA,WAEA,QACA,MACA,GACA,MAAG,SAEH,CAEA,mBADA,MAGA,GACA,mBAEA,iBACA,MACA,WAEA,QAEA,gBACA,qBAEA,aAEA,CAGA,yCAFA,+BACA,KAGA,CA9HA,MACA,GACA,KACA,EAAC,SACD,KACA,GAgIA,UANA,CACA,WACA,eACA,YACA,kCCnIA,aAEA,0BACA,UACA,UACA,mBCJA,aACA,qBACA,IACA,yCACA,eACA,cAAK,SACL,WACA,UAEA,WACA,6BCTA,wCACA,OACA,QAEgB,GAkEhB,UACA,CACA,aAtDA,WACA,iFACA,eAGA,6BACA,sFACA,OACA,wBACA,SACA,0BACA,OACA,oBACA,OACA,mBACA,SACA,iBAMA,4BAiCA,iBApEA,UACA,sFACA,eAGA,6BACA,iCACA,+EACA,eACA,qBACA,aACA,kCA0DA,iBAhCA,WACA,IACA,yBACG,6BACH,sBAEA,wCAEA,wDAyBA,aAvBA,iBAEA,eACA,SACA,+BACA,gBACA,MACA,KACA,EAEA,KAcA,iBAZA,eACA,sBACA,eACA,qBACA,gCCpEA,aAGA,aACA,4CACA,kBACA,GACA,IAIA,WATA,iBAiBA,UACA,CACA,cACA,iBATA,WACA,SACA,0BACA,MACA,2BCnBA,aAEA,UACA,YACA,mBCJA,kB,2BCGA,0BACA,iBAEA,KACA,CACA,SACA,aACA,QACA,QACA,QACA,WACA,SACA,SACA,YACA,QACA,QACA,YACA,UACA,SACA,SACA,OACA,QACA,QACA,UACA,OACA,WACA,UACA,WACA,WACA,SACA,QACA,OACA,UACA,WACA,SACA,SACA,oBAKA,KAGA,yBACA,4BACA,CAKA,sBACA,KAEA,GACA,eACA,QACA,KAGA,GACA,sBACA,OACA,uBAEA,wBACA,OAEA,YAEA,EAEA,4BACA,OACA,uBAEA,qCACA,kBACA,WACA,YAAe,aAEf,WACA,EAMA,EACA,0BACA,OACA,6CAGA,yBACA,kBACA,WACA,YAAe,gBAEf,WACA,kCClGgB,YACd,IAAK,GACH,MAAM,GAAW,MAAI,QACrB,cAAmB,EAAU,OAC9B,OAED,CACD,+CAZD,qBACA,UAEA,GAAI,GAAkC,KAEtC,E,sCCGA,SACA,QAEA,SAEA,wBACA,OACA,iBACA,qBACA,sBACA,oBACA,yCAEA,QAEA,2BACA,OACA,aACA,wCACA,yCACA,iBACA,uBACA,yBACA,qBACA,yBAEA,gBAEA,sBACA,OACA,WACA,mBAEA,WAEA,sBACA,sBACA,8BACA,OACA,UACA,yBACA,yBACA,yBACA,yBACA,yBAEA,WACA,iBCvDA,kB,uBCAA,QAOA;;;;;;cAEA,cA0BA,IACA,uBACA,sBACA,gCACA,eACA,UACA,CAIA,OAnCA,gBAGA,IAEA,oCACA,OAEA,uCACA,OAGA,OAGA,KACA,cAGA,8BACA,CAEA,SADA,SAGA,yBAaA,qCACA,OACA,4BAEA,iBACA,YACA,MAEA,OACA,SAEA,SAEA,iBACA,YACA,MACA,SAEA,SACA,cAEA,UACA,QAEA,mBACA,CAIA,0BAHA,GACA,UACA,IAGA,iBACA,mBACA,GACA,OACA,EAEA,4BACA,OACA,UACA,UACA,qBAGA,QACA,QAEA,iBACA,MACA,SACA,MAGA,WACA,WAEA,eAEA,SACA,cAEA,KACA,QAOA,EACA,EACA,oCAGA,mDAEA,6BAgBA,qCAEA,CACA,IAGA,IAIA,mCAxBA,CACA,IACA,mBAGA,iCACA,cACA,EACA,mBAIA,gCAaA,cAUA,IACA,KAGA,SACA,OACA,QAGA,IACA,MAnBA,QACA,aAEA,WACA,iBACA,KACA,KACA,EAaA,cAEA,iCACA,MACA,QACA,aAEA,WACA,cACA,mBAEA,IACA,KAGA,SACA,OACA,OAGA,IAGA,IACA,EACA,EACA,GACA,oBAGA,wCACA,OACA,kBACA,QACA,mBAEA,2BAEA,uBACA,MACA,gBACA,WAEA,WACA,IACA,IAEA,eACA,SACA,aAGA,mBACA,WACA,KACA,sBAEA,IACA,KAGA,SACA,KACA,OACA,OAGA,IAGA,IAEA,EACA,IACA,CAIA,sCACA,iBACA,uBACA,SAEA,iCAGA,qBAEA,IACA,kBAEA,OACA,EACA,SAGA,MACA,EACA,GAbA,GAeA,kDACA,iBACA,QACA,SACA,UACA,SAEA,WACA,cACA,IACA,QACA,yBAEA,IACA,kBAGA,OACA,EACA,OAIA,UAGA,YAIA,IACA,GACA,IACA,EACA,GAIA,kDACA,CACA,WAEA,mBAEA,uBACA,iBACA,QACA,SACA,cACA,WAEA,WACA,IACA,IAEA,eACA,IACA,WAGA,oBACA,IACA,KACA,YACA,uBAEA,IACA,kBAGA,OACA,KACA,EACA,KAGA,IAGA,IACA,EACA,CACA,IACA,CAGA,eACA,kBACA,SACA,wCACA,UACA,CACA,iBACA,kBACA,SACA,sCACA,UACA,CACA,eACA,kBACA,SACA,8CACA,UACA,CAGA,qBACA,uBACA,QAAoB,QACpB,QACA,GACA,oBACA,sBACA,CACA,IACA,EACS,OACT,OACA,oBACA,wBACA,KACA,SACA,IACA,EAAa,aACb,CACA,MACA,EACA,CACA,QACA,iBACA,iCACA,OACA,YAEA,mBACA,OACA,OAIA,4BACA,6BACA,oBACA,CACA,IACA,IACA,EAAS,aACT,CACA,MACA,EAEA,aAEA,iBAEA,sCACA,sBACA,CACA,QAAS,GACT,YACA,eAEA,YAEA,mCACA,OACA,sBACA,QAAoB,QACpB,QACA,oBACA,sBAEA,MAEA,QACA,GACA,EAAS,YACT,yBACA,kBACA,KAAa,cACb,UACA,KACA,GACA,EACA,WACA,oBAEA,gBACA,wBAEA,oCACA,OACA,sBACA,QAAoB,QACpB,QACA,oBACA,sBAEA,MAEA,QACA,GACA,EAAS,YACT,yBACA,kBACA,KAAa,cACb,UACA,KACA,GACA,EACA,WACA,oBAEA,4BACA,kBACA,gBAEA,IACA,KAGA,KAEA,GACA,EAAS,YACT,CACA,GACA,EACA,WACA,oBAEA,2BACA,uBACA,gBAEA,KACA,MAEA,KACA,GACA,EAAS,YACT,CACA,KACA,EAEA,UAEA,4BACA,uBACA,gBAEA,KACA,MAEA,KACA,GACA,EAAS,YACT,CACA,KACA,EAEA,UAEA,8BACA,sBACA,kBAEA,GAGA,aAAoC,QAEpC,YACA,EAAS,eACT,CACA,WAGA,mCACA,sBACA,6BACA,CACA,cACA,UACA,KAEA,GACA,EAEA,sBACA,GACA,WACA,SACA,UACA,SAGA,WAEA,KACA,gBACA,GACA,UACA,eACA,WAA2B,MAAsB,UACjD,KACA,SAIA,uBAHA,EAIA,cACA,CACA,4BACA,CACA,GACA,EAEA,cACA,OACA,IAEA,KAEA,MACA,OACA,CAEA,kBACA,yBACA,mBACA,mBACA,MACA,kBAEA,MACA,OACA,qBACA,MACA,IACA,GACA,OAEA,OACA,GAEA,KACA,UAEA,eACA,qCAEA,OACA,OACA,OACA,UACA,uBAEA,2CACA,2BAEA,0BACA,iBACA,yBACA,aACA,iBAAiB,UACjB,iBACA,KACA,eAEA,YACA,iBACA,CACA,MACA,gBAEA,QACA,EACA,IACA,CACA,EAEA,yBACA,OACA,IAEA,GACA,uBACA,IACA,IAGA,kBACA,0BACA,wBACA,mBACA,gBACA,UAA8D,MAC9D,UACA,IACA,CAEA,qBAEA,6BACA,cACA,kBACA,OACA,EAEA,WACA,KAEA,2BACA,MACA,WACA,iBACA,mEACA,KACA,OACA,aAEA,sBACA,mBACA,CACA,kBACA,WAEA,QACA,mBACA,OAEA,gBAGA,QAEA,iCACA,SACA,OACA,EACA,CACA,CACA,MACA,cAEA,uBACA,MACA,KACA,0BAEA,iBACA,mBACA,GACA,kBAEA,WACA,SAEA,EAEA,SACA,OACA,4BACA,iBACA,mBACA,GACA,kBAEA,IACA,OACA,IACA,EAAa,aACb,CACA,MACA,EACA,CAEA,0BACA,GAAmB,kBACnB,UAEA,iCACA,GAAmB,eACnB,UAEA,wBACA,MACA,KACA,gCAEA,iBACA,mBACA,GACA,kBAEA,WACA,SAEA,EAEA,SACA,OACA,kCACA,iBACA,mBACA,GACA,kBAEA,IACA,OACA,IACA,EAAa,aACb,CACA,MACA,EACA,CAEA,wBACA,kBACA,iBACA,UACA,wBAEA,aACA,MACA,EAIA,wBAHA,4BACA,IACA,GAEA,WACA,EAEA,qBACA,mBACA,oBACA,UACA,sBAEA,YACA,CAEA,yBACA,OACA,oBACA,kBACA,eACA,IACA,IACA,EAAS,aACT,CACA,MACA,EACA,WACA,oBAEA,6BACA,CACA,iBAEA,UAEA,YACA,aAGA,GAEA,GAEA,4BACA,cACA,CACA,WAEA,wBACA,WACA,UAGA,gBAEA,GACA,EAEA,yBACA,CACA,IAUA,iBARA,UAEA,YACA,YAGA,EAIA,2BACA,cACA,CACA,WAEA,wBACA,WACA,QAKA,MAFA,cAGA,EAEA,uBACA,oBAOA,UACA,YAEA,YACA,SAEA,KAEA,sCACA,GACA,SAEA,OAEA,uBACA,OACA,CACA,uCAIA,gBAEA,mBAGA,wCACA,eAEA,6BACA,QACA,EAEA,IAvCA,aAEA,UACA,sBAEA,sCAmCA,IACA,OACA,GACA,wBACA,WACA,WACA,KACA,WACA,4BACA,CACA,WACA,iBACA,SACA,aACA,EACA,uBACA,CACA,WACA,oBACA,+CACA,eACA,iBACA,sBAEA,WACA,kBACA,IACA,IACA,6BAEA,oBACA,wBAEA,UACA,SACA,IACA,SACA,OACA,CACA,mBACA,gBACA,MACA,oBACA,CACA,QACA,iBACA,OACA,qBACA,kBACA,QACA,WACA,UACA,mBACA,WACA,UACA,mDAGA,UAA+B,EAAkB,KACjD,qBAEA,SAEA,GACA,QAEA,+BAEA,gBACA,qBACA,QAEA,kBACA,YACA,aACA,IACA,kBACA,GACA,aAEA,QAGA,EACA,QAEA,oBACA,UACA,YAEA,YACA,SAEA,KAEA,sCACA,GACA,SAEA,OAEA,uBACA,OACA,CACA,OACA,2CAGA,sCAEA,qCACA,eAEA,6BACA,QACA,EAGA,SAGA,WAQA,6BAPA,CACA,UAGA,WAEA,SAGA,uBACA,IACA,QAEA,KACA,CACA,QACA,oBACA,WACA,WACA,KACA,6BACA,CACA,SAEA,oBACA,QACA,CACA,uCAEA,SACA,0BACA,cAEA,WACA,oBACA,QACA,sBACA,CACA,UACA,aAKA,8BAJA,eACA,kBAIA,4BACA,kBAEA,yBACA,UACA,IAEA,cACA,QACA,mBACA,CAEA,WACA,yBACA,GACA,2BAEA,OAEA,GACA,GACA,GACA,mBACA,UACA,MACA,oBACA,CACA,QAEA,GACA,QAEA,mBACA,mBACA,mBACA,qCACA,mBACA,GAEA,wCACA,eAGA,SACA,2BACA,CACA,aAGA,GACA,IACA,CACA,UACA,eAKA,8BACA,OACA,KACA,mBACA,CACA,QACA,kBACA,SACA,eACA,gBACA,QACA,4BACA,cACA,KAEA,GACA,YAGA,cACA,qCACA,QACA,iBACA,WACA,sBAAiD,OAAO,IACxD,oBAEA,UAEA,KACA,EAGA,SAFA,SACA,cAGA,yBACA,kBACA,oCACA,UACA,CAEA,yBACA,WACA,KAAuB,EAAW,IAClC,MAEA,iBACA,UAEA,+BACA,WACA,KAAuB,EAAW,IAClC,MAEA,iBACA,gBAEA,kBACA,OACA,2BACA,OACA,SACA,eACA,kCACA,+BACA,iBACA,iBACA,GACA,MACA,IACA,eACA,eACA,UACA,EACA,CAEA,sBACA,sDACA,WAEA,qBACA,iBACA,OACA,SACA,eACA,8BACA,oBACA,KAEA,IACA,wBACA,mBACA,kBACA,OAEA,CAEA,QACA,cACA,uBAEA,4BACA,cACA,MACA,CACA,WAEA,MACA,OACA,CACA,IACA,CACA,GAGA,2BACA,UAIA,4BACA,CACA,QAAS,8BAOT,YAAC,mCClvCuB,aAChB,MACW,GAAkB,WAAnC,YACA,aAAO,GACR,SAED,CAU2B,aACzB,MAAM,GAAa,GAAI,GAAQ,WAAW,gBACxC,CAEA,WACA,oBACA,oBACA,cAEA,iBACA,OASF,eAAW,GAAG,QAAS,IAAQ,CAE/B,QAAM,GAAgB,GAAI,GAAQ,WAAW,QAC3C,CAAgD,MAGlD,mBAAQ,UACN,YAGF,QAAO,EACR,IAaQ,YAKP,eAAgB,GAAI,SAAqC,OACvD,MAAM,GAAe,EAErB,wBAAU,aACP,KAAK,IACJ,IACE,MAAM,GAAS,EACf,MACD,IAHD,CAGS,QACP,CACD,IACF,CARH,GASG,MAAM,KACL,CACD,IACJ,EAGF,KAED,uCApGA,qBACA,OAEA,QAEA,YAEA,EAEA,IAIA,KAAM,GAEN,GAiDA,GAAI,GAEJ,KA2CA,E,IAA2C,mBACzC,IACE,MAAM,GAAS,KACf,UAAM,IAAI,SAAwB,OAChC,CAAc,MAAS,KAEnB,GAEA,KAEH,GACF,EACF,EAXD,CAWS,QAQR,CACF,kBClID,8DAyBA,E,sBAAoD,aAClD,SAAQ,KAAiC,6BAAO,CACjD,wCCpB0C,eACzC,OAAO,CAAC,EAAI,EAAkB,oBAAQ,EAAI,EAC3C,gBAED,CAIS,YACP,MAAM,GAAO,OAAK,kBAAkB,CAAC,CAAE,KAAM,cAAe,MAK5D,GAAM,EAAQ,GAAQ,EAAK,QAAU,EAAK,QAAQ,MAKlD,SAAO,GAAM,OAAO,KAAK,CAAC,EAAW,EAAE,KACxC,sBAED,CA4BE,eACA,EAAwC,GAExC,MAAM,GAAO,GAAI,GAEjB,SAAK,KAAY,OAAS,GACxB,aAAI,EAAW,EAAK,KAClB,gBAAK,KAAM,KACT,OAEH,cACC,MAAM,GAAU,CAEhB,UAAK,OACH,GAAI,GAAJ,SACE,OAAO,EACP,WAAM,EACN,aAAS,EACT,aAAM,EACN,WAAO,IACP,aAAS,EAAK,QACV,EAA0B,EAInC,sBAGH,CACD,Q,kDArFD,UAEA,GA6CA,mBAEE,aAEA,OACD,6ECrDD,qBACA,OAEA,QAEA,IAAM,EACN,IAAM,EAEN,IAOA,E,YAAa,KASX,CAAyC,gBAAY,cAP1B,GAAI,GAIvB,aACA,2BAGN,0BAAM,GACJ,CACA,QACA,SACA,WACA,YAGA,wBACA,sBAGE,sBAOA,WACA,wBAOF,uBAGF,cAAK,OAAS,GAAI,GAClB,sBACA,aACD,WAEM,OACL,KAAI,MAQJ,+BAAK,OAAO,YAAY,KAAK,oBAAqB,IAChD,KAAI,MACL,2BAED,QAAK,OAAO,YAAY,KAAK,kBAAmB,IAC9C,KAAI,MAKJ,iCACA,2BACD,kBAED,QAAK,OAAO,YAAY,GAAG,kBAAmB,IAC5C,MAAK,OAAO,YAAY,yBAAyB,EAClD,EAED,QAAK,OAAO,YAAY,GAAG,gBAAiB,IAC1C,KAAI,MAKF,qCAAK,QAAQ,KAAK,gBAErB,KAED,aAAQ,GAAG,cAAgB,IACzB,KAAU,MAEV,+BAEA,0BACA,iBACD,kBAED,aAAQ,GAAG,aAAe,IACxB,KAAI,MACJ,2CAAK,OACN,OAED,sCAAiC,KAEjC,aAAK,OAAe,kBAAmB,SACxC,cAMO,mBACN,CAAI,KAAK,oBAAsB,KAC7B,wBAAK,QAAQ,KAAK,WAErB,KAEM,CAAQ,UACb,MAAK,OAAO,GACb,WAEM,CAAe,iBACpB,MAAK,QAAQ,GACd,kBAMM,CAAU,YACf,OAAO,MAAK,QAAQ,GACrB,aAEM,QACL,MAAK,OACN,OAGM,OACL,KAAI,MACJ,qCAAK,OACN,MAGO,YAGN,MAAM,GACJ,OAAO,KAAK,MACZ,cAAS,KAAK,MACd,aAAM,KAAK,MAGb,MAAM,EACJ,MAAM,KACN,UAGF,cAAK,OAAO,YAAY,KACzB,UAEM,UACL,MAAK,OACN,SA7JqB,iCCPsC,eAC5D,CAGE,OAHE,MAAM,EAEV,kBAIA,OAEA,OAEA,oBAAM,GAAc,GAAI,GAAJ,YAClB,EAAgB,SAIlB,eAAY,UAAU,IACpB,GACD,MAED,KAAY,eAAe,SACzB,MAAM,UAAO,eACX,MACA,QAAoB,MACpB,8BAEE,qFADA,CAEA,gJAAsD,EAAM,OAC1D,EAAa,OAIjB,WAEF,iBACD,MAED,KAAY,QAAQ,IAEhB,OAEF,iBACD,MAED,KACD,6CArDD,qBACA,OACA,QACA,YAEA,GAEA,MACA,E,4FCRA,qBAEM,GAKN,E,YAGE,qBAMA,MAAM,GAAO,GAEb,KAYE,KAZG,IAAI,OAAQ,EACjB,QAAK,IAAI,UAAW,EAEpB,SAAI,EACF,SAAK,IAAI,QAAS,EAGpB,SAAK,IAAI,WACT,WAAK,IAAI,MACT,8CAAK,IAAI,UAAW,MAEpB,oBACO,KAAM,KAAO,QAChB,UAAS,MAIb,WAAM,GACJ,QACA,WACA,EAhCJ,6DAHM,2DAoCA,gBAIJ,sCAAM,EAAO,CAAC,GAAG,EAAK,WACnB,IACC,CACE,WAA0B,yBAA6B,qBAHhD,IAKV,KAEH,QACE,MAAM,IAAI,SAAwB,OAChC,MAAM,GAAU,MAEhB,aAAQ,GAAG,WAAY,KACrB,CACE,GADE,KAAS,WAGX,IACE,SAAO,EAAmB,gBACxB,EACF,aAGL,gBAED,KAAQ,GAER,aACD,MACD,OAAI,KACL,yBArBD,CAqBS,QACP,KAAI,MACL,mCACF,iCCfC,eAEA,IACE,MAAM,GAAQ,EACd,iBAAO,IAAI,SAA0B,OACnC,IAAI,GAIJ,GAAI,EACF,UAAM,OAAO,GAAG,OAAQ,KACtB,CACD,IAGH,KAAM,GAAG,QAAS,KAChB,CACE,CADE,KAGF,OAAO,GAAI,OAAyB,YAAnB,CAA2B,KAAoB,eAEnE,KAED,KAAM,GAAG,QAAU,KACjB,CACD,IAED,GAAI,EAIF,SAAM,MAET,KACF,EAhCD,CAgCS,QACP,OAAO,SACR,SACF,wCAhGD,qBACA,QAEA,GACA,EAoCA,gBApCsB,oBAEpB,QAAM,GAAa,QAAQ,IAC3B,cAAkB,IAAd,IACF,MAAM,GAAe,EAAU,OAC/B,cAAiB,EACf,OACA,oBACA,OAGH,iBACC,QAGF,sBAAM,IACJ,aACA,mBACA,eAMA,WAOF;;;;KAhBa,CAdb,CA8BM,EAAS,KACf,QAAM,EAAa,EAAO,QAAQ,aAClC,UAAO,GAAW,MAAM,MAAM,OAAO,KAAW,EACjD,SAGD,EAeA,gBAdE,iBAEA,IACA,QAAM,GAAa,QACnB,eAAI,KACF,MAAM,GAAe,EAAU,OAC/B,cAAW,EAAU,OACtB,WACC,QAGF,gBAAY,KAAU,CAAC,OAAQ,EAAM,KACtC,QAGD,E,sCCpBe,kBACb,MAAM,GAAe,CAAC,YACtB,iBACD,KAEc,kBACb,MACA,UACD,KAEc,kBACb,MAAM,GACN,SAAM,GACN,kBACA,WACA,WAAM,GAAQ,KAAM,GACpB,kBACE,CADE,GAAc,kBACV,mBAAgB,CAEzB,SAED,CAIS,YACP,OAAO,GAAK,QAAQ,QAAQ,SAC7B,aAE8C,eAC7C,MAAM,GAAY,EAAK,QAAQ,QAAQ,SACvC,YAAO,GAAc,WAAS,EAC/B,UAED,CAWuC,aACrC,MAAM,GACJ,IAIF,mCAAM,EAAgD,sBAAnC,CACnB,OAAM,EAAiB,EAAU,OAEjC,oBAAO,GACR,eAEsC,mBAK/B,GACJ,IACA,kCACA,QAAQ,MAEV,KAAM,EAEkB;;aAFL,CAGnB,QARA,CAQM,EAAiB,EAAU,OAEjC,gBAAO,GAA0B,cAAY,CAAE,SAAU,OAAQ,KAClE,KAED,CAEE,mBAEA,MAAM,GACP,WAIuB,aACtB,OAAO,GAAoB,CAEzB,qBACA,KACA,EAAU,KAEb,OAEc,kBACb,MAEA,UAAM,GAAQ,KAAM,GACpB,kBAAM,EACN,IAAM,EAAsB,EAAM,OAAO,KACzC,aAAO,GACR,mBAEQ,YACP,OAAO,GAAoB,CAC5B,uBAEc,kBACb,MAAM,GAAgB,EACtB,UAAI,KACF,MAAM,GAAsB,EAC1B,OACA,UAGF,sBAAM,EAAS,KAAM,GACrB,cAAM,EAA+B,EACjC,CAAC,YAAa,WACd,CACJ,mBACD,KACC,OAAO,GAAe,CAAC,YAE1B,W,uCA/JD,qBACA,OAEA,QACA,QAEA,IAAM,EAAY,EAAK,QAAQ,QAAQ,SACvC,MAAM,EAAa,EAAa,UAChC,MAAM,EAAe,EAAK,QAAQ,EAAU,OAC5C,eAAM,EAAU,EAAK,SAAS,QAK9B,UAKA,sBAAoC,WAEhC,OACE,yBAEF,IACE,yBAEF,IACE,2BAEF,IACE,0BAAO,QAGX,UACD,wEChCD,WACA,KAAM,GAEN,+DACA,EAIA,iBAJiC,WAC/B,OAAO,GAAa,UAAuB,KAAK,QAAQ,WACzD,KAGD,E,oBAAoC,WAClC,OAAO,GACR,uCC6CC,eAEA,MAAM,GACN,WACE,KADE,IAIJ,KAAI,MACF,WAAO,EAIV,2CAvED,qBACA,QAkDA,IAsBA,E,YAA4B,WAC1B,MAAM,GAAY,EAClB,YAAM,EAAW,EACjB,SAAM,EAA0B,CAAE,KAAM,UACxC,UACE,GAGF,cAAM,GAAQ,EAEd,MAAM,EAAa,EACnB,iBAAmB,OAAf,KACF,MAAM,GAA2B,IACjC,QAAM,EAA4B,IAClC,eAAY,KAAR,KACF,IADkB,IACX,CAAE,KAAM,QAAS,OAI3B,UAKD,MAAM,GAAW,EACjB,YAAK,IACH,CADe,IAAS,OAK1B,cAAM,GAAa,EAAS,OAE5B,MAAmB,UAAf,KACF,MAAM,GAAyB,IAC/B,MAAM,EAA6B,IACnC,UAAM,EAA+B,IAErC,eAAU,IAAN,IACF,IAAI,CAAC,QACH,QAIF,YAAc,IAAV,KAAkB,CAAC,YACrB,QAEH,QAED,OAAc,KAAV,KAAkB,EAItB,yBACE,MACA,2BACA,MACA,SACA,KAEH,WAED,OACE,eADE,KAEA,MACA,iCAKL,2CC9ID,aAsCe,kBACb,MAAM,GAEN,IAAM,EAAU,GAAI,SAAqB,KACvC,IAAI,GACJ,KAAI,EACJ,KAAI,EACJ,GAGA,UAAM,GAAU,IACd,CACE,UACA,OAEH,KACD,UAAQ,KACR,qBAAW,IACT,CACD,GAFD,EAIA,OAAQ,EAAmB,QAAO,CAAC,OAAQ,eACzC,CACA,kBAAO,CAAC,SAAU,OAAQ,QAG5B,eAAM,GAEN,KAAM,GAAG,QAAU,KACjB,CACA,KACD,GAID,GAAI,EACF,UAAM,OAAO,GAAG,OAAS,KACvB,GACD,OAGH,KAAM,GAAG,QAAwB,IAC/B,CACA,aAAQ,eACR,UAAI,EACF,WAAS,OAAc,UAAS,SAGlC,WAAQ,CAAE,SACX,SACF,EAED,GAAM,CAAE,SAAQ,SAId,iBAIH,OAEQ,YACP,OAAI,SAAQ,IACV,MAAO,QAAQ,IAGjB,MACD,WAED,CAOE,mBA6BD,CAED,CAMmC,aACjC,KAAK,KACH,QAAI,EAIJ,iBAAY,OAEf,KAED,uCAhKA,qBACA,QASA,IAAM,EAA0B,GAAI,KAAI,CAExC,wBAUA,EASA,mBATmC,UACjC,CACD,UA4ID,E,4BAAgB,UACd,OACD,mCClKgC,aAC/B,KAAK,KAAM,KAAY,GACrB,MAEA,QAAsB,SAAlB,KAAS,MAAsB,WACjC,gBAAO,EAAgB,EAG5B,gDAZD,WAIA,E,gDCgBiB,aACf,IAEA,SAAI,EAAK,kBAAmB,GAC1B,SAAK,KAAM,KAAe,GAAK,QAC7B,MACE,OAKN,SAAI,GAAc,EAChB,KAGF,cAAM,GAAM,EAEZ,WAAW,eAAP,MAIJ,eAJ8B,UAM/B,c,kDA7CD,UAEA,GAQA,eAAgB,UACd,MAAM,GAAO,OAEb,qBAIA,SAAK,KAAM,KAAgB,GACzB,MAEH,mFCpBD,KAAM,GAA2B,CAAC,OAAQ,OAAQ,OAAQ,OAC7C,EACT,kBACA,iBAES,EACT,mBACA,0BAES,EAET,yBAEA,mBAES,EAA8B,eAAU,cAExC,EACT,4BACA,4BAEJ,E,oBAAoC,WAEhC,OAAqE,CAGxE,CAHU,KAAyB,QAAQ,EAAU,4CChB7C,YASP,UAKD,GALK,WAAQ,IAAI,+BAOlB,CAOS,YACP,OACD,QAED,uCAhCA,WAsBA,EAKA,wBALgB,UACd,OACD,MASD,8BAAgB,UACd,OACD,MAED,EAIA,6BAJgB,UACd,OACD,MAGD,EAIA,mBAJgB,UACd,OACD,MAKD,EAIA,qBAJgB,UACd,CACD,UAQD,EAIA,gCAJgB,UACd,CACD,UAMD,EAIA,qCAJgB,UACd,CACD,UAMD,EAIA,gCAJgB,UACd,CACD,UAKD,EAIA,sBAJgB,UACd,CACD,UAMD,EAIA,0BAJgB,UACd,CACD,UAQD,EAIA,iBAJgB,UACd,CACD,UAKD,EAIA,qBAJgB,UACd,CACD,UAKD,EAIA,sBAJgB,UACd,CACD,UAMD,EAIA,mBAJgB,UACd,CACD,UAKD,E,mBAAgB,UACd,CACD,4ECrID,WACA,E,qBAAkD,aAChD,IAAI,EACF,UAKF,cAAM,GAAa,CACnB,SAAI,EACF,UAIF,cAAM,GAAa,EAAW,OAC5B,QAAY,QAAR,KACF,QADsB,IAClB,EACF,UAAW,QAAQ,EAAgB,KAAO,GAA1B,CAGlB,MAGH,WAED,OAAI,EACF,UAGF,cAAM,GAAS,EAAW,MAAS,KAAW,KAC9C,UAAgB,GAAT,CACR,mCCKe,WAAiB,CAC/B,yBACA,gBACA,gCACA,wCACwB,2BACJ,sBACc,qCACR,6BACiB,+CAE3C,GAAoB,EAAqB,uBAEzC,SAAM,GAIN,MAAM,EAIN,MAAM,EACqB,IAAzB,OAAqE,WAAxB,CAE/C,GAAM,EACuB,IAA3B,KACI,EADJ,mBAEqC,WAAjC,CAEN,GACA,KAAM,EAAiD,CAAE,KAuCzD,kBAAM,GACJ,CAAoB,MACpB,gBAAS,CAEL,CAAoB,MACpB,2BACA,uBAAO,EACP,iCAEF,iBAEE,CAAoB,MACpB,iCACA,mCACA,oBAAO,EAAK,yBAGZ,CAAoB,MACpB,6BACA,+BACA,0BAAO,EAKT,uBACF,MAAM,GAAY,EAElB,UACE,OAEE,OACA,oBACA,0BACA,oBAAO,EAET,uBAEE,MACA,aACA,oBAGL,UAED,GAEA,UAAS,KACP,CAAoB,MACpB,gBAAS,CACP,CAAE,KAAM,OAA4B,MAAS,SAC7C,CAAE,KAAM,OAA4B,MACpC,WACA,CAAE,KAAM,MAA2B,MAAQ,QAC3C,CAAE,KAAM,OAA4B,MAAS,SAC7C,CAAE,KAAM,QAA6B,MAAU,UAE7C,CAAoB,MACpB,0BACA,oBAAO,EAET,iBAEE,IACA,OAAoB,MACpB,oBACA,oBAAO,EAKb,mBAAS,KACP,CAAoB,MACpB,gBAAS,CAEL,CAAoB,MACpB,cACA,2BACA,oBAAO,EAAK,iBAGZ,CAAoB,MACpB,cACA,2BACA,oBAAO,EAAK,iBAGZ,CAAoB,MACpB,sBACA,mCACA,oBAAO,EAAK,sBAGZ,CAAoB,MACpB,oBACA,iCACA,oBAAO,EAET,oBAEE,CAAoB,MACpB,oBACA,mCACA,oBAAO,EAAK,yBAGZ,OACA,QACA,qCACA,eAAO,EACH,EAAK,wBACL,EAAK,yBAGT,CAAoB,MACpB,2BAEF,sBAEE,CAAoB,MACpB,yBACA,oBAAO,EAAK,EAAc,QAG1B,CAAoB,MACpB,sBACA,oBAAO,EAAK,EAAc,KAG1B,CAAoB,MACpB,uBACA,oBAAO,EAAK,EAEd,QAEE,OACA,aAKA,4BACA,kBAAiB,UAEb,MAEH,QACD,EAAiC,YAGjC,IACA,gBACI,MAEJ,sCAAa,CACS,IAEtB,kBAAiB,UAEb,MAAc,YAEjB,gBAKP,WAAM,GAKN,OAAM,EAAgB,EAAkC,aAExD,SAAS,KACP,CAAoB,MACpB,iBACA,qBAAS,CAEL,IACA,OACA,oBACA,oBAAY,MAGZ,IACA,OAAoB,MACpB,oBACA,0BAAO,EAAK,SAGZ,CACA,WACA,gCACA,4BAAO,EAET,wBAEE,IACA,4BAAoB,MACpB,8BACA,0BAAO,EAAK,8BAGZ,CACA,WACA,4BACA,eAAO,EAAK,kBAGZ,CAEI,MAGJ,uBACA,qCACA,0BAAO,EAAK,2BAGZ,CACA,WACA,mCACA,0BAAO,EAET,2BAEE,IACA,uCACI,MAEJ,sCACA,oBAAO,EACP,gDAAS,EAEX,qCAEE,CAAoB,MACpB,gCACA,iCAAO,EAKb,kCAAS,KACP,CAAoB,MACpB,aACA,iBAAS,CAEL,CAAoB,MACpB,uBACA,4BACA,0BAAO,EAAK,kBAGZ,CAAoB,MACpB,mBACA,4BACA,0BAAO,EAAK,kBAGZ,CAAoB,MACpB,mBACA,4BACA,0BAAO,EAET,oBAEE,CAAoB,MACpB,+BACA,kCACA,kCAAO,EAAK,wBAGZ,OAGA,SACA,gCACA,0BAAO,EAET,wBAEE,CACI,MACiC,gBAAjC,CACJ,MACA,4BACA,0BAAO,EAAK,kBAGZ,CAAoB,MACpB,wBACA,gCACA,0BAAO,EAAK,sBAGZ,CACI,MAEJ,sCACA,2BACA,0BAAO,EAAK,iBAGZ,CACI,MAEJ,kCACA,4BACA,0BAAO,EAET,oBAEE,CAAoB,MACpB,wBACA,gCACA,0BAAO,EAAK,sBAGZ,CACA,WACA,kCACA,oBAAO,EAkBb,iCAAM,GACJ,CAAoB,MACpB,4BACE,SACG,aAAa,wDACb,MAAM,KAAO,IAAI,MACrB,wCAGH,GAAM,EACJ,CAAoB,MACpB,uCACE,SAEI,0EAA6D,MAAgB,YAFjF,IAIG,MAAM,KAAO,IAAI,MACrB,yCAGH,GAAM,EACJ,OACA,0BACE,SACG,aAAa,2CACb,MAAM,KAAO,IAAI,MACrB,qCAGH,GAAM,EACJ,CAAoB,MACpB,iCACE,SACG,aACC,+GAED,MAAM,KAAO,IAAI,MACrB,4CAGH,GAEI,EAIJ,yBAAM,EACJ,CACA,eACE,MAAM,GAAU,EAChB,wBAAU,aACP,KAAK,IACJ,GACD,oBAHH,GAIG,MAAM,KACL,KAAI,MACL,kCACJ,EAGG,cA2CK,KACP,OACA,gBAAS,CAEP,GAJJ,cAMM,OACA,8BAAO,EACP,iBAMR,cAEA,iBAAO,OACR,qBAIC,eAGsB,YAOF,oBACrB,cAJuB,QAMQ,aAER,UAGF,wBACrB,uBAQD,CAIc,aACZ,OAAkB,OAEd,KAAO,YAAY,KAAK,aAAc,CAEtC,mBAAQ,KAAK,aAAc,CAE9B,QACF,CAGD,CAO8C,eAC5C,OAAO,GAAI,OACT,OAAO,EAAmB,KAAc,EAI3C,SAED,CAIc,aACZ,OAAkB,OAChB,CAIA,WAAM,CAEN,oBAAI,IAAc,EAChB,QAAY,WACZ,IAAY,KAAK,sBAClB,OACC,MAAM,GAAU,EAChB,WAAM,EACJ,IAAc,EAMhB,OAAM,EAEN,OAAM,EAAgB,EAAY,KAAK,KACrC,IAAc,EAAc,GAAS,IAMvC,KAAM,EAEN,iBACA,eAAY,KACb,wBACF,EACF,C,YA7Ce,0CA5mBhB,qBACA,OAEA,QACA,QACA,QACA,QACA,QAEA,QAEA,IACI,EAEJ,yBACI,EAEJ,uBACI,EAEJ,qBAA4C,EAC5C,iBAAmD,EACnD,gBAA4C,EAC5C,UACI,EAEJ,2BACI,EACA,qBAEJ,GAAK,GAAL,CAAK,WACH,cACA,kBACA,gBACD,KAJD,GAAK,MAAa,KAMlB,0BA+jBM,GAAgB,CAAC,EAAG,IAAK,KAAM,IAAK,KAC1C,GAAM,EAAiB,EAAc,QAErC,2BCpmBA,uBACA,OACA,OACA,YAEA,qBACA,cAeA,8CACA,cAEA,aACA,8BACA,QACA,QACA,gBACA,wBACA,UAEA,aACA,+BAGA,SACA,uBACA,4BACA,MACA,IACA,EAEA,gBAEA,cACA,CACA,cACA,UACA,sBACA,2BAEA,MAEA,aACA,iCACA,SAGA,YAGA,SAEA,IAEA,aACA,mCAEA,mCAKA,eAEA,YAHA,KAKA,cACA,MACA,MAIA,MACA,WACA,YACA,aACA,QACA,YACA,iBAEA,wBACA,+BACA,uDACA,MAAK,UACL,CAEA,cAGA,IAIA,QACA,UACA,cACA,kBAAK,SAEL,CACA,CAEA,aAEA,CACA,kBACA,eAEA,aACA,CACA,GAEA,aAEA,CACA,IACA,GAEA,cACA,eACA,eAEA,2BACA,gBAEA,uBACA,iBACA,eACA,gBACA,YACA,GAEA,aAEA,sBACA,6BACA,UACA,iCACA,4BACA,cAEA,KAGA,yBApJA,yBACA,UACA,GACA,EACA,UACA,oBACA,MACA,mCACA,YACA,YAEA,oCAEA,SAwIA,KACA,eAAG,SAEH,CAGA,OAGA,qBACA,uBACA,4BAGA,QACA,QAAa,UAAgB,CAC7B,SAAa,UAAgB,CAC7B,aAAiB,UAAoB,KACrC,cAAkB,UAAqB,MACvC,qBAAyB,UAA4B,aACrD,mBAAuB,UAA0B,WACjD,oBAAwB,UAA2B,YACnD,EACA,YACA,WACA,SAEA,sDC1DwB,aACtB,IAAI,EACF,kBAAO,GAGT,eAAI,EAAS,KAGX,MAAM,GAA4B,EAElC,6BACE,UADS,cAEP,MAAM,GAAyB,EAC/B,WACE,QADS,WAGZ,QALD,CAKS,QACP,SAAQ,MACT,2CAEJ,CAED,OACD,KAED,CAOsB,aACpB,MAAM,GAAI,EAAK,MACf,iBAAO,GAAI,EAAE,GACd,IAED,CAEE,aAEA,CACE,cACA,aACA,gBACA,cACA,eACE,QACF,SACE,aAAM,IAAI,OACsB,0BAA9B,CAGP,+BAED,CAKsC,aAIpC,MAAM,GAA0B,EAChC,MACE,QAAM,IAAU,oCAA6B,EAAc,KAE7D,SAAM,GAAU,EAChB,QAAM,EAAU,EAChB,QAAM,EAAQ,EACd,MAAM,EAAU,EAChB,QAAM,EACN,KAAM,EAAY,EAAa,EAE/B,OAAM,EAAO,EAAc,EAG3B,MACE,cACE,eACE,CACA,UACA,WACA,QACA,UACA,UACA,cAEJ,iBACE,kBAAO,CAAE,KAAI,KAAM,YACrB,eACE,eAAM,GAAO,EAAqB,EAClC,iBACE,CACA,UACA,cACA,QACA,UACA,UACA,OAEJ,iBACE,iBACE,CACA,UACA,WACA,QACA,UACA,UACA,cACA,UAEJ,iBACE,cACE,CACA,UACA,QACA,QACA,UACA,UACA,cACA,UAEJ,aACE,cAAO,GAAY,cAAoC,0BAA9B,CAE9B,KACD,CAW0D,eACxD,MAAM,GAAQ,EAAK,MAoBnB,gBAAO,CAAE,KAAI,KAAM,OACpB,SAOC,aACA,EAAM,GAAI,KAEV,KAAK,KAAM,KAAQ,GACjB,QAAI,IAAI,EACR,MACE,aADE,KAAK,QACI,EAIf,QACD,QAED,CAEE,aAEA,OACgB,UAAd,KAAK,MACS,aAAd,KAAK,MACS,UAAd,KAAK,MAGR,OAFG,KAAK,KASwB,aAC/B,OAAqB,WAAd,KAAK,MAAwB,EAAK,SAAW,EACrD,yDAvUD,UAyHA,IAiJA,EAwBA,uBAmBA,EAWA,uBAKA,EAIA,mBAQA,EAoBA,oBAlBE,aAEA,MAAM,GAAqB,EAE3B,kBAAK,KACH,WACE,MACE,EAAK,WACL,EAAK,UAEL,kBAKN,eACD,OAiBY,OA0BX,CAGmB,kBAAmC,MADpC,YACC,iBACf,cAzBG,OAAgB,YACrB,MAAM,GACA,WAGP,SADC,MA0BK,CAAY,cACjB,OAAO,MAAK,aACb,MAMM,CAAS,WACd,MAAM,GACN,KAIA,SAAK,KAAM,KAAY,MAAK,UAC1B,IAGA,MAAI,CAAC,EACH,GACD,QAEC,MAAM,GAAO,EAAO,IAAI,EAExB,OAAI,GACF,aADU,KAAK,OACD,EAKd,SAEH,MAED,IAEA,GAAI,EACF,iBAAkB,EAAO,IAAI,EAAS,aAGxC,OAAa,KACX,IAAI,EACJ,QACA,aAAO,EACP,MAEH,gBAED,OACD,aAeM,CACL,iBACkB,KAElB,MAAM,GAAc,KAAK,aAAa,IAAI,EAE1C,OACE,SAGF,SACE,aADE,KAAY,UACR,IACJ,gEACE,EACF,IAIJ,SAAM,GAAkB,KAAK,UAAU,UACrC,KAAsC,CAKxC,CALO,KAAE,MAAc,eAKC,CACtB,CADE,WAIJ,WAAM,GAAe,KAAK,UAAU,MAAM,EAAG,EAE7C,GAAI,KAEF,MAAM,GAAe,EAAY,KAAK,MACtC,UAAa,KAAI,iBAAM,EAAY,KAAI,CACxC,iBACC,QAAa,KAAK,EAGpB,YAAW,OAAQ,KAAW,OAAc,KAC7C,aASM,CAAe,iBAEpB,IAAI,CAAC,EACH,SAGF,WAAM,GAAe,KAAK,UAAU,UAAU,KAAK,EAAE,KAAO,EAE5D,OAAqB,CACnB,CADE,WAIJ,WAAM,GAAe,KAAK,UAAU,MAEpC,WAAW,OAAQ,KAAW,OAAc,KAC7C,aAUM,CAAa,eAClB,MAAM,GAAe,KAAK,UAAU,UAAU,KAAK,EAAE,KAAO,EAE5D,OAAqB,CACnB,CADE,WAIJ,WAAM,GAAe,KAAK,UAAU,MAAM,EAAG,EAE7C,SAAW,OAAQ,KAAW,OAAc,KAC7C,aAiBM,CAAiB,mBACtB,MAAM,GAAc,KAAK,aAAa,IAAI,EAI1C,OACE,SAGF,WAAM,GAAkB,KAAK,UAAU,UACrC,KAAsC,CAKxC,CALO,KAAE,MAAc,eAKC,CACtB,CADE,WAIJ,WAAM,GAAe,KAAK,UAE1B,QAAM,EAEN,KAAa,KAAgB,cAAQ,KAAU,CAG/C,qBAAK,GAAI,GAAI,EAAkB,EAAG,EAAI,EAAa,OACjD,IAAa,KAAE,iBAAqB,KAAE,CAMxC,0BAAK,GAAI,GAAI,EAAkB,EAAQ,CAAL,IAAQ,IACxC,MAAM,GACN,KAAM,EAAY,EAAa,EAE/B,GAAM,EAAe,EAAK,MAAM,KAC9B,KAAsB,aAAd,KAAK,MAA0B,EAAK,KAAO,EAGrD,IAAa,KAAE,cAAQ,KAAI,CAC5B,gBAED,OAAW,OAAQ,KAAW,OAAc,KAC7C,aAeM,CAAmB,qBACxB,MAAM,GAAe,KAAK,UAAU,UAAU,KAAK,EAAE,KAAO,EAI5D,OAAqB,CACnB,CADE,WAIJ,WAAM,GAAU,KAChB,aAAM,EAAe,KAAK,UAE1B,QAAa,KAAa,cAAQ,KAAO,CAKzC,0BAAK,GAAI,GAAI,EAAe,EAAQ,CAAL,IAAQ,IACrC,MAAM,GACN,KAAM,EAAY,EAAa,EAE/B,GAAM,EAAe,EAAK,MAAM,KAC9B,KAAsB,aAAd,KAAK,MAA0B,EAAK,KAAO,EAGrD,IAAa,KAAE,cAAQ,KAAI,CAC5B,gBAED,OAAW,OAAQ,KAAW,OAAc,KAC7C,aAOM,YACL,OAAW,OAAQ,KAAK,KAAM,CAAC,KAAK,MAAO,KAC5C,aAzSiB,EAApB,E,2BCpXA,aACA,aAEA,iBACA,IACA,iEAAgD,QAGhD,qBAEA,kBAEA,cACA,cAGA,8BAGA,KACA,eAAiB,KAKjB,cAA4B,WAAS,oBACrC,yFC1BA,qBACA,OAEA,IAKA,E,gBAAgB,SAAmB,KACjC,MAAM,GAAO,EAAK,QAClB,YACD,wBCXD,WACA,SAEA,IAEA,2BACA,aAQA,SACA,0BACA,qBAA2C,OAAW,IACtD,MACA,kBAEA,MAEA,CA4CA,mBArDA,0CAUA,MACA,gBACA,gDACA,UACA,SACA,oBAEA,KAOA,4BACA,SACA,WACA,6BAA6C,OAAW,OACxD,IACA,aACA,sBAGA,MAEA,gCACA,MACA,2BAEA,YAEA,mCACA,MACA,SAEA,8BACA,MACA,2BAEA,OAEA,GAIA,iBACA,IACA,cAEA,QACA,oCAEA,qEAEA,CAAC,+BC7ED,WACA,OAEA,MAEA,0BACA,aA+CA,MACA,OAEA,CAgIA,2BAhLA,wCACA,OACA,wDAEA,kDACA,yBACA,kBACA,8DACA,GACA,mDAEA,cACA,CAAO,EACP,MAEA,gCACA,OACA,KAEA,2CACA,eACA,KACA,OACA,KAAO,SACP,KACA,WACA,oBACA,YAAwC,QAAW,IACnD,MACA,YAEA,MACA,QACA,CAEA,eAEA,2BAOA,wCAKA,iCACA,EAEA,gCACA,iCACA,UACA,WAOA,gCACA,IACA,MACA,UAEA,WACA,yBAEA,gCACA,qCAEA,yEAEA,8BAEA,YAGA,UAEA,wBACA,UAEA,kCACA,OACA,QACA,WAEA,mBACA,UACA,UACA,IACA,SACA,SAEA,mCACA,aACA,UAEA,+BACA,aACA,WAGA,0CACA,OACA,WAA+C,OAAW,IAC1D,MACA,KACA,SAGA,QACA,gBAEA,qCAEA,sBACA,CAOA,gCACA,aACA,8CACA,oBAA4C,OAAW,IACvD,MACA,sBAGA,aAEA,qCACA,WACA,kDACA,sBACA,SACA,QACA,WAA8C,OAAW,IACzD,MACA,6BAEA,eACA,QAAS,OACT,qCAEA,YACA,SAEA,sCACA,yBACA,oBAEA,mDACA,OACA,yEACA,GAEA,8CACA,aACA,QACA,qBACA,8BAAsC,QAAW,IACjD,MACA,oCAEA,OACA,QAEA,GAIA,GAAC,kFC1LD,qBACA,OACA,QACA,QAIA,QACA,QACA,QACA,WAEa,OAUX,cARQ,cAAU,GAAI,GAEd,uBACA,6BAEA,mBACA,mBAGN,SAAM,GAAmB,EACvB,cAAc,KACd,uBAAe,KAGjB,YAAM,EACJ,GAAG,EACH,IAAG,EACH,QAAO,EACP,aAAQ,EACR,gBAAU,KACV,mBAAW,KACX,UAGA,wBACA,sBAGE,sBAEA,WACA,wBAEF,oBAMA,uBAKF,cAAK,OAAS,GAAI,GAClB,mBAAiB,OAAO,KAExB,WACA,YAAI,GAAG,cAAe,IACpB,CACD,IAED,aAAQ,GAAG,YAAc,KACvB,CACA,OACD,cAwBC,WAAK,OAAO,KAAK,gBAAiB,IAChC,MAAK,OAAO,GAAG,aAAc,IAC3B,YAAW,IACT,MAAM,GAAS,KAAK,OACpB,cAAO,OACP,OAAK,OACL,eAAO,OACP,OAAK,OACN,YAND,EAOD,EACF,EAEJ,EAEM,OACL,IAAI,GAOJ,OAAK,OAAO,YAAY,KAAK,oBAAqB,IAChD,MAAK,mBACL,UAAK,UAEL,OAAY,EACb,KAED,QAAK,OAAO,YAAY,KAAK,kBAAmB,IAK9C,SAAK,UAAY,EAEjB,aACD,kBAED,QAAK,OAAO,YAAY,GAAG,kBAAmB,IAC5C,MAAK,OAAO,YAAY,yBAAyB,EAClD,EAED,QAAK,OAAO,YAAY,GAAG,gBAAiB,IAC1C,MAAK,OAAO,YACZ,oBAAK,OACN,MAGD,aAAQ,KACN,iBAC+B,OAC7B,MAEA,0BACD,kBAGH,QAAK,OAAO,GAAG,QAAS,IAAM,KAAK,OAAO,YAAY,KACtD,eAAK,OAAO,GAAG,OAAQ,IAAM,KAAK,OAAO,YAAY,KAErD,4CAAiC,KACjC,aAAK,OAAO,QAAQ,kBAAgB,UACrC,cAMO,mBACF,CAAC,KAIL,qBAAK,QAAQ,KAAK,WACnB,KAGD,IAAY,iBACV,OAAO,CAAC,CAAC,KAAK,UAAY,CAAC,CAAC,KAC7B,iBAEM,CAAQ,UACb,MAAK,OAAO,GACb,WAMM,CAAU,YACf,OAAO,MAAK,QAAQ,GACrB,aAEM,cACL,OAAO,MAAK,OACb,aAGM,YACL,OAAO,MAAK,OACb,WAEM,UACL,MAAK,OACN,SAEM,QACL,MAAK,OACN,OAGM,OACL,MAAK,OACN,MAGM,CAAc,gBACnB,MAEA,YAAK,OAAO,YAAY,KAAK,aAAc,CAC5C,QAGM,CAAc,gBACnB,MAEA,YAAK,OAAO,YAAY,KAAK,aAAc,CAC5C,UAGM,CAAsB,wBAC3B,MAAK,OAAO,YAAY,KAAK,sBAAuB,CACrD,SAGM,cACL,MAAM,GAAU,OAChB,qBAAI,KACF,MAAM,GAAO,EACb,6BAAK,OAAO,YAAY,KAAK,WAAY,CAC1C,QACF,CAGM,CAGL,2BAEA,MAAK,OAAO,YAAY,KAAK,oBAC3B,CACA,cACA,QAEH,OAEM,CAEL,+BAIA,MAAM,GAAI,EACV,SAAE,2BACA,KAAK,OACL,CAAE,cAAa,WACf,IAAQ,CAEX,EAGM,CAAc,gBAGnB,MAAM,GACJ,OAAO,EACP,cAAS,EACT,aAAM,EAER,WAAK,OAAO,YAAY,KACzB,2BAOD,IAAW,WACT,OAAO,MACR,SAQD,IAAW,oBACT,OAAO,MACR,kBAEM,UACL,MAAK,OACN,SA7RmB,EAAtB,E,yBCZA,kB,0BCOA,CA2BA,qBACA,eACA,uBACA,qBACA,2BACA,2BACA,yBACA,OACA,yBACA,MASA,aA5CA,uBAIA,MAGA,YAkBA,qBAoBA,EACA,uCAGA,gBA6FA,yBACA,SACO,WACP,OACA,aACA,UACA,qBACA,eAGA,qBACA,MACA,CACA,OApGA,UACA,WACA,cACA,aAMA,YACA,SACA,WACA,OAPA,WACA,SAEA,IAOA,QAKA,IAEA,KAgEA,gCA/DA,IAGA,gBAEA,kBACA,KACA,MAES,MAIT,OACA,oBAEA,mBAOA,uBALA,uBACA,gBAEA,YACA,IAMA,UACA,qBACA,KAEA,2BACA,OACA,wBACA,kCACA,qBACA,eACA,CACA,GAAK,EAEL,UAGA,gBAGA,4BAIA,mCACA,SACA,oBACA,UACA,cAEA,aAEA,sBAEA,IAuBA,EACA,2BACA,UACA,gCACA,MACA,MAAK,EAEL,oBAEA,oCAIA,sBACA,WAGA,uFACA,KAOA,EACA,+BACA,UACA,8BAAiC,EAAQ,KACzC,iBAGA,oBACA,iCAGA,yBACA,WAGA,uFACA,KAQA,EACA,4BACA,6BAC6C,OAA7C,EAAsD,IACtD,WACA,YACA,OAGA,QACA,YAAoB,aACpB,iBACA,iBACA,iBAIA,MAOA,EACA,4BACA,qBAGA,OAFA,EACA,SAEA,OACA,KAAe,MAAW,EAC1B,gBACA,eAEA,oBACA,kBACA,UACA,OACA,KAQA,EACA,sCACA,0CACA,SACA,QAEA,kBACA,2DAGA,mCAEA,cACA,IAQA,EACA,YACA,8BACA,uBACA,iBAOA,EACA,YACA,8BACA,6BAA+C,OAAS,IACxD,SACA,iCAIA,iDACA,wBAAyC,OAAS,IAClD,gDAEA,MAKA,EACA,+BACA,OACA,GAIA,4BAHA,CACA,IACA,IAMA,EACA,6CACA,OACA,MACA,QACA,SAEA,KACA,SACA,OACA,OACA,OACA,OACA,mCACA,GACA,QACA,iBACA,eACA,wBACA,cACA,YACA,cACA,oBACA,UACA,gBACA,QACA,cAEA,kBACA,QACA,cAEA,eAGA,WACA,WACA,SACA,WACA,KAEA,uBACA,WACA,QACA,cAGA,YACA,KAEA,sBAA4C,OAAc,IAC1D,MACA,gBAxWA,MAyWA,gBAEA,IACA,SACA,KAEA,sBACA,UACA,gBACA,QACA,cAEA,kBACA,QACA,cAEA,eAIA,UAGA,QACA,wCACA,GACA,qBAEA,GAAU,aACV,QAEA,6BClYA,CACA,iBACA,OACA,UACA,KACA,MASA,CACA,eACA,oCACA,KAaA,CACA,mBAKA,QAYA,OACA,WAEA,EACA,mBAQA,KAAmB,IAAO,IAC1B,IACA,kBACA,EAIA,gBACA,aAIA,YACA,WACA,IACA,CASA,CACA,yBACA,kBACA,kBC5GA,CAkBA,uBAUA,wBACA,WACA,eAIA,SAEA,IAEA,MAKA,oBACA,gCAOA,IAEA,MAIA,oBAGA,yBAGA,GAmBA,CAhFA,yBACA,oBAcA,EAkEA,0BACA,IACA,oBAGA,eACA,kBACA,yBACA,WAMA,OACA,UAGA,wBAGA,IACA,0BCvGA,CAMA,aACA,IACA,WACA,4CAAsD,WAGtD,MACA,iBAEA,SADA,SAoQA,aACA,IACA,KACA,4CAAsD,WAGtD,uBACA,wBAGA,gCACA,8BACA,oCACA,mBACA,gCAIA,iBACA,yBAGA,6BACA,MAIA,cAKA,0BACA,8BACA,gBAEA,eAMA,iCACA,4BAEA,qBACA,kBACA,sBACA,iBACA,OA6EA,YACA,oBACA,uBACA,cACA,uBACA,yBACA,eACA,IAMA,CAkZA,aACA,IACA,KACA,4CAAsD,WAGtD,uBACA,wBAEA,uBACA,yBAGA,yCACA,kBAEA,YACA,OACA,SAEA,mCACA,MAGA,oBAEA,uEACA,uBACA,qBAEA,iBACA,sBACA,uBAEA,8DAEA,KACA,iBAGA,iBACA,oBAEA,6BAEA,QACA,WA51BA,QACA,YACA,aACA,sBAaA,2BACA,UACA,gBAIA,EACA,qBA8BA,EAEA,qCACA,uDACA,eACA,aACA,6DAGA,iBACA,mBACC,IAED,oCACA,sDACA,eACA,aACA,4DAGA,iBACA,kBACC,IAED,YACA,qCACA,SACA,gBAAmB,SACnB,OAMA,EACA,YACA,yBACA,iBACA,6CAEA,oBACA,mBAEA,yBACA,oBAiBA,EACA,YACA,2BACA,YAGA,gBACA,EACA,iBACA,uBACA,mBACA,aACA,sBACA,kBACA,MACA,wBAGA,2CACA,4BACA,+CACA,wBACA,cAEA,WACA,CACA,yBACA,gCACA,+BACA,8BACA,wDAEA,MAAK,QACL,aA7BA,KAiDA,EACA,YACA,oCACA,kBAMA,UACA,mBACA,UACA,kDAGA,OACA,8DAEA,8BACA,cAEA,oCAEA,cAEA,UACA,oBACA,kBACA,eACA,mBACA,6BACA,2BACA,YAEA,mCACA,mBAMA,kBACA,yBACA,iCACA,0CACA,kDAGA,iCAGA,sBAMA,eACA,KACA,oBACA,0BACA,iCACA,0CACA,kDAGA,iCAGA,IAEA,CACA,UAEA,EA+BA,oBAoDA,uCACA,YAQA,WACA,EACA,yBACA,uBAEA,2CACA,kDACA,6BACA,kEACA,YACA,qBAOA,sCACA,gCACA,0BAEA,WAAsD,OAAY,QAClE,OACA,OACA,wBACA,kCAEA,kBACA,8BACA,yBACA,gCAEA,iBACA,0BAGA,SAGA,WACA,OAEA,CAGA,gCADA,6BAKA,EACA,qBAIA,EACA,4CACA,eACA,+CACA,4CACA,aAAK,EACL,KAKA,IAeA,YACA,0BACA,WACA,IACA,IACA,IACA,IACA,IACA,MACA,SACA,IACA,KACA,KACA,KACA,WAEA,EACA,QACA,kBACA,IACA,MAEA,UACA,kBAEA,QACA,OACA,QAOA,gBAAyB,IAAc,WAKvC,6BAJA,KAQA,OAFA,aACA,YAES,WACT,OACA,GACA,OACA,kBACA,UACA,OAGA,WACA,6BAGA,6CACA,6BAGA,0CACA,MAGA,uBACA,OAEA,gBAEA,0BACA,QAGA,sBACA,OAEA,6BAGA,uBACA,OAEA,eAEA,wBACA,QAIA,OACA,QACA,mCAEA,OAGA,OACA,0CAEA,4BACA,iCACA,oBAKA,EACA,YACA,aACA,qBAMA,IACA,4BACA,gDAEA,SACA,2BACA,kDAGA,eACA,eAKA,EACA,YACA,6BACA,WAAuB,8BAAwC,WAC/D,WAMA,yDACA,iCAEA,wCACA,yCACA,EACA,QACA,CAGA,uBACA,QACA,CAqBA,EACA,YACA,+BACA,OACA,0BACA,mCAGA,kBAEA,oBACA,mBACA,gBACA,oBACA,wDAGA,+BACA,YAEA,2DACA,2BACA,MACA,2BACA,MACA,sCAGA,wCACA,YACA,0BAEA,OACA,CACA,wCACA,yCACA,MAEA,OACA,CAEA,OACA,QACA,UACA,YACA,UAEA,KAKA,EACA,YACA,kCACA,cAGA,0DACA,6CAA+C,OAAmB,QAClE,EAMA,EACA,YACA,8BACA,UACA,qBAGA,SACA,0CAGA,6BACA,gDAGA,eACA,MACA,uDAKA,8BACA,OACA,gCACA,gDAGA,yBACA,gCACA,wDAEA,OAMA,CACA,WAGA,4BAEA,6BAoBA,EACA,YACA,gCACA,kBACA,aACA,0CAEA,8BACA,aACA,MACA,YACA,gBAGA,sBAEA,iBACA,CACA,iCACA,kCAGA,kBAEA,oBACA,kBACA,eACA,mBACA,+CAGA,+BACA,YAEA,qCACA,aACA,iCACA,0CACA,kDAGA,MAEA,OACA,MACA,YACA,gBAEA,OAEA,EA8CA,yBAiDA,uCACA,YAIA,cACA,qBAIA,EACA,4CACA,eACA,WACA,KAAmB,mBAA2B,OAC9C,cAAqB,uCAA+C,OACpE,sCAGA,YACA,QAiBA,IACA,YACA,+BACA,OACA,0BACA,mCAKA,6BACA,uBACA,yCAKA,2BACA,kCACA,eACA,UAGA,qDASA,QACA,+CACA,YACA,qDACA,gDACA,EACA,UAEA,OAhBA,QACA,UACA,YACA,UAIA,KAcA,EACA,YACA,kCACA,wCACA,mBACA,yBACA,EAMA,EACA,YACA,8BACA,WAAmB,mBAA2B,WAC9C,YAEA,0BACA,uBACA,KAEA,QACA,CACA,WAGA,4BAEA,6BAeA,EACA,YACA,gCACA,WAAmB,qBAA2B,OAC9C,cAIA,cAGA,uEACA,6BACA,OACA,QACA,sCACA,YACA,4CACA,uCACA,EAEA,IACA,QAGA,QACA,MACA,YAEA,KAMA,EACA,YACA,yBACA,0BACA,2BACA,aAAmB,mBAA2B,OAC9C,mBACA,0BACA,qBAAqB,MAA4B,WACjD,OAEA,gCACA,QACA,mDAEA,6BACA,uBAEA,wCACA,kBACA,qBAMA,iBACA,CACA,yBACA,+CACA,qBACA,qDACA,gDACA,EACA,kBACA,8BACA,eAGA,iCACA,QACA,yDAEA,OAGA,8BACA,iEACA,6BAEA,6CCpjCA,CAQA,eAEA,SACA,kBACA,kBACA,oBACA,kCACA,MACA,6CAMA,CACA,YACA,aACA,QAEA,uBAAgB,iCAChB,EAOA,CAjCA,QAKA,IA6BA,YACA,6BACA,aACA,YAMA,EACA,2BACA,QACA,eACA,oBAEA,eACA,uBAEA,QAUA,EACA,8BACA,aACA,6BACA,0CAEA,iBACA,QAEA,8BCzEA,CAEA,GAIA,qQACA,oBACA,cACA,aAEA,0BACA,+BAKA,EACA,oBACA,OACA,KAGA,KAGA,gBAUA,GAdA,GAkBA,UACA,GAhBA,IAoBA,IAbA,SAcA,GAlBA,GAsBA,IAfA,GAgBA,GAtBA,GA0BA,GACA,GAzBA,GA6BA,IACA,mBC9DA,CACA,8CACA,4CACA,8CCPA,CAqCA,YACA,SAEA,gBAEA,4HACA,kCAEA,YACA,iDACA,8BAEA,aACA,mBACA,WAAmB,QAAiB,OACpC,IAEA,KADA,UAIA,eACA,KACA,CAEA,CAiCA,eACA,OACA,iBACA,+BACA,iBACA,gCACA,WAEA,aACA,IAEA,MACA,OACA,UACA,uBACA,mBACA,wCAGA,+BACA,kCACA,eACA,KAEA,QAAM,SACN,CAIA,GACA,eAGA,8HACA,eACA,eAEA,GADA,IAOA,CA6BA,aACA,WACA,cAEA,WAEA,yBACA,OACA,gBAKA,YACA,mDACA,aACA,uBACA,WACA,OACA,MACA,CAGA,kBACA,KACA,SAGA,KAGA,aACA,aAOA,0BACA,gBAIA,gBAHA,UACA,SAIA,CACA,QAGA,CACA,aAEA,gDACA,aACA,SACA,UACA,WACA,eAEA,wCACA,4BACA,GAGA,uCAEA,uCAKA,KAOA,CACA,YACA,OAEA,GADA,UAEA,aACG,aACH,QACA,oCACA,kBACA,mBASA,aAEA,yBACA,2BACA,IACA,iBAEA,yBAEA,MACA,CAEA,OACA,UACA,kBACA,YACA,yBACA,sBACA,YAEA,cACA,0BAEA,mBAEA,sBACA,uBAEA,KACA,4CACA,iBAGA,mBAEA,cACA,sBAEA,iBAEA,MACA,KAGA,MAGA,qBADA,OAGA,aACA,OACA,GAKA,+EAJA,sCAA0D,aAAgC,OAAE,EAC5F,IACA,KACA,aAGA,aACA,MACA,WAMA,kCACA,gCACA,SACA,sCAIA,IACA,yBACA,WAGA,cACA,CACA,SACA,OAEA,WAMA,SALA,6BAAoC,UAAwB,MAC5D,4BAAsC,UAAsB,IAC5D,8BAAwC,iBAA4B,CACpE,uCAAiD,UAAwB,MACzE,GAIA,qBAEA,4BACA,OACA,+BAAsC,CAAe,QAMrD,MAGA,CACA,eAEA,cACA,KAGA,uBACA,mBACA,IAAG,QACH,GAEA,CACA,aACA,oDACA,YACA,SACA,QACA,QAGA,KAGA,iBACA,iBACA,oBACA,OAAO,SACP,GACA,EAIA,MACA,mCACA,GACA,2BACA,wBAEA,GACA,CACA,OACA,MAEA,aACA,OAGA,iBACA,gBAGA,0BACA,oBACA,GAEA,YACA,eAEA,6BACA,4BACA,kCACA,QAEA,iCACA,sBAEA,GAEA,qBACA,UACA,cAvbA,sBAEA,KACA,GACA,KACA,mBAEA,iBAEA,KAAC,SAED,CAGA,IACA,MAGA,KAGA,OAGA,SAGA,KAGA,KAGA,wCACA,eA4BA,kBAEA,QACA,OACA,aAGA,YACA,WAEA,UACA,uBACA,mBACA,YACA,uBACA,qBAEA,aAAG,WAEH,iBACA,oBACA,OAAK,SACL,GACA,EAGA,OACA,OAGA,GA6CA,WACA,kBACA,OACA,iBAGA,SACA,gBAEA,8BACA,4BACA,WACA,GAEA,QACA,SAIA,cAIA,CACA,MAEA,OAJA,IAIC,GAsRD,iBACA,mBACA,sBACA,sBAEA,qBACA,SAEA,KACA,kBACA,aACA,2EAMA,kEACA,iBACA,gCAGA,eAKA,iBACA,sBACA,qCAGA,eAIA,wCACA,IACA,MACA,KACA,GAAK,SAEL,CACA,mBAEA,WACA,uDACA,OACA,QACA,mBACA,SAEA,uBAEA,sBAIA,aACA,sCAKA,iCACA,WAGA,wBACA,SACA,mCASA,4BACA,MACA,KAEA,IACA,mBC3gBA,CAEA,gBAIA,IAEA,EAQA,QAEA,WACA,cACA,UACA,sCACA,uBAGA,mFACA,gBACA,mBACA,qBAMA,4BAGA,UAUA,6BAGA,OACA,4BAGA,eAIA,YAGA,KACA,oFCjEA,cAEA,E,iBAAkD,aAChD,OAAO,GAAQ,EAChB,qCCFD,qBACA,OACA,OACA,OACA,WACA,iBACA,WACA,QACA,QACA,QAEA,2CAQA,8BACA,cAOA,4DACA,IACA,+CAEA,WACA,EAEA,WARA,sBASA,gCACA,yCACA,sBACA,UAEA,kDACA,mCAAuC,MAKvC,4DACG,oBACH,uBACA,0BACA,aACA,wCACA,QACA,UAOA,gCACA,SACA,sBAGA,mEACA,qBACA,qCACA,+BACA,+BACA,yBACA,wBACA,uDACA,iDACA,uDACA,kCACA,uBACA,kCACA,iBACA,8BACA,gCACA,mCACA,0CAEA,OACA,wBAQA,sBACA,gBACA,eACA,QACA,4BACA,OAMA,yCAGA,UACA,WACA,sDACA,wBACA,UAAS,6BACT,OACA,CACA,qDAEA,UAAS,gCACT,iBACA,IAAS,kBACT,UACA,IACA,EAAO,SAEP,CAEA,OACA,EAAG,OAEH,iCACA,kCACA,kCACA,iCACA,mCACA,wCACA,cACA,qDAEA,gBACA,IACA,YAEA,MACA,QAEA,kCAEA,0BACA,kCACA,kCACA,iCACA,mCACA,wCAEA,cACA,0BACA,aACA,oBACA,mBACA,UACA,gBACA,cACA,gBACA,cACA,kBACA,kBAEA,uDACA,uCACA,EACA,EACA,CAIA,EACA,EAKA,cACA,aAIA,kBACA,iBASA,kBACA,iCACA,SACA,gBAQA,iCACA,8BAGA,0CAEA,aACA,CACA,QACA,UACA,iBACA,mBACA,uBACA,0BACA,2BACA,qBACA,qBACA,yBACA,qBACA,qBACA,+CACG,uCAEH,kBAEA,YACA,8BAKA,yBAGA,cACA,cACA,aAOA,SACA,iBAEA,aAOA,EACA,gCAIA,oBAKA,kBACA,2CACA,GACA,QAEA,UACA,eAOA,EACA,+BACA,CACA,uBACA,MAEA,UAGA,6BACA,KACA,KACA,MAEA,kBACA,mBAIA,qBACA,gBAmDA,IACA,YACA,SACA,MAEA,IAAO,SAEP,WAEA,UACA,CAEA,cACA,8BACA,iBAMA,cALA,YAEA,uBAIA,OACA,+BACA,MACA,IACA,GACA,GAEA,CACA,8BACA,QAGA,UACA,OAEA,cACA,CAIA,MAIA,qCACA,+BACA,mBAKA,eACA,CArGA,qBACA,aAEA,0BACA,UAGA,iCACA,UACA,YAKA,wCACA,WAEA,0BACA,eACA,OAGY,mBAFZ,IAEA,EAAmB,IACnB,oBACA,UAEA,MAGA,MACA,IAEA,0BAEA,IAEA,QACA,uBAGA,aACA,WAEA,cAEA,OAEA,GAsDG,IACH,QAMA,EACA,8BACA,gCACA,qBACA,SAEA,QACA,CACA,eAGA,OAmBA,2CAlBA,CACA,mBAGA,cACA,QACA,iBACA,gBACA,QAAK,SACL,QACA,UACA,CAEA,KACA,UAGA,UAQA,EACA,4BACA,SAMA,cACG,2DACH,cACA,4BAMA,iBACA,WAMA,qBACA,IAKA,EACA,4BACA,OAEA,UACA,uBACA,mBAEA,kDACA,QACA,gBACA,SAEA,GAMA,EACA,4BACA,OAMA,qCACA,SACA,OAEA,8BACA,GACA,uBACA,MACA,EAMA,oBAMA,mCACA,QACA,gBACA,SACA,EAMA,EACA,oCACA,OACA,UAEA,wBACA,cAMA,GACA,kDAEA,eACA,gBAGA,iBACA,qBAGA,cACA,UACA,6CACA,yCACA,eACA,cACA,kBAEA,oBAEA,UAOA,6BAOA,mCAIA,GAEA,UACA,kBACA,SAQA,KACA,QACA,GAEA,aACA,SACA,cACA,kCACA,SAEA,iBACA,+CAEA,iBACA,UACA,gBACA,CAEA,gBAtEA,iCAwEA,UACA,oBAMA,UAHA,oCAQA,YAGA,gBACA,0CACA,4BACA,4BACA,2BACA,6BACA,kCACA,mBACA,MAGA,sBACA,KACA,EAAG,OACH,WAMA,EACA,gCACA,YACA,eAEA,OAMA,gDACA,oCACA,GACA,SACA,0BACA,WAAS,UAET,SACA,oCACA,OAAS,UAIT,gBACA,CAAG,eAGH,aACA,sDAMA,gEACA,IACA,qDACA,IAAO,SAEP,CAGA,6CACA,EAGA,iCACA,UAKA,EACA,mCACA,YAEA,+BACA,SACA,oDACA,qBAGA,2BAGA,gBACA,WAOA,EACA,iCACA,OAEA,2BACA,eAEA,iDACA,MACA,oBACA,SAEA,GAMA,EACA,0CAEA,2BACA,iLACG,wCACH,sIACG,+BACH,oGACG,+BACH,iEACG,kCACH,gCAGA,OAMA,EACA,gCACA,UAEA,wBACA,IACA,oBACK,iBACL,qBACK,cACL,oBACK,aACL,oBACK,cACL,sBACK,gBACL,mBAEA,QACA,OACA,aACG,iBACH,cACG,cACH,aACG,aACH,aACG,cACH,eACG,gBACH,YAEA,kBAIA,EACA,qCACA,cAKA,uCAEA,kBAEA,yBACA,EAEA,cACA,mBACA,4BACA,CACA,KAIA,0BAHA,2DAIA,cACA,QACA,SAEA,IACA,EAGA,OA5BA,OACA,aAEA,QA0BA,0CACA,CACA,KAIA,uDAHA,wCAIA,0BACA,mBACA,SAEA,IACA,EAEA,qBCl1BA,0BACA,iBACA,OACA,OACA,qBA8BA,UACA,YACA,EA9BA,iBACA,CACA,uBACA,MAGA,kBACA,eACA,SACA,SAEA,mCACA,OAEA,YAGA,uBAcA,eAZA,gBACA,WACA,oBACA,gCAEA,aACA,gCACA,0BChCA,aAkCA,mBAEA,cACA,OACA,KAGA,qBACA,SACA,mBACA,yBAEA,YAEA,mBACA,cACA,wBAIA,WAFA,KADA,KAKA,mBACA,OACA,CACA,YAGA,iBACA,OACA,KAEA,QAEA,eACA,mBACA,iBAEA,qBACA,YAEA,0BA1EA,iBACA,OACA,WACA,aACA,cACA,yBAuEA,UACA,MACA,EAvEA,iBACA,CACA,uBACA,MAGA,2BAEA,uBACA,eAEA,mBAEA,0BACA,SAEA,sBACA,mBAA0C,iBAAsC,oCAEhF,2BACA,OACA,KAGA,iCChCA,aAOA,iBACA,aAcA,CACA,QACA,UACA,eAAO,SACP,6CACA,uBACA,QACA,aAGA,6BACA,cACA,SAEA,SACA,UACA,gBACA,aAAO,SACP,2DACA,yBAEA,UACA,OAEA,CACA,MAtCA,0BAEA,mBACA,eAEA,0BAEA,wCAA8D,iBAAqB,mBAEnF,UACA,YAEA,IA4BA,iBACA,WAEA,qBACA,cAEA,SAEA,SAEA,iBACA,MACA,WAEA,aAEA,oBACA,SACA,gCACA,gBAEA,YACA,wBACA,uBACA,KACA,IAEA,UACA,eACA,eACA,cAEA,iBACA,aAYA,OACA,UACA,IACA,SAdA,CAIA,iBACA,KAEA,KAGA,GAOA,CACA,eACA,IACA,sBACA,eACA,QACA,mEACA,WAAG,SACH,CACA,QACA,YA7GA,OACA,WACA,iBACA,kBACA,mBA2GA,UACA,CACA,6BClHA,uBACA,OACA,OACA,WAYA,UAVA,eACA,WAEA,aACA,iBAGA,gBACA,uCCbA,uBACA,OACA,UACA,mBAqBA,UAnBA,iBACA,CACA,uBACA,MAGA,cAEA,eACA,SACA,SAEA,mCACA,OACA,YAGA,uCCtBA,0BACA,qBAEA,sBACA,mBACA,IACA,0BACA,kCACA,wBACA,gCACA,sBACA,8BAEA,6BCfA,aAEA,aAyBA,UACA,CACA,YAzBA,eACA,UACA,2BACA,4BACA,uBACA,gBACA,wCACA,SAEA,WAiBA,gBAfA,aACA,IAEA,QACA,YACA,KACA,YAAG,SACH,OACA,MACA,iCACA,0BCvBA,uBACA,OACA,UAsBA,WAqEA,UACA,CACA,aArEA,eACA,MACA,+BAEA,4CACA,iBAEA,aACA,CACA,QAGG,eACH,WACA,eACA,qBACA,SAEA,cACA,CACA,QAGA,oBAEA,4CACA,iBAEA,aACA,CACA,gBAKA,iBACA,GAkCA,iBAhCA,aACA,IACA,sBACA,QACA,iCACA,yCACA,CACA,QAEA,QAAG,KACH,WACA,eACA,UAEA,OADA,sBAEA,CACA,QAGA,gBACA,iCACA,yCACA,CACA,gBAGA,cACA,qBC3FA,0BACA,iBACA,OACA,OACA,OACA,WAEA,eACA,QACA,iBAEA,qBACA,QACA,gBAEA,kCA0CA,UACA,eACA,EA1CA,iBACA,GACA,2BAEA,4BACA,SACA,SACA,iBACA,SACA,cACA,yBACA,YACA,gBACA,eACA,SACA,SACA,0BACA,OACA,YAGA,kBAGA,QAmBA,kBAjBA,eACA,WACA,cAEA,eACA,WACA,YACA,mBACA,eACA,yBACA,oBACA,OACA,wCCvDA,0BACA,iBACA,OACA,OACA,qBAmDA,UACA,YACA,EAnDA,eACA,gBACA,YACA,OACA,YAEA,MAEA,KACA,SACA,SACA,0BACA,CACA,gDACA,cAGA,eACA,eACA,SACA,OACA,uBACA,OACA,SAGA,SAEA,MAwBA,eAtBA,aACA,WACA,cAEA,UACA,GACA,YAAG,SACH,CAEA,0CADA,eAGA,WACA,eACA,yBACA,iBAEA,gBACA,mCCrDA,0BACA,iBACA,OACA,OACA,qBAuCA,UACA,YACA,EAvCA,aACA,aACA,kBACA,OACA,SAEA,KAEA,iBACA,yBACA,eACA,eACA,SACA,OACA,oBACA,OACA,SAGA,MACA,KAoBA,eAlBA,WACA,IACA,MACA,KACA,WAAG,UACH,WAEA,qBACA,aACA,iBAGA,gCACA,wBCzCA,uBACA,QACA,YAEA,UAEA,cACA,4BACA,4BACA,4BAEA,4BACA,4BACA,4BACA,4BAEA,+BACA,kCACA,kCACA,kCACA,oCCpBA,aAMA,aACA,CACA,CACA,SACA,QACA,OACA,QACA,QAEA,wBACA,YACA,QACA,kBACA,IAEA,kCACA,EAEA,iBACA,OAEA,EACA,uBACA,MAGA,QACA,wDACA,qEACA,0CACA,6EAEA,oCAEA,wBACA,MACA,6CACA,oCACA,CACA,YAEA,4BACA,WAGA,uBACA,KAEA,CACA,IACA,EAYA,CACA,iBACA,CACA,KACA,OAIA,gCACA,UACA,oBAIA,SACA,oBAGA,gBACA,cAGA,gCACA,MACA,IACA,2BAEA,SACA,iBACA,MAGA,eACA,wBAEA,WACA,OACA,KAEA,IAEA,mBACA,CACA,KACA,OAEA,uCAGA,2BAEA,uBAEA,wBAEA,uBACS,UACT,cAEA,aAEA,WAEA,EACA,GAEA,iBACA,IAEA,GACA,KAEA,sBAGA,WACA,eACA,IAAG,SACH,IACA,kBAEA,OAEA,OAEA,IACA,KACA,WAAG,SACH,IACA,kBAEA,OAEA,OAEA,GACA,cAEA,WAEA,cAEA,mBACA,CACA,KAEA,sBAEA,UAKA,qCACA,8CACA,kBACK,YACL,mBAEA,KAEA,IACA,GAEA,iBACA,CACA,KACA,OAEA,yCACA,YAEA,cACA,OAEA,iBAEA,+BACA,iBAIA,kBACA,UACA,UAGA,YACA,EACA,EAIA,CACA,eACA,IAEA,QACA,GAEA,SACA,wDACA,uCACA,2DAEA,uCACA,KACA,YAAG,SACH,IACA,kBAIA,OACA,qBAEA,QAEA,IAEA,MACA,oBAEA,QAEA,aAAG,SACH,IACA,kBACK,UACL,uBACK,aACL,kBAEA,QACA,QACA,EAEA,iBACA,CACA,KAEA,sBAGA,WACA,GACA,YAAG,SACH,IACA,mBACK,yDACL,iBACK,eACL,kBAEA,OACA,EAEA,eACA,CACA,KACA,uCAEA,cAOA,cACA,MACA,MACA,WACA,eACA,QAAO,SAAa,CACf,OACL,iBAIA,YAnTA,OACA,OAEA,SAkTA,YACA,0BCvTA,aA0BA,aACA,IACA,MACA,KACA,cAAG,SACH,UACA,aAEA,gBACA,KACA,YACA,aACA,gBArCA,iBACA,OACA,OACA,OAEA,qBACA,iBACA,qBACA,aAOA,WACA,+BAEA,OACA,SAEA,MAJA,GAKA,YAZA,gCAEA,WAEA,IASA,EAAC,GAgBD,UACA,CACA,eACA,eACA,WACA,6BC7CA,aAQA,oBAEA,wBAGA,0BAGA,YALA,MACG,oBAKH,OAEA,mCACA,oDAGA,8BACA,oCAIA;kEAnBA,OAoBA,SACA,cACA,eAEA,cAEA,qBACA,WACA,eACA,SACA,OACA,sBACA,OACA,KAGA,eAEA,uBACA,qCAEA,SACA,aAEA,WACG,SACH,MAEA,qBACA,iBACA,eACA,aAEA,qBACA,gCACA,iBACA,YAEA,6BACA,iBACA,YACA,uCACA,kCACA,mBACA,GAEA,uBACA,cACA,aACA,aAEA,qBACA,UACA,0BACA,OACA,KAEG,gBACH,yBAA4B,KACzB,qBACH,IAEA,qBACA,OACA,6CACA,OACA,KAGA,YACA,aAEA,qBACA,WACA,4DACA,+BAA2C,QAC3C,yBACA,sBACA,0BACA,WACA,GAEA,mBACA,kBACA,OACA,OACA,iCAEA,SAEA,KAEA,uBACA,cACA,mBACA,0BAA2D,oCAAyB,sBAEpF,OACA,WAEA,qBACA,WACA,OACA,kBACA,OACA,iBAGA,UAEA,mBACA,aACA,SACA,KAEA,cAEA,qBACA,WACA,eAEA,eADA,IAGA,uBACA,WACA,cACA,gBACA,SACA,oBACA,OACA,KAGA,eAEA,qBACA,cACA,SAEA,QACA,kCAGA,UACA,QAEA,iCAKA,iDACA,eAEA,QACA,kCAEA,UACA,mBAA8C,iBAA8C,oCAM5F,wBACA,mBAAmD,sBAAuB,YAE1E,OAIA,aAEA,iBACA,YACA,OACA,OAEA,eAEA,CACA,eACA,8BACA,4BACA,iCACA,aAEA,iBACA,UACA,SACA,mBAEA,mCAAoD,UACpD,aAEA,aAAuB,UAGvB,eAEA,iBACA,cACA,YACA,YAAW,UACX,sCACA,gBAEA,kEACA,mBAA0C,iBAAsC,oCAEhF,SACA,OACA,aAhPA,OACA,UACA,cACA,mBAEA,kCA6OA,6BCnPA,aAMA,iBACA,IACA,uBAAY,CAGZ,iBACA,eAEA,cACA,qBACA,4CAEA,aADA,UAGA,CACA,0BAEA,eAEA,UAEA,cACA,GACA,iBACA,IAAG,SACH,sBACA,qBACA,cACA,gBACA,QAAK,KAGL,IACA,MACA,KACA,WAAO,SACP,CACA,OACA,qBACA,OACA,CAEA,CACA,mBAhDA,OACA,WAEA,sCA+CA,6BCnDA,aAMA,mBACA,IACA,sBACA,MACG,SACH,wBAAY,CAGZ,cACA,qBACA,0DACA,SACA,IAEA,SACA,eAEA,MACA,0BAEA,eAEA,sBACA,MAEA,4BACA,IACA,YACA,OAEA,iBACA,UACA,mCACA,8BACA,GACA,OACA,UACA,GAKA,MACA,wBAGA,qBACA,SACA,OAGA,IACA,aAzDA,OACA,WAEA,sCAwDA,6BC5DA,aAOA,kBAEA,0BAGA,gBACA,mCACA,oDAGA,8BACA,oCAIA;kEAdA,SAgBA,uBAEA,uBACA,mCACA,KACA,YAEA,mBACA,qBACA,mBACA,WAEA,mBACA,oCACA,YAEA,8BACA,uBACA,YACA,uCACA,gCACA,kBAEA,qBACA,cACA,WACA,WAEA,mBACA,MACA,mBACA,cACG,gBACH,6BAAwB,KAExB,oBAEA,mBACA,OACA,qCACA,kCACA,QACA,iCAIA,eACA,WAEA,mBACA,MACA,aAEA,sBACA,0BACA,gBAEA,YACA,wBACA,uBACA,KACA,IAEA,iDAEA,SACA,eACA,aAEA,qBACA,gBACA,qBACA,8BAAuD,oCAAyB,sBAEhF,YACA,UAEA,mBACA,UACA,aACA,yBACA,MAEA,iBACA,+BACA,YAEA,mBACA,WACA,cACA,YACA,aACA,YAEA,mBACA,SAEA,qBACA,kCAGA,UACA,eACG,qBACH,IACA,MACA,KACA,eAAK,SAIL,mDACA,iBACA,OACA,MACA,kCAEA,UACA,uBAAsC,iBAA8C,oCAMpF,sCACA,uBAA2C,sBAAuB,YAElE,YACA,OACA,EAEA,eACA,UACA,gBACA,gBAEA,CACA,eACA,8BACA,4BACA,iCACA,aAEA,eACA,WACA,eACA,MACA,KACA,WAAG,SACH,6BAAuC,UACvC,YACA,OACA,QAAU,UACV,YAEA,eACA,OAAS,UAAkB,YAC3B,2BACA,oBAEA,oEACA,uBAAoC,iBAAsC,oCAE1E,MACA,mBA3LA,OACA,UACA,mBAEA,sCAyLA,yBChMA,aAEA,UAEA,WACA,cACA,mBAEA,wBACA,cAAgB,aAEhB,oCAEA,MAKA,wDAJA,kCACA,8BAEA,uBCjBA,kBAEA,UAEA,WACA,gBAMA,+BAEA,mBAEA,YAEA,UACA,eACA,UACA,iBAEA,qBACA,cACA,SAEA,sBAGA,oBACA,gBAA6C,SAAgB,IAC7D,MACA,aAGA,6CAEA,8BACA,0BACA,sBAEA,2CACA,aACO,uCACP,oBAGA,2CACA,oBAGA,sCACA,KAEA,OACA,wEAQA,kBACA,kBAIA,qBACA,YACA,YACA,QACA,mCAhBA,GACA,OAIA,EAaA,gBACA,+BAEA,mBAEA,WACA,eACA,UAEA,uBACA,kBACA,mBACA,sBAEA,OAGA,oBACA,gBAA6C,SAAgB,IAC7D,MACA,aAGA,4BACA,0BACA,sBAEA,6BACA,6BAGA,uCACA,KAEA,MACA,oBAEA,GACA,8BACA,4DACA,mBAEA,QACA,OA/GA,CACA,aAGA,6BCVA,kB,6BCAA,SAEA,eACA,MAEA,iDAEA,sBAEA,CAEA,oBADA,aAEA,GACA,SACA,KAAC,WAED,oBACA,yBACA,GACA,YACA,YAEA,UAEA,WAKA,cAkNA,yBACA,gCACA,UACA,sBACA,UACA,EACA,GAEA,cAEA,uBACA,IACA,UACA,WAAO,SACP,UACA,OACA,CACA,GAGA,cAEA,2BACA,kCACA,UACA,sBACA,UACA,EACA,GAEA,cAEA,yBACA,IACA,UACA,aAAO,SACP,UACA,OACA,CACA,GAEA,cAIA,yBACA,gBAMA,sBACA,6BAEA,6BACA,UACA,OAVA,uBACA,MAEA,UAQA,gBACA,WACA,GAEA,cAIA,uBACA,WACA,cACA,UAGA,wBAFA,6BACA,aAEA,GAcA,cACA,IACA,GAEA,YACA,kBAEA,gCAEA,qDAKA,kBACA,kBAvTA,oCACA,sCA2HA,yBACA,GACA,oBAEA,yBAEA,kBAKA,mCACA,sBACA,MACA,KACA,EACA,EACA,EAEA,4BACA,iCAIA,aACA,KACA,KACA,KACA,gBACA,IAAO,QACP,CACA,QACA,GACA,YAAW,UAEX,QAEA,YACA,CACA,QACA,CAEA,CAjKA,MACA,oBAiKA,kBACA,yCACA,mCAEA,kBAGA,sCACA,sBACA,MACA,KACA,EACA,EACA,EAEA,+BACA,sBACA,WAEA,KADA,KAEA,KACA,mBACA,IAAS,QACT,CACA,QACA,GACA,YAAa,UAEb,QAEA,YACA,CACA,QAGA,+BAA8C,uBAC9C,2BAEA,EAEA,CAjMA,gBACA,oBACA,qBAEA,oBACA,oBACA,qBAEA,wBACA,4BACA,6BAEA,4BACA,4BACA,6BAEA,uBACA,kBACA,mBAEA,sBACA,0BACA,2BAGA,aACA,iCACA,YACA,WACA,0BAEA,KACA,mCACA,YACA,WACA,0BAYA,GACA,kCAAuC,uBACvC,YACA,QACA,qBACA,OACA,wBACA,mBACA,uCACA,qBACA,IACA,kBAEA,SACA,IACA,EACA,UACA,WAGA,cACA,KACA,GAAM,IAIN,2BACA,wBACA,IACA,8BACA,OACA,eACA,8BACA,MACA,MAEA,uCACA,UACA,CACA,UACA,mBAGA,CAEA,SADA,aACG,IAEH,4BAAyC,2BACzC,WAEA,OACA,UACA,iBAAO,SACP,4BACA,CACA,IACA,QACA,CACA,OAEA,EAAI,IAEJ,2BCjJA,CA+rBA,aACA,MACA,yBACA,KAMA,SAvsBA,QACA,OACA,QACA,QACA,OACA,WAEA,SAQA,iCACA,qBACA,WACA,YAIA,EACA,eAQA,cACA,iCACA,OAMA,6CACA,aAGA,aACA,mBACA,eAEA,KACA,4CACA,SACA,QAMA,oBACA,+BACA,UACA,sBAMA,sBACA,yBACA,uBACA,gCACA,mCACA,sCAOA,mCACA,kBAEA,8CACA,oBACA,MACA,KACA,EAEA,KACA,2CAEA,kBASA,EACA,2BACA,cAuBA,GAEA,OACA,iBAEA,UAEA,cA+CA,MACA,YACA,QACA,WAEA,GAEA,eAEA,eAGA,gBAkCA,SACA,qCAEA,aACA,YACA,KAGA,iBACA,mBACA,IACA,EAEA,gDAvIA,KAGA,KACA,wBASA,YACA,mCACA,MAKA,QAUA,0CAEA,sCACA,mDAQA,8DACA,SACA,mDACA,0CACA,SAEA,SACmB,OAUnB,eATA,WASoB,GACpB,4BACA,uCACA,yBAA2C,eAC3C,uDAEA,cACA,sCACA,UACA,6CACA,iCACA,EACA,qBAKA,aAcA,sDAGA,0CACA,GACA,UAEA,mCACA,OACA,WACA,mBAEA,SACA,QAEA,KASA,oBACA,OACA,6CACA,GAKA,UAeA,eACA,IASA,EACA,+BACA,gBAeA,GACA,kBAGA,uCAEA,UAGA,qCACA,QACA,EAMA,CA/BA,uBACA,MAGA,UACA,UACA,KACA,uBACA,GAKA,WA0CA,mCACA,kCAMA,iDACA,UACA,aAAG,qBACH,WACA,KAMA,4BAxCA,kBAMA,OAEA,aAGA,SAGA,OACA,IACA,EAMA,YAmBA,GACA,OACA,GAMA,EACA,8BACA,OACA,UACA,KACA,QACA,GAEA,iBACA,yBACA,uBACA,eACA,gBAEA,SAEA,CAmCA,SAlCA,+BACA,aACA,iBACA,SAKA,+BACA,UACA,aAAG,qBACH,WACA,MAEA,wBACA,SAGA,gBAEA,8BACA,0BACA,sBACA,aACA,QAEA,2BACA,0BACA,sBACA,aACA,UACA,GAEA,IAOA,EACA,4BACA,OAEA,oCACA,SACA,mBACA,SAEA,OAEA,aACA,QAMA,EACA,uCACA,kCACA,aACA,KAEA,0BACA,OACA,eAGA,YAEA,OAEA,kDACA,wBACA,uBACA,OAEA,8BAEA,wBACA,oEACA,0CAEA,iBAMA,EACA,yCACA,OAEA,UACA,yEACA,SACA,uBACA,SAEA,OAEA,0BACA,mDACA,SACA,gBACA,qBAEA,oBAEA,mDACA,sBAEA,mBAQA,EACA,+BACA,WAEA,wBACA,oBAEA,oEACA,4DAGA,sDACA,qCAKA,0CAEA,0BAOA,oCACA,sBAGA,mBACA,IAKA,EACA,4BACA,iDACA,aAAiB,CACjB,QAAG,EACH,KAMA,EACA,8BACA,OACA,yCAGA,cACA,6CAGA,6CACA,iCACA,2CAEA,cACA,SAGA,UACA,qCAEA,UACA,IAWA,EACA,iCACA,cACA,KAWA,EACA,+BACA,oBACA,MAEA,cACA,qBACA,yBAGA,0CACA,sDACA,8CACA,oBAGA,kBACA,SAGA,mBAGA,eACA,KAMA,EACA,iCACA,8BACA,SAOA,EACA,0BACA,aACA,kCACA,0BAEA,wBACA,mEACA,uEAGA,eACA,IAOA,EACA,0CACA,aAmBA,IAKA,KACA,gBACA,kBAEA,GAEA,OA7BA,KACA,SACA,qBACA,wBACA,EAKA,WACA,yCACA,oBAEA,eAiBA,oBASA,uBAzBA,yCACA,kBAEA,wBAwBA,OAJA,GAUA,EACA,4CACA,OAEA,wCACA,UACA,oBAAG,qCACH,4CACA,aAAG,WACH,QAQA,EACA,kCACA,MACA,oBAEA,YAOA,EAWA,4BACA,kCACA,sDACA,8CAEA,2CACA,iBACA,6BChtBA,SACA,OACA,WAQA,iCACA,cACA,mBACA,gBACA,YACA,0BACA,OACA,QAIA,eAQA,EACA,6CACA,OACA,KAEA,cAKA,iBAAuB,yBACvB,sCAKA,oCAEA,kCACA,sDAGA,sCACA,IAIA,0BAEA,oBACA,8BAGA,0CACA,OACA,6BACA,kBAEA,KACA,2BAEA,+CACA,GACA,UAGA,SACA,UAOA,EACA,2BACA,cACA,UAOA,EACA,6BACA,cAGA,GAIA,0BACA,UACA,WAEA,OATA,gEAUA,CACA,IACA,EAMA,EACA,+BACA,aACA,2BC7BA,aACA,QACA,gBAEA,IAEA,CAvGA,iBACA,aACA,sCAEA,eAEA,WACA,uDACA,CACA,QACA,iCAEA,aACA,MAIA,aAHA,0BAEA,qBAGA,mBACA,OACA,YAGA,SACA,iCAEA,SACA,kBACA,YACA,+CACA,CACA,sBACA,kBACA,cACA,gBACA,kBACA,YAIA,qBACA,0DAIA,YACA,OACA,OACA,OACA,OACA,OAEA,wBACA,KACA,uBACA,QACA,aACA,QACA,YACA,kBACA,mBACA,WACA,mBACA,cAEA,KACA,GACA,IAGA,KACA,IAGA,KACA,sBACA,OAGA,YACA,gBACA,mCACA,KACA,eACA,WACA,6CACA,KAGA,mBACA,yBACA,qBACA,QACA,EACA,IASA,CACA,OACA,WACA,eACA,aACA,WACA,aACA,eACA,WAEA,aAMA,oBACA,gBACA,iEACA,OACA,QACA,CAAC,GAVD,CACA,WACA,OACA,SACA,cAOA,oBACA,GACA,2EACA,OACA,QACA,CAAC,GAED,mCACA,OACA,2BCvIA,SACA,QACA,OACA,WAQA,gCACA,QACA,aAEA,oBACA,oBAEA,eACA,yBACA,gCACA,kEACA,oDACA,8BACA,yBAEA,UACA,8CACA,8BACA,EAEA,EAIA,EACA,EAIA,cACA,iBASA,SACA,iCACA,SACA,gBAGA,eACA,KAEA,UACA,eACA,mBACA,KACA,QACA,UACA,sBACA,yBACA,2BACA,qBACA,eACA,iBACA,qBACA,+CAGA,+CACA,6BAEA,yBAGA,eACA,YACA,UAEA,gCACA,kBACA,oBACA,iBCxFA,kB,sBCAA,kB,wBCAA,SACA,OACA,QACA,SACA,YACA,eAQA,8BACA,QACA,aAEA,aACA,oBACA,sBACA,wBACA,iBACA,uBACA,gBAEA,WACA,8BAEA,KAEA,eAIA,WACA,iBAOA,OACA,kCACA,MAEA,sBACA,0BACA,GAEA,WACA,cAGA,8BACA,WACA,eACA,8BACA,WACA,eAAc,gBACd,+BACA,uCAGA,UACA,sCACA,OAEA,0BACA,CACA,IAEA,wBACA,GACA,SAEA,KACA,QAEA,sCACA,QASA,EACA,iCACA,OAEA,KACA,uBACA,MAGA,UACA,QACA,iBACA,CACA,QACA,UAKA,eACA,gBACA,cAGA,QACA,gBACA,cAIA,oCACA,WACA,wDAGA,eAIA,iBAEA,eACA,SACA,EAOA,EACA,+BACA,CACA,uBACA,MAGA,UACA,YAEA,oBACA,QACA,QAGA,mBACA,uBACA,qBAGA,eACA,uBACA,qBAGA,qCACA,OACA,wDAGA,qBAEA,SACA,sBACA,QACA,QAAO,SACP,OACA,KAGA,GACA,OACA,EAMA,EACA,8BACA,MAEA,SACA,OACA,MACA,EAEA,EA2CA,2BA1CA,GACA,SAEA,IACA,QACA,SAGA,mBACA,uBACA,qBAGA,eACA,uBACA,qBAGA,aACA,cAEA,0BACA,CAIU,sBAHV,kBACA,IAEA,EAAiB,IACjB,OACA,yBACA,MAAO,SACP,QACA,UAGA,GACA,IAEA,2BACA,QACA,UAEA,uBC3OA,aACA,uBACA,OAGA,aACA,0CACA,kCAGA,aACA,2CACA,kCAfA,WAuBA,YACA,uBACA,uBACA,mBARA,WACA,cACA,sBCZA,SACA,QACA,OACA,OACA,OACA,QACA,QACA,WACA,mBACA,kBACA,WAQA,wBACA,cAQA,4DACA,IACA,+CAEA,WACA,EAEA,OAdA,eAMA,sBASA,gCACA,yCACA,sBACA,UAEA,kDACA,kCAAuC,OAKvC,4DAEA,aACA,6BACA,0BACA,+BACA,4CACA,QACA,UAMA,gCAGA,+BAGA,mEACA,qBACA,6BACA,qCACA,2BACA,wCACA,4CACA,wBACA,oCACA,yCACA,4BACA,oBACA,iCACA,4CACA,wCAEA,OACA,wBAQA,sBACA,gBACA,eACA,QACA,kBACA,2BACA,gBACA,IAIA,EACA,EAIA,cACA,iBASA,OACA,iCACA,SACA,gBAQA,iCACA,8BAGA,0CAEA,KACA,uBAGA,kBACA,CACA,QACA,UACA,iBACA,mBACA,uBACA,0BACA,2BACA,yBACA,yBACA,qBACA,iBACA,qBACA,+CAGA,kCACA,6BAGA,UAMA,8BAUA,yBAGA,cACA,uBACA,SACA,aAEA,SAjBA,0BACA,YAGA,aAoBA,EACA,gCACA,SACA,gCACA,uCACA,GACA,QAMA,sBAEA,kBACA,2CACA,GACA,QAEA,mCACA,GACA,QACA,SAOA,EACA,+BACA,gBAiDA,IACA,YACA,eACA,IAAK,SAEL,WAEA,UACA,CAEA,cACA,wBACA,MACA,gBAMA,cALA,YAEA,uBAIA,OACA,+BACA,MACA,IACA,GACA,GAEA,CACA,8BACA,QAGA,UACA,OAEA,cACA,CAEA,MAEA,qCACA,+BACA,mBAKA,eACA,CAhGA,uBACA,MAGA,mCACA,iBACA,oBACA,KACA,KAEA,yBACA,UAGA,iCACA,UACA,YAGA,YACA,oBAEA,QADA,WAGA,0BACA,CAIU,sBAHV,kBACA,IAEA,EAAiB,IACjB,oBACA,UAEA,MAGA,MACA,IAEA,0BACA,IACA,QACA,uBAEA,gBACA,OAEA,EAuDA,EACA,8BACA,gCACA,eACA,KAEA,QACA,CACA,eAGA,OAgBA,2CAdA,CACA,mBAGA,cACA,QACA,iBACA,gBACA,QAAK,SACL,QACA,UACA,CAEA,IAQA,EACA,4BACA,SAMA,cAEA,2DAMA,SACA,WAGA,yEAKA,KACA,IAKA,EACA,4BACA,OAEA,UACA,uBACA,mBAEA,mDACA,QACA,gBACA,SAEA,GAMA,EACA,4BACA,OAKA,yBACA,4CAQA,SACA,OAEA,8BACA,GACA,uBACA,MACA,EAMA,oBAMA,mCACA,QACA,gBACA,SACA,WAxBA,QA8BA,EACA,oCACA,OACA,UAEA,wBACA,cAOA,GACA,oBACA,gBAGA,iBACA,UACA,6CACA,2BACA,yCACA,eACA,cACA,kBAGA,oBAEA,UAMA,6BAOA,mCAIA,GAEA,UACA,kBACA,SAOA,KACA,QACA,GAEA,aACA,eACA,SAEA,oCACA,8CAEA,iBAEA,mBACA,wBACA,EACA,CAEA,gBAhEA,iCAkEA,UACA,oBAKA,UAHA,oCAQA,6BACA,KACA,WAGA,YACA,KACA,EAAG,OACH,aAGA,gCACA,sBACA,6BAIA,kBACA,cAMA,8CALA,OAGA,kCAQA,EACA,+BACA,sBACA,6BAOA,wCACA,2DACA,YACA,GAMA,EACA,sDACA,OAGA,OAFA,WAGA,4CACA,gCAMA,iCACA,SAGA,wBACA,qCACA,+BACA,OACA,YASA,EACA,kDACA,OACA,KAEA,aAGA,kCAAiC,EAAO,IACxC,sBACA,mBACA,6BACA,4BACA,2BAEA,2CAIA,6BACA,UAFA,KAGA,EACA,CAGA,QACA,8CAEA,2BACA,GACA,wBACA,wBAGA,OACA,GAOA,EACA,iCACA,OAEA,2BACA,eAEA,iDACA,MACA,oBACA,SAEA,mBCrqBA,CAEA,QAEA,SACA,OACA,QACA,OACA,QACA,UACA,SACA,OACA,QACA,GAEA,SACA,OACA,YACA,cACA,YACA,cACA,aACA,cACA,cACA,sBCxBA,CAEA,QAEA,SACA,OACA,OACA,OACA,UACA,QACA,QACA,GAEA,SACA,OACA,WACA,cACA,gBACA,aACA,aACA,yBCpBA,CAEA,QAEA,SACA,OACA,OACA,OACA,OACA,OACA,QACA,SACA,UACA,QACA,QACA,GAEA,SACA,OACA,WACA,cACA,YACA,YACA,cACA,cACA,eACA,aACA,aACA,4BClCA,YAEA,oBACA,kFACA,6BACA,wDACA,QACA,CAAC,qBCPD,YAEA,oBACA,sCACA,+BACA,OAGA,oBAEA,WACA,CAAC,qBCXD,YAEA,uBACA,mBACA,U,mBCJA,YAEA,oBACA,qBACA,YACA,kBACA,mBACA,uBACA,yBAEA,SACA,CAAC,gBCXD,CACA,qBACA,cA0CA,uBACA,YACA,QAEA,cACA,IACA,MAIA,2BAHA,GACA,KACA,IAIA,gBACA,YACA,EAOA,cANA,QACA,eACA,iBACA,0BACA,iBACA,UAIA,gBACA,QAAgB,gBAChB,KACA,UACA,cACA,WACA,YACA,GACA,UACA,kBACA,aACA,eACA,EACA,MACA,kBACA,aACA,cAIA,qBACA,eACA,kBACA,OAAwB,KAAoB,KAC5C,IACA,sBAKA,UACA,QAEA,MAnGA,yBACA,IACA,4BACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,kBAEA,eACA,4BACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCACA,oCAEA,cACA,4BACA,oCACA,oCACA,2BACA,oCACA,2BAGA,sCACA,OAEA,SA4DA,oBCvGA,qBACA,OACA,QACA,wCACA,UACA,qDACA,wDACA,6BACA,wDACA,0EACA,aACA,aACA,0DACA,aACA,aACA,wCACA,aACA,0DACA,wDACA,+EACA,sBACA,aACA,wDACA,sCACA,+BACA,sBACA,aACA,wCACA,wCACA,6BACA,sBAEA,WAYA,4BAXA,KACA,2BACA,kCACA,WACA,2BAIA,OACA,mBC1CA,aACA,0CACA,MAEA,aADA,qBAEA,iBAAuC,OAAW,IAClD,YACA,YACA,K,gBCeA,CAEA,mBAEA,oBACA,QACA,8BAIA,oCACA,2BACA,gCAIA,kEAqBA,MAAC,gBCrCD,CAEA,SACA,YAEA,MACA,UAEA,WACA,WACA,cACA,iBACA,eACA,cACA,qBAEA,cACA,YACA,cACA,eACA,aACA,gBACA,aACA,cACA,aACA,aAEA,gBACA,cACA,gBACA,iBACA,eACA,kBACA,eACA,gBAGA,gBACA,cACA,gBACA,iBACA,eACA,kBACA,eACA,gBAEA,KAEA,kCACA,OACA,YACA,uBACA,yBACA,GAAC,mBCtED,CACA,YACA,yBCRA,kB,2CCmBA,CAEA,kBAEA,yBACA,CAkBA,mBACA,KAEA,yBAIA,IACA,GACA,EAKA,yBACA,wBACA,yBACA,sBACA,wBACA,iCAMA,OAAuB,MAAoB,UAC3C,KACA,gBAA4B,KAM5B,WACA,UAIA,QACA,4DACA,KAA2B,MAAkB,UAC7C,sBAMA,SAEA,YADA,qCAEA,mBACA,6BAIA,MACA,QACA,CACA,QAAK,IACL,MAGA,4BACA,CAqBA,gBACA,IAEA,iHAOA,iBAEA,eACA,0BACA,gEAA2B,UAAkB,UAC7C,aACA,SACA,kCACA,oCACA,oBAEA,UAKA,uBACA,OACA,0CACA,MACA,iBACA,oCACA,uBAEA,UAOA,OAAK,EACL,GACA,gBCzKA,kB,0BCQA,SACA,QACA,QACA,OACA,WAQA,iCACA,QACA,aAEA,eACA,yBACA,gCACA,kEACA,oDACA,8BACA,qBACA,iCACA,kBACA,yCAgBA,OACA,6DACA,CAKA,qBAGA,+EACA,WAEA,IACA,sCACK,sBACL,2BAGA,6DACA,qBACA,mBApCA,+BAEA,SACA,8CACA,8BACA,EASA,EA0BA,EACA,EAIA,cACA,iBASA,UACA,iCACA,SACA,gBAGA,eACA,KAEA,UACA,eACA,mBACA,KACA,QACA,UACA,sBACA,yBACA,yBACA,2BACA,qBACA,eACA,oBACA,oBACA,qBACA,qBACA,2CAGA,uCACA,4CAEA,iCAOA,YACA,YACA,0BC3HA,CAEA,kCACA,CACA,gBACA,4BACA,eACA,OACC,IACD,+BACA,CACA,gBACA,4BACA,eACA,IACC,IACD,+BACA,CACA,gBACA,4BACA,eACA,IACC,IACD,iCACA,CACA,gBACA,4BACA,eACA,MACC,4vBCnCD,qBACA,QAEA,IAAM,EAAI,OAEV,EAAE,IACA,CAAuB,UACrB,OAAI,QAAS,UAAY,EAC1B,sBACD,EAAsB,SACpB,OAAI,OAAQ,UAAY,EACzB,sBACD,EAAsB,SACpB,OAAI,OAAQ,UAAY,EACzB,sBACD,EAAuB,UACrB,OAAI,QAAS,UAAY,EAC1B,sBAZK,iCCuCyB,aAC/B,CAQA,UAAM,GAGJ,IAHoB,WAIpB,YAGF,QACD,0BAED,CAGS,YACP,OAAO,CAAC,EAAQ,SACjB,IAEQ,YACP,OACE,QAAQ,IAAqB,QAC7B,QAAM,GAAI,QAEb,WAGD,CAkDsB,aACpB,KAAI,KACJ,gCAAM,GAAS,EACf,iBAAU,KAGR,GACA,UACD,gBACF,GA8E2C,aAC1C,KAAS,8CAAyC,EAAW,MAEzD,IASF,MAAM,GAAe,EAAK,OAAO,KAE/B,IACE,MAAM,GAAM,EAEZ,eAAO,GAAI,UAAY,EAAkB,IAAI,EAAI,SAAS,MAAM,EAAG,CACpE,GAJD,CAIS,QACP,CAED,WAFK,MAA6C,oCAAvC,CACV,MAEH,CAED,GAAI,EAAc,aAChB,CADwC,KAAa,SACxC,EAEb,QAAI,MAAkD,wCAA5C,CAEb,GAGF,CAED,CAIoC,aAEhC,OAA+B,6BAAU,QAAQ,SAMpD,IAED,CAsUS,YACP,MAAM,GAAS,GAAI,GAwBnB,eAAO,QAAQ,IACb,GAEE,cAEH,MAED,KAAO,UAAU,IACf,GACA,SAAO,sBACL,CACA,yBAAU,EACV,2BAAmB,EAGrB,yBACA,OACA,SAAK,KACH,QAEH,IAED,KAEA,OACD,GAED,CAImB,aAEf,KAGE,WAGL,I,kDA7oBD,EAEA,eACA,OACA,OAIA,QACA,QACA,QACA,QACA,QACA,QAIA,QACA,QACA,QACA,QAIA,QACA,QAEA,QACA,YAEA,MAAI,iBACJ,qBAEA,GAAI,GAA+B,KAEnC,KAAM,GAAa,EAEnB,SACA,MAAI,EAIJ,KAAI,EAA0C,QAoCxC,GAEN,sBAAM,EAAoB,GAAI,KAAI,CAIhC,sBAAkB,IAMlB,2BAAkB,IACnB,kBAED,MAAI,GAAG,oBAAqB,IAQ3B,CARD,GAUA,QAAQ,GAAG,oBAAsB,KAC/B,GAAQ,EACR,2BAAY,cACZ,KACD,IAJD,GAMA,GAA4B,MACxB,GAAmC,CAAtB,SAAQ,KAAK,OAC5B,MAAM,GAAM,QAAQ,KAEpB,GAAM,EAAU,EAEd,0BACA,OACG,MAAM,KACL,KAAI,MAA4C,mCAAtC,CACX,KAHH,GAIG,KAAK,IACJ,OACD,MAEH,MAAmC,QAEtC,MAaD,GAGA,MACA,GAAK,GACH,MAAM,GAAwB,MAC9B,8BAEA,SAAI,GAAG,kBAAiC,OAGpC,KAAI,EACF,iBAGF,UAAI,CAAC,EACH,eAGF,SAGF,SACD,IAGC,YAEH,MAED,CAAI,qBACF,YACD,8BAED,MAAI,GAAG,wBAAyB,IAE9B,OAAI,GAAG,WAAoB,OACzB,GACA,iBACD,IACF,EA4BD,MAwDI,QAAQ,IACV,mDACE,KAEF,gHACD,+BAED,MAAI,GAAG,QAAS,IACd,CAIA,SAAY,EAEZ,UAAkB,QAAQ,KAE1B,MAEA,WAAK,mBACH,mBACE,eACA,4BACA,KACA,yCAIJ,8CAAQ,GACN,wCAC+B,OAQ7B,MAAM,GAAU,EAEhB,oBAAM,EAAc,OAKpB,wBAEE,IAFE,KAgBJ,cAZE,2BACE,IADE,QAIJ,kBAUF,UAAK,KAAM,KAAW,GAAgB,mBAIpC,MAAM,GAAM,EAEZ,MACE,GAGF,cAAM,GAAc,EAMlB,sBAEI,EAAY,QAAU,EACxB,QAMF,MAAI,EAAY,UAAY,EAC1B,YAAQ,QAAU,EAClB,QAGL,OAZG,IAcJ,CAEE,cACA,wBAEH,cAGH,aAAQ,GAAG,aAA6C,KACtD,MAAM,CAEJ,eAEH,gBAMD,aAAQ,GACN,oBACC,GAA8B,CAAE,QAC/B,MAAM,GAAc,OAEpB,wBAIA,IAJI,WAIE,GAAW,EACjB,mBAAI,KACF,MAAM,GAAS,gBAAc,gBAAgB,EAC7C,QAAM,EAAY,CAAE,eAAgB,IAAQ,CAA1B,EAA4B,OAAQ,EACtD,UAA0B,UAAQ,EACnC,OACF,EAGH,aAAQ,GACN,oBAGE,OAEA,IAEA,WAAM,GAAc,OAEpB,wBACE,IADE,KAKJ,gBAJY,MACV,kDAGG,KAAc,QACjB,MAAM,CAAE,KAER,WAAM,EAAW,EAMf,qBACE,EAAkB,kBAClB,EAAS,UAAY,EAErB,YAAS,QAAU,EACnB,QAGF,mBAAiC,oBAAtB,CAEd,GAED,CACE,cACA,wBAEH,cAGH,aAAQ,GACN,uBAC+B,OAC7B,MAAM,GAAO,EAAiB,mBAAO,KACnC,EAAM,OAAO,KAGf,6BAAM,EAAS,gBAAc,gBAAgB,EAC7C,UAAK,MAAM,CACZ,UAOH,aAAQ,GAAG,eAAgB,IAEvB,MAEH,aAED,aAAQ,GACN,gCAEE,GACA,CACE,cACA,aAKA,GAAU,KACR,GACD,+BAEJ,EAGH,aAAQ,GACN,MACgD,SAC9C,GACD,QAGH,aAAQ,GACN,qBAC+B,OAC7B,CACD,IAGH,aAAQ,GACN,oBAEE,GACA,CACE,QACA,QACA,cAGF,GACE,cAAK,iBAOR,SAGH,aAAQ,GACN,gBACO,QAA8B,CAAE,UACrC,MAAM,GAAgB,EACtB,eACE,EAAc,WAAW,YACzB,EAAc,WAEd,kBAAI,KAAgC,uBAA3B,CAGX,OACA,MACE,MAAM,SACN,gBACD,IAHD,CAGS,QACP,KAAI,MAAwC,iCAAlC,CACV,KACD,IACD,GAAM,OAAO,KAAK,uBAAwB,CAC3C,UAGH,aAAQ,GACN,sBACC,GAA8B,CAAE,UAC/B,GAAQ,OAEJ,kBAAI,MAAqC,2BAA/B,CAIP,YAAc,EACjB,gBAEA,6BAGL,qBAEJ,GA1RD,GA4RA,MAAI,GAAG,WAAY,IACjB,GAAU,KACR,GACD,MACF,EAJD,GAMA,MAAI,GAAG,uBAAgC,OACrC,GAAS,GAAG,aAAsB,OAEhC,GACA,sBAAM,GAAwC,4BAA/B,CACf,OACA,gCAAsB,qBACvB,SAGD,KAAS,GAAG,gBAAyB,OACnC,GACA,sBAAM,GAAwC,4BAA/B,CACf,OACA,gCAAsB,wBACvB,SACF,EAhBD,GAkBA,MAAI,GACF,oBAC8C,eAC5C,CAEA,QAAU,KACR,GACD,2BACF,EARH","file":"main.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 135);\n","module.exports = require(\"path\");","var fs = require('fs')\nvar polyfills = require('./polyfills.js')\nvar legacy = require('./legacy-streams.js')\nvar clone = require('./clone.js')\n\nvar util = require('util')\n\n/* istanbul ignore next - node 0.x polyfill */\nvar gracefulQueue\nvar previousSymbol\n\n/* istanbul ignore else - node 0.x polyfill */\nif (typeof Symbol === 'function' && typeof Symbol.for === 'function') {\n  gracefulQueue = Symbol.for('graceful-fs.queue')\n  // This is used in testing by future versions\n  previousSymbol = Symbol.for('graceful-fs.previous')\n} else {\n  gracefulQueue = '___graceful-fs.queue'\n  previousSymbol = '___graceful-fs.previous'\n}\n\nfunction noop () {}\n\nvar debug = noop\nif (util.debuglog)\n  debug = util.debuglog('gfs4')\nelse if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || ''))\n  debug = function() {\n    var m = util.format.apply(util, arguments)\n    m = 'GFS4: ' + m.split(/\\n/).join('\\nGFS4: ')\n    console.error(m)\n  }\n\n// Once time initialization\nif (!global[gracefulQueue]) {\n  // This queue can be shared by multiple loaded instances\n  var queue = []\n  Object.defineProperty(global, gracefulQueue, {\n    get: function() {\n      return queue\n    }\n  })\n\n  // Patch fs.close/closeSync to shared queue version, because we need\n  // to retry() whenever a close happens *anywhere* in the program.\n  // This is essential when multiple graceful-fs instances are\n  // in play at the same time.\n  fs.close = (function (fs$close) {\n    function close (fd, cb) {\n      return fs$close.call(fs, fd, function (err) {\n        // This function uses the graceful-fs shared queue\n        if (!err) {\n          retry()\n        }\n\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n      })\n    }\n\n    Object.defineProperty(close, previousSymbol, {\n      value: fs$close\n    })\n    return close\n  })(fs.close)\n\n  fs.closeSync = (function (fs$closeSync) {\n    function closeSync (fd) {\n      // This function uses the graceful-fs shared queue\n      fs$closeSync.apply(fs, arguments)\n      retry()\n    }\n\n    Object.defineProperty(closeSync, previousSymbol, {\n      value: fs$closeSync\n    })\n    return closeSync\n  })(fs.closeSync)\n\n  if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || '')) {\n    process.on('exit', function() {\n      debug(global[gracefulQueue])\n      require('assert').equal(global[gracefulQueue].length, 0)\n    })\n  }\n}\n\nmodule.exports = patch(clone(fs))\nif (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {\n    module.exports = patch(fs)\n    fs.__patched = true;\n}\n\nfunction patch (fs) {\n  // Everything that references the open() function needs to be in here\n  polyfills(fs)\n  fs.gracefulify = patch\n\n  fs.createReadStream = createReadStream\n  fs.createWriteStream = createWriteStream\n  var fs$readFile = fs.readFile\n  fs.readFile = readFile\n  function readFile (path, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$readFile(path, options, cb)\n\n    function go$readFile (path, options, cb) {\n      return fs$readFile(path, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$readFile, [path, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$writeFile = fs.writeFile\n  fs.writeFile = writeFile\n  function writeFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$writeFile(path, data, options, cb)\n\n    function go$writeFile (path, data, options, cb) {\n      return fs$writeFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$writeFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$appendFile = fs.appendFile\n  if (fs$appendFile)\n    fs.appendFile = appendFile\n  function appendFile (path, data, options, cb) {\n    if (typeof options === 'function')\n      cb = options, options = null\n\n    return go$appendFile(path, data, options, cb)\n\n    function go$appendFile (path, data, options, cb) {\n      return fs$appendFile(path, data, options, function (err) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$appendFile, [path, data, options, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  var fs$readdir = fs.readdir\n  fs.readdir = readdir\n  function readdir (path, options, cb) {\n    var args = [path]\n    if (typeof options !== 'function') {\n      args.push(options)\n    } else {\n      cb = options\n    }\n    args.push(go$readdir$cb)\n\n    return go$readdir(args)\n\n    function go$readdir$cb (err, files) {\n      if (files && files.sort)\n        files.sort()\n\n      if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n        enqueue([go$readdir, [args]])\n\n      else {\n        if (typeof cb === 'function')\n          cb.apply(this, arguments)\n        retry()\n      }\n    }\n  }\n\n  function go$readdir (args) {\n    return fs$readdir.apply(fs, args)\n  }\n\n  if (process.version.substr(0, 4) === 'v0.8') {\n    var legStreams = legacy(fs)\n    ReadStream = legStreams.ReadStream\n    WriteStream = legStreams.WriteStream\n  }\n\n  var fs$ReadStream = fs.ReadStream\n  if (fs$ReadStream) {\n    ReadStream.prototype = Object.create(fs$ReadStream.prototype)\n    ReadStream.prototype.open = ReadStream$open\n  }\n\n  var fs$WriteStream = fs.WriteStream\n  if (fs$WriteStream) {\n    WriteStream.prototype = Object.create(fs$WriteStream.prototype)\n    WriteStream.prototype.open = WriteStream$open\n  }\n\n  Object.defineProperty(fs, 'ReadStream', {\n    get: function () {\n      return ReadStream\n    },\n    set: function (val) {\n      ReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  Object.defineProperty(fs, 'WriteStream', {\n    get: function () {\n      return WriteStream\n    },\n    set: function (val) {\n      WriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  // legacy names\n  var FileReadStream = ReadStream\n  Object.defineProperty(fs, 'FileReadStream', {\n    get: function () {\n      return FileReadStream\n    },\n    set: function (val) {\n      FileReadStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n  var FileWriteStream = WriteStream\n  Object.defineProperty(fs, 'FileWriteStream', {\n    get: function () {\n      return FileWriteStream\n    },\n    set: function (val) {\n      FileWriteStream = val\n    },\n    enumerable: true,\n    configurable: true\n  })\n\n  function ReadStream (path, options) {\n    if (this instanceof ReadStream)\n      return fs$ReadStream.apply(this, arguments), this\n    else\n      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)\n  }\n\n  function ReadStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        if (that.autoClose)\n          that.destroy()\n\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n        that.read()\n      }\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (this instanceof WriteStream)\n      return fs$WriteStream.apply(this, arguments), this\n    else\n      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)\n  }\n\n  function WriteStream$open () {\n    var that = this\n    open(that.path, that.flags, that.mode, function (err, fd) {\n      if (err) {\n        that.destroy()\n        that.emit('error', err)\n      } else {\n        that.fd = fd\n        that.emit('open', fd)\n      }\n    })\n  }\n\n  function createReadStream (path, options) {\n    return new fs.ReadStream(path, options)\n  }\n\n  function createWriteStream (path, options) {\n    return new fs.WriteStream(path, options)\n  }\n\n  var fs$open = fs.open\n  fs.open = open\n  function open (path, flags, mode, cb) {\n    if (typeof mode === 'function')\n      cb = mode, mode = null\n\n    return go$open(path, flags, mode, cb)\n\n    function go$open (path, flags, mode, cb) {\n      return fs$open(path, flags, mode, function (err, fd) {\n        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))\n          enqueue([go$open, [path, flags, mode, cb]])\n        else {\n          if (typeof cb === 'function')\n            cb.apply(this, arguments)\n          retry()\n        }\n      })\n    }\n  }\n\n  return fs\n}\n\nfunction enqueue (elem) {\n  debug('ENQUEUE', elem[0].name, elem[1])\n  global[gracefulQueue].push(elem)\n}\n\nfunction retry () {\n  var elem = global[gracefulQueue].shift()\n  if (elem) {\n    debug('RETRY', elem[0].name, elem[1])\n    elem[0].apply(null, elem[1])\n  }\n}\n","'use strict'\n\nexports.fromCallback = function (fn) {\n  return Object.defineProperty(function () {\n    if (typeof arguments[arguments.length - 1] === 'function') fn.apply(this, arguments)\n    else {\n      return new Promise((resolve, reject) => {\n        arguments[arguments.length] = (err, res) => {\n          if (err) return reject(err)\n          resolve(res)\n        }\n        arguments.length++\n        fn.apply(this, arguments)\n      })\n    }\n  }, 'name', { value: fn.name })\n}\n\nexports.fromPromise = function (fn) {\n  return Object.defineProperty(function () {\n    const cb = arguments[arguments.length - 1]\n    if (typeof cb !== 'function') return fn.apply(this, arguments)\n    else fn.apply(this, arguments).then(r => cb(null, r), cb)\n  }, 'name', { value: fn.name })\n}\n","'use strict'\nconst u = require('universalify').fromCallback\nconst mkdirs = u(require('./mkdirs'))\nconst mkdirsSync = require('./mkdirs-sync')\n\nmodule.exports = {\n  mkdirs,\n  mkdirsSync,\n  // alias\n  mkdirp: mkdirs,\n  mkdirpSync: mkdirsSync,\n  ensureDir: mkdirs,\n  ensureDirSync: mkdirsSync\n}\n","module.exports = require(\"electron\");","module.exports = require(\"fs\");","module.exports = require(\"util\");","'use strict'\nconst u = require('universalify').fromPromise\nconst fs = require('../fs')\n\nfunction pathExists (path) {\n  return fs.access(path).then(() => true).catch(() => false)\n}\n\nmodule.exports = {\n  pathExists: u(pathExists),\n  pathExistsSync: fs.existsSync\n}\n","module.exports = require(\"stream\");","/*\n * common.js: Internal helper and utility functions for winston\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar util = require('util'),\n    crypto = require('crypto'),\n    cycle = require('cycle'),\n    fs = require('fs'),\n    StringDecoder = require('string_decoder').StringDecoder,\n    Stream = require('stream').Stream,\n    config = require('./config');\n\n//\n// ### function setLevels (target, past, current)\n// #### @target {Object} Object on which to set levels.\n// #### @past {Object} Previous levels set on target.\n// #### @current {Object} Current levels to set on target.\n// Create functions on the target objects for each level\n// in current.levels. If past is defined, remove functions\n// for each of those levels.\n//\nexports.setLevels = function (target, past, current, isDefault) {\n  var self = this;\n  if (past) {\n    Object.keys(past).forEach(function (level) {\n      delete target[level];\n    });\n  }\n\n  target.levels = current || config.npm.levels;\n  if (target.padLevels) {\n    target.levelLength = exports.longestElement(Object.keys(target.levels));\n  }\n\n  //\n  //  Define prototype methods for each log level\n  //  e.g. target.log('info', msg) <=> target.info(msg)\n  //\n  Object.keys(target.levels).forEach(function (level) {\n\n    // TODO Refactor logging methods into a different object to avoid name clashes\n    if (level === 'log') {\n      console.warn('Log level named \"log\" will clash with the method \"log\". Consider using a different name.');\n      return;\n    }\n\n    target[level] = function (msg) {\n      // build argument list (level, msg, ... [string interpolate], [{metadata}], [callback])\n      var args = [level].concat(Array.prototype.slice.call(arguments));\n      target.log.apply(target, args);\n    };\n  });\n\n  return target;\n};\n\n//\n// ### function longestElement\n// #### @xs {Array} Array to calculate against\n// Returns the longest element in the `xs` array.\n//\nexports.longestElement = function (xs) {\n  return Math.max.apply(\n    null,\n    xs.map(function (x) { return x.length; })\n  );\n};\n\n//\n// ### function clone (obj)\n// #### @obj {Object} Object to clone.\n// Helper method for deep cloning pure JSON objects\n// i.e. JSON objects that are either literals or objects (no Arrays, etc)\n//\nexports.clone = function (obj) {\n  //\n  // We only need to clone reference types (Object)\n  //\n  var copy = {};\n\n  if (obj instanceof Error) {\n    // With potential custom Error objects, this might not be exactly correct,\n    // but probably close-enough for purposes of this lib.\n    copy = { message: obj.message };\n    Object.getOwnPropertyNames(obj).forEach(function (key) {\n      copy[key] = obj[key];\n    });\n\n    return copy;\n  }\n  else if (!(obj instanceof Object)) {\n    return obj;\n  }\n  else if (obj instanceof Date) {\n    return new Date(obj.getTime());\n  }\n\n  for (var i in obj) {\n    if (Array.isArray(obj[i])) {\n      copy[i] = obj[i].slice(0);\n    }\n    else if (obj[i] instanceof Buffer) {\n        copy[i] = obj[i].slice(0);\n    }\n    else if (typeof obj[i] != 'function') {\n      copy[i] = obj[i] instanceof Object ? exports.clone(obj[i]) : obj[i];\n    }\n    else if (typeof obj[i] === 'function') {\n      copy[i] = obj[i];\n    }\n  }\n\n  return copy;\n};\n\n//\n// ### function log (options)\n// #### @options {Object} All information about the log serialization.\n// Generic logging function for returning timestamped strings\n// with the following options:\n//\n//    {\n//      level:     'level to add to serialized message',\n//      message:   'message to serialize',\n//      meta:      'additional logging metadata to serialize',\n//      colorize:  false, // Colorizes output (only if `.json` is false)\n//      align:     false  // Align message level.\n//      timestamp: true   // Adds a timestamp to the serialized message\n//      label:     'label to prepend the message'\n//    }\n//\nexports.log = function (options) {\n  var timestampFn = typeof options.timestamp === 'function'\n        ? options.timestamp\n        : exports.timestamp,\n      timestamp   = options.timestamp ? timestampFn() : null,\n      showLevel   = options.showLevel === undefined ? true : options.showLevel,\n      meta        = options.meta !== null && options.meta !== undefined && !(options.meta instanceof Error)\n        ? exports.clone(cycle.decycle(options.meta))\n        : options.meta || null,\n      output;\n\n  //\n  // raw mode is intended for outputing winston as streaming JSON to STDOUT\n  //\n  if (options.raw) {\n    if (typeof meta !== 'object' && meta != null) {\n      meta = { meta: meta };\n    }\n    output         = exports.clone(meta) || {};\n    output.level   = options.level;\n    //\n    // Remark (jcrugzz): This used to be output.message = options.message.stripColors.\n    // I do not know why this is, it does not make sense but im handling that\n    // case here as well as handling the case that does make sense which is to\n    // make the `output.message = options.message`\n    //\n    output.message = options.message.stripColors\n      ? options.message.stripColors\n      : options.message;\n\n    return JSON.stringify(output);\n  }\n\n  //\n  // json mode is intended for pretty printing multi-line json to the terminal\n  //\n  if (options.json || true === options.logstash) {\n    if (typeof meta !== 'object' && meta != null) {\n      meta = { meta: meta };\n    }\n\n    output         = exports.clone(meta) || {};\n    output.level   = options.level;\n    output.message = output.message || '';\n\n    if (options.label) { output.label = options.label; }\n    if (options.message) { output.message = options.message; }\n    if (timestamp) { output.timestamp = timestamp; }\n\n    if (options.logstash === true) {\n      // use logstash format\n      var logstashOutput = {};\n      if (output.message !== undefined) {\n        logstashOutput['@message'] = output.message;\n        delete output.message;\n      }\n\n      if (output.timestamp !== undefined) {\n        logstashOutput['@timestamp'] = output.timestamp;\n        delete output.timestamp;\n      }\n\n      logstashOutput['@fields'] = exports.clone(output);\n      output = logstashOutput;\n    }\n\n    if (typeof options.stringify === 'function') {\n      return options.stringify(output);\n    }\n\n    return JSON.stringify(output, function (key, value) {\n      return value instanceof Buffer\n        ? value.toString('base64')\n        : value;\n    });\n  }\n\n  //\n  // Remark: this should really be a call to `util.format`.\n  //\n  if (typeof options.formatter == 'function') {\n    options.meta = meta;\n    return String(options.formatter(exports.clone(options)));\n  }\n\n  output = timestamp ? timestamp + ' - ' : '';\n  if (showLevel) {\n    output += options.colorize === 'all' || options.colorize === 'level' || options.colorize === true\n      ? config.colorize(options.level)\n      : options.level;\n  }\n\n  output += (options.align) ? '\\t' : '';\n  output += (timestamp || showLevel) ? ': ' : '';\n  output += options.label ? ('[' + options.label + '] ') : '';\n  output += options.colorize === 'all' || options.colorize === 'message'\n    ? config.colorize(options.level, options.message)\n    : options.message;\n\n  if (meta !== null && meta !== undefined) {\n    if (meta && meta instanceof Error && meta.stack) {\n      meta = meta.stack;\n    }\n\n    if (typeof meta !== 'object') {\n      output += ' ' + meta;\n    }\n    else if (Object.keys(meta).length > 0) {\n      if (typeof options.prettyPrint === 'function') {\n        output += ' ' + options.prettyPrint(meta);\n      } else if (options.prettyPrint) {\n        output += ' ' + '\\n' + util.inspect(meta, false, options.depth || null, options.colorize);\n      } else if (\n        options.humanReadableUnhandledException\n          && Object.keys(meta).length === 5\n          && meta.hasOwnProperty('date')\n          && meta.hasOwnProperty('process')\n          && meta.hasOwnProperty('os')\n          && meta.hasOwnProperty('trace')\n          && meta.hasOwnProperty('stack')) {\n\n        //\n        // If meta carries unhandled exception data serialize the stack nicely\n        //\n        var stack = meta.stack;\n        delete meta.stack;\n        delete meta.trace;\n        output += ' ' + exports.serialize(meta);\n\n        if (stack) {\n          output += '\\n' + stack.join('\\n');\n        }\n      } else {\n        output += ' ' + exports.serialize(meta);\n      }\n    }\n  }\n\n  return output;\n};\n\nexports.capitalize = function (str) {\n  return str && str[0].toUpperCase() + str.slice(1);\n};\n\n//\n// ### function hash (str)\n// #### @str {string} String to hash.\n// Utility function for creating unique ids\n// e.g. Profiling incoming HTTP requests on the same tick\n//\nexports.hash = function (str) {\n  return crypto.createHash('sha1').update(str).digest('hex');\n};\n\n//\n// ### function pad (n)\n// Returns a padded string if `n < 10`.\n//\nexports.pad = function (n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n};\n\n//\n// ### function timestamp ()\n// Returns a timestamp string for the current time.\n//\nexports.timestamp = function () {\n  return new Date().toISOString();\n};\n\n//\n// ### function serialize (obj, key)\n// #### @obj {Object|literal} Object to serialize\n// #### @key {string} **Optional** Optional key represented by obj in a larger object\n// Performs simple comma-separated, `key=value` serialization for Loggly when\n// logging to non-JSON inputs.\n//\nexports.serialize = function (obj, key) {\n  // symbols cannot be directly casted to strings\n  if (typeof key === 'symbol') {\n    key = key.toString()\n  }\n  if (typeof obj === 'symbol') {\n    obj = obj.toString()\n  }\n\n  if (obj === null) {\n    obj = 'null';\n  }\n  else if (obj === undefined) {\n    obj = 'undefined';\n  }\n  else if (obj === false) {\n    obj = 'false';\n  }\n\n  if (typeof obj !== 'object') {\n    return key ? key + '=' + obj : obj;\n  }\n\n  if (obj instanceof Buffer) {\n    return key ? key + '=' + obj.toString('base64') : obj.toString('base64');\n  }\n\n  var msg = '',\n      keys = Object.keys(obj),\n      length = keys.length;\n\n  for (var i = 0; i < length; i++) {\n    if (Array.isArray(obj[keys[i]])) {\n      msg += keys[i] + '=[';\n\n      for (var j = 0, l = obj[keys[i]].length; j < l; j++) {\n        msg += exports.serialize(obj[keys[i]][j]);\n        if (j < l - 1) {\n          msg += ', ';\n        }\n      }\n\n      msg += ']';\n    }\n    else if (obj[keys[i]] instanceof Date) {\n      msg += keys[i] + '=' + obj[keys[i]];\n    }\n    else {\n      msg += exports.serialize(obj[keys[i]], keys[i]);\n    }\n\n    if (i < length - 1) {\n      msg += ', ';\n    }\n  }\n\n  return msg;\n};\n\n//\n// ### function tailFile (options, callback)\n// #### @options {Object} Options for tail.\n// #### @callback {function} Callback to execute on every line.\n// `tail -f` a file. Options must include file.\n//\nexports.tailFile = function(options, callback) {\n  var buffer = new Buffer(64 * 1024)\n    , decode = new StringDecoder('utf8')\n    , stream = new Stream\n    , buff = ''\n    , pos = 0\n    , row = 0;\n\n  if (options.start === -1) {\n    delete options.start;\n  }\n\n  stream.readable = true;\n  stream.destroy = function() {\n    stream.destroyed = true;\n    stream.emit('end');\n    stream.emit('close');\n  };\n\n  fs.open(options.file, 'a+', '0644', function(err, fd) {\n    if (err) {\n      if (!callback) {\n        stream.emit('error', err);\n      } else {\n        callback(err);\n      }\n      stream.destroy();\n      return;\n    }\n\n    (function read() {\n      if (stream.destroyed) {\n        fs.close(fd);\n        return;\n      }\n\n      return fs.read(fd, buffer, 0, buffer.length, pos, function(err, bytes) {\n        if (err) {\n          if (!callback) {\n            stream.emit('error', err);\n          } else {\n            callback(err);\n          }\n          stream.destroy();\n          return;\n        }\n\n        if (!bytes) {\n          if (buff) {\n            if (options.start == null || row > options.start) {\n              if (!callback) {\n                stream.emit('line', buff);\n              } else {\n                callback(null, buff);\n              }\n            }\n            row++;\n            buff = '';\n          }\n          return setTimeout(read, 1000);\n        }\n\n        var data = decode.write(buffer.slice(0, bytes));\n\n        if (!callback) {\n          stream.emit('data', data);\n        }\n\n        var data = (buff + data).split(/\\n+/)\n          , l = data.length - 1\n          , i = 0;\n\n        for (; i < l; i++) {\n          if (options.start == null || row > options.start) {\n            if (!callback) {\n              stream.emit('line', data[i]);\n            } else {\n              callback(null, data[i]);\n            }\n          }\n          row++;\n        }\n\n        buff = data[l];\n\n        pos += bytes;\n\n        return read();\n      });\n    })();\n  });\n\n  if (!callback) {\n    return stream;\n  }\n\n  return stream.destroy;\n};\n\n//\n// ### function stringArrayToSet (array)\n// #### @strArray {Array} Array of Set-elements as strings.\n// #### @errMsg {string} **Optional** Custom error message thrown on invalid input.\n// Returns a Set-like object with strArray's elements as keys (each with the value true).\n//\nexports.stringArrayToSet = function (strArray, errMsg) {\n  if (typeof errMsg === 'undefined') {\n    errMsg = 'Cannot make set from Array with non-string elements';\n  }\n  return strArray.reduce(function (set, el) {\n    if (!(typeof el === 'string' || el instanceof String)) {\n      throw new Error(errMsg);\n    }\n    set[el] = true;\n    return set;\n  }, Object.create(null));\n};\n","module.exports = require(\"os\");","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.]*)(?::(\\d+))?(\\S*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nfunction normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n\n  var parts = path.split(/\\/+/);\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n}\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = mappingA.source - mappingB.source;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return mappingA.name - mappingB.name;\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n","/*\n * transport.js: Base Transport object for all Winston transports.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar events = require('events'),\n    util = require('util');\n\n//\n// ### function Transport (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Tranport object responsible\n// base functionality for all winston transports.\n//\nvar Transport = exports.Transport = function (options) {\n  events.EventEmitter.call(this);\n\n  options        = options        || {};\n  this.silent    = options.silent || false;\n  this.raw       = options.raw    || false;\n  this.name      = options.name   || this.name;\n  this.formatter = options.formatter;\n\n  //\n  // Do not set a default level. When `level` is falsey on any\n  // `Transport` instance, any `Logger` instance uses the\n  // configured level (instead of the Transport level)\n  //\n  this.level = options.level;\n\n  this.handleExceptions = options.handleExceptions || false;\n  this.exceptionsLevel  = options.exceptionsLevel || 'error';\n  this.humanReadableUnhandledException = options.humanReadableUnhandledException || false;\n};\n\n//\n// Inherit from `events.EventEmitter`.\n//\nutil.inherits(Transport, events.EventEmitter);\n\n//\n// ### function formatQuery (query)\n// #### @query {string|Object} Query to format\n// Formats the specified `query` Object (or string) to conform\n// with the underlying implementation of this transport.\n//\nTransport.prototype.formatQuery = function (query) {\n  return query;\n};\n\n//\n// ### function normalizeQuery (query)\n// #### @options {string|Object} Query to normalize\n// Normalize options for query\n//\nTransport.prototype.normalizeQuery = function (options) {\n  //\n  // Use options similar to loggly.\n  // [See Loggly Search API](http://wiki.loggly.com/retrieve_events#optional)\n  //\n\n  options = options || {};\n\n  // limit\n  options.rows = options.rows || options.limit || 10;\n\n  // starting row offset\n  options.start = options.start || 0;\n\n  // now\n  options.until = options.until || new Date;\n  if (typeof options.until !== 'object') {\n    options.until = new Date(options.until);\n  }\n\n  // now - 24\n  options.from = options.from || (options.until - (24 * 60 * 60 * 1000));\n  if (typeof options.from !== 'object') {\n    options.from = new Date(options.from);\n  }\n\n\n  // 'asc' or 'desc'\n  options.order = options.order || 'desc';\n\n  // which fields to select\n  options.fields = options.fields;\n\n  return options;\n};\n\n//\n// ### function formatResults (results, options)\n// #### @results {Object|Array} Results returned from `.query`.\n// #### @options {Object} **Optional** Formatting options\n// Formats the specified `results` with the given `options` accordinging\n// to the implementation of this transport.\n//\nTransport.prototype.formatResults = function (results, options) {\n  return results;\n};\n\n//\n// ### function logException (msg, meta, callback)\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Logs the specified `msg`, `meta` and responds to the callback once the log\n// operation is complete to ensure that the event loop will not exit before\n// all logging has completed.\n//\nTransport.prototype.logException = function (msg, meta, callback) {\n  var self = this,\n      called;\n\n  if (this.silent) {\n    return callback();\n  }\n\n  function onComplete () {\n    if (!called) {\n      called = true;\n      self.removeListener('logged', onComplete);\n      self.removeListener('error', onComplete);\n      callback();\n    }\n  }\n\n  this.once('logged', onComplete);\n  this.once('error', onComplete);\n  this.log(self.exceptionsLevel, msg, meta, function () { });\n};\n","/*\n\nThe MIT License (MIT)\n\nOriginal Library \n  - Copyright (c) Marak Squires\n\nAdditional functionality\n - Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\nvar colors = {};\nmodule['exports'] = colors;\n\ncolors.themes = {};\n\nvar ansiStyles = colors.styles = require('./styles');\nvar defineProps = Object.defineProperties;\n\ncolors.supportsColor = require('./system/supports-colors');\n\nif (typeof colors.enabled === \"undefined\") {\n  colors.enabled = colors.supportsColor;\n}\n\ncolors.stripColors = colors.strip = function(str){\n  return (\"\" + str).replace(/\\x1B\\[\\d+m/g, '');\n};\n\n\nvar stylize = colors.stylize = function stylize (str, style) {\n  return ansiStyles[style].open + str + ansiStyles[style].close;\n}\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\nvar escapeStringRegexp = function (str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n  return str.replace(matchOperatorsRe,  '\\\\$&');\n}\n\nfunction build(_styles) {\n  var builder = function builder() {\n    return applyStyle.apply(builder, arguments);\n  };\n  builder._styles = _styles;\n  // __proto__ is used because we must return a function, but there is\n  // no way to create a function with a different prototype.\n  builder.__proto__ = proto;\n  return builder;\n}\n\nvar styles = (function () {\n  var ret = {};\n  ansiStyles.grey = ansiStyles.gray;\n  Object.keys(ansiStyles).forEach(function (key) {\n    ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');\n    ret[key] = {\n      get: function () {\n        return build(this._styles.concat(key));\n      }\n    };\n  });\n  return ret;\n})();\n\nvar proto = defineProps(function colors() {}, styles);\n\nfunction applyStyle() {\n  var args = arguments;\n  var argsLen = args.length;\n  var str = argsLen !== 0 && String(arguments[0]);\n  if (argsLen > 1) {\n    for (var a = 1; a < argsLen; a++) {\n      str += ' ' + args[a];\n    }\n  }\n\n  if (!colors.enabled || !str) {\n    return str;\n  }\n\n  var nestedStyles = this._styles;\n\n  var i = nestedStyles.length;\n  while (i--) {\n    var code = ansiStyles[nestedStyles[i]];\n    str = code.open + str.replace(code.closeRe, code.open) + code.close;\n  }\n\n  return str;\n}\n\nfunction applyTheme (theme) {\n  for (var style in theme) {\n    (function(style){\n      colors[style] = function(str){\n        return colors[theme[style]](str);\n      };\n    })(style)\n  }\n}\n\ncolors.setTheme = function (theme) {\n  if (typeof theme === 'string') {\n    try {\n      colors.themes[theme] = require(theme);\n      applyTheme(colors.themes[theme]);\n      return colors.themes[theme];\n    } catch (err) {\n      console.log(err);\n      return err;\n    }\n  } else {\n    applyTheme(theme);\n  }\n};\n\nfunction init() {\n  var ret = {};\n  Object.keys(styles).forEach(function (name) {\n    ret[name] = {\n      get: function () {\n        return build([name]);\n      }\n    };\n  });\n  return ret;\n}\n\nvar sequencer = function sequencer (map, str) {\n  var exploded = str.split(\"\"), i = 0;\n  exploded = exploded.map(map);\n  return exploded.join(\"\");\n};\n\n// custom formatter methods\ncolors.trap = require('./custom/trap');\ncolors.zalgo = require('./custom/zalgo');\n\n// maps\ncolors.maps = {};\ncolors.maps.america = require('./maps/america');\ncolors.maps.zebra = require('./maps/zebra');\ncolors.maps.rainbow = require('./maps/rainbow');\ncolors.maps.random = require('./maps/random')\n\nfor (var map in colors.maps) {\n  (function(map){\n    colors[map] = function (str) {\n      return sequencer(colors.maps[map], str);\n    }\n  })(map)\n}\n\ndefineProps(colors, init());","module.exports = require(\"events\");","/*\n * winston.js: Top-level include defining Winston.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar winston = exports;\n\n//\n// use require method for webpack bundle\n//\nwinston.version = require('../package.json').version\n\n//\n// Include transports defined by default by winston\n//\nwinston.transports = require('./winston/transports');\n\n//\n// Expose utility methods\n//\nvar common             = require('./winston/common');\nwinston.hash           = common.hash;\nwinston.clone          = common.clone;\nwinston.longestElement = common.longestElement;\nwinston.exception      = require('./winston/exception');\nwinston.config         = require('./winston/config');\nwinston.addColors      = winston.config.addColors;\n\n//\n// Expose core Logging-related prototypes.\n//\nwinston.Container      = require('./winston/container').Container;\nwinston.Logger         = require('./winston/logger').Logger;\nwinston.Transport      = require('./winston/transports/transport').Transport;\n\n//\n// We create and expose a default `Container` to `winston.loggers` so that the\n// programmer may manage multiple `winston.Logger` instances without any additional overhead.\n//\n// ### some-file1.js\n//\n//     var logger = require('winston').loggers.get('something');\n//\n// ### some-file2.js\n//\n//     var logger = require('winston').loggers.get('something');\n//\nwinston.loggers = new winston.Container();\n\n//\n// We create and expose a 'defaultLogger' so that the programmer may do the\n// following without the need to create an instance of winston.Logger directly:\n//\n//     var winston = require('winston');\n//     winston.log('info', 'some message');\n//     winston.error('some error');\n//\nvar defaultLogger = new winston.Logger({\n  transports: [new winston.transports.Console()]\n});\n\n//\n// Pass through the target methods onto `winston`.\n//\nvar methods = [\n  'log',\n  'query',\n  'stream',\n  'add',\n  'remove',\n  'clear',\n  'profile',\n  'startTimer',\n  'extend',\n  'cli',\n  'handleExceptions',\n  'unhandleExceptions',\n  'configure'\n];\ncommon.setLevels(winston, null, defaultLogger.levels);\nmethods.forEach(function (method) {\n  winston[method] = function () {\n    return defaultLogger[method].apply(defaultLogger, arguments);\n  };\n});\n\n//\n// ### function cli ()\n// Configures the default winston logger to have the\n// settings for command-line interfaces: no timestamp,\n// colors enabled, padded output, and additional levels.\n//\nwinston.cli = function () {\n  winston.padLevels = true;\n  common.setLevels(winston, defaultLogger.levels, winston.config.cli.levels);\n  defaultLogger.setLevels(winston.config.cli.levels);\n  winston.config.addColors(winston.config.cli.colors);\n\n  if (defaultLogger.transports.console) {\n    defaultLogger.transports.console.colorize = true;\n    defaultLogger.transports.console.timestamp = false;\n  }\n\n  return winston;\n};\n\n//\n// ### function setLevels (target)\n// #### @target {Object} Target levels to use\n// Sets the `target` levels specified on the default winston logger.\n//\nwinston.setLevels = function (target) {\n  common.setLevels(winston, defaultLogger.levels, target);\n  defaultLogger.setLevels(target);\n};\n\n//\n// Define getter / setter for the default logger level\n// which need to be exposed by winston.\n//\nObject.defineProperty(winston, 'level', {\n  get: function () {\n    return defaultLogger.level;\n  },\n  set: function (val) {\n    defaultLogger.level = val;\n\n    Object.keys(defaultLogger.transports).forEach(function(key) {\n      defaultLogger.transports[key].level = val;\n    });\n  }\n});\n\n//\n// Define getters / setters for appropriate properties of the\n// default logger which need to be exposed by winston.\n//\n['emitErrs', 'exitOnError', 'padLevels', 'levelLength', 'stripColors'].forEach(function (prop) {\n  Object.defineProperty(winston, prop, {\n    get: function () {\n      return defaultLogger[prop];\n    },\n    set: function (val) {\n      defaultLogger[prop] = val;\n    }\n  });\n});\n\n//\n// @default {Object}\n// The default transports and exceptionHandlers for\n// the default winston logger.\n//\nObject.defineProperty(winston, 'default', {\n  get: function () {\n    return {\n      transports: defaultLogger.transports,\n      exceptionHandlers: defaultLogger.exceptionHandlers\n    };\n  }\n});\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst rimraf = require('./rimraf')\n\nmodule.exports = {\n  remove: u(rimraf),\n  removeSync: rimraf.sync\n}\n","(function() {\n  var Disposable;\n\n  module.exports = Disposable = (function() {\n    Disposable.prototype.disposed = false;\n\n    Disposable.isDisposable = function(object) {\n      return typeof (object != null ? object.dispose : void 0) === \"function\";\n    };\n\n\n    /*\n    Section: Construction and Destruction\n     */\n\n    function Disposable(disposalAction) {\n      this.disposalAction = disposalAction;\n    }\n\n    Disposable.prototype.dispose = function() {\n      if (!this.disposed) {\n        this.disposed = true;\n        if (typeof this.disposalAction === \"function\") {\n          this.disposalAction();\n        }\n        this.disposalAction = null;\n      }\n    };\n\n    return Disposable;\n\n  })();\n\n}).call(this);\n","module.exports = require(\"url\");","'use strict'\n\nconst u = require('universalify').fromCallback\nconst jsonFile = require('jsonfile')\n\nmodule.exports = {\n  // jsonfile exports\n  readJson: u(jsonFile.readFile),\n  readJsonSync: jsonFile.readFileSync,\n  writeJson: u(jsonFile.writeFile),\n  writeJsonSync: jsonFile.writeFileSync\n}\n","'use strict'\n\nmodule.exports = Object.assign(\n  {},\n  // Export promiseified graceful-fs:\n  require('./fs'),\n  // Export extra methods:\n  require('./copy-sync'),\n  require('./copy'),\n  require('./empty'),\n  require('./ensure'),\n  require('./json'),\n  require('./mkdirs'),\n  require('./move-sync'),\n  require('./move'),\n  require('./output'),\n  require('./path-exists'),\n  require('./remove')\n)\n\n// Export fs.promises as a getter property so that we don't trigger\n// ExperimentalWarning before fs.promises is actually accessed.\nconst fs = require('fs')\nif (Object.getOwnPropertyDescriptor(fs, 'promises')) {\n  Object.defineProperty(module.exports, 'promises', {\n    get () { return fs.promises }\n  })\n}\n","/*\n * config.js: Default settings for all levels that winston knows about\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar colors = require('colors/safe');\n\n// Fix colors not appearing in non-tty environments\ncolors.enabled = true;\n\nvar config = exports,\n    allColors = exports.allColors = {};\n\nconfig.addColors = function (colors) {\n  mixin(allColors, colors);\n};\n\nconfig.colorize = function (level, message) {\n  if (typeof message === 'undefined') message = level;\n\n  var colorized = message;\n  if (allColors[level] instanceof Array) {\n    for (var i = 0, l = allColors[level].length; i < l; ++i) {\n      colorized = colors[allColors[level][i]](colorized);\n    }\n  }\n  else if (allColors[level].match(/\\s/)) {\n    var colorArr = allColors[level].split(/\\s+/);\n    for (var i = 0; i < colorArr.length; ++i) {\n      colorized = colors[colorArr[i]](colorized);\n    }\n    allColors[level] = colorArr;\n  }\n  else {\n    colorized = colors[allColors[level]](colorized);\n  }\n\n  return colorized;\n};\n\n//\n// Export config sets\n//\nconfig.cli    = require('./config/cli-config');\nconfig.npm    = require('./config/npm-config');\nconfig.syslog = require('./config/syslog-config');\n\n//\n// Add colors for pre-defined config sets\n//\nconfig.addColors(config.cli.colors);\nconfig.addColors(config.npm.colors);\nconfig.addColors(config.syslog.colors);\n\nfunction mixin (target) {\n  var args = Array.prototype.slice.call(arguments, 1);\n\n  args.forEach(function (a) {\n    var keys = Object.keys(a);\n    for (var i = 0; i < keys.length; i++) {\n      target[keys[i]] = a[keys[i]];\n    }\n  });\n  return target;\n};\n","module.exports = require(\"child_process\");","import * as Url from 'url'\nimport { shell } from 'electron'\n\n/**\n * Wraps the inbuilt shell.openItem path to address a focus issue that affects macOS.\n *\n * When opening a folder in Finder, the window will appear behind the application\n * window, which may confuse users. As a workaround, we will fallback to using\n * shell.openExternal for macOS until it can be fixed upstream.\n *\n * @param path directory to open\n */\nexport function openDirectorySafe(path: string) {\n  if (__DARWIN__) {\n    const directoryURL = Url.format({\n      pathname: path,\n      protocol: 'file:',\n      slashes: true,\n    })\n\n    shell\n      .openExternal(directoryURL)\n      .catch(err => log.error(`Failed to open directory (${path})`, err))\n  } else {\n    shell.openItem(path)\n  }\n}\n","function getItemId(template: Electron.MenuItemConstructorOptions) {\n  return template.id || template.label || template.role || 'unknown'\n}\n\n/**\n * Ensures that all menu items in the given template are assigned an id\n * by recursively traversing the template and mutating items in place.\n *\n * Items which already have an id are left alone, the other get a unique,\n * but consistent id based on their label or role and their position in\n * the menu hierarchy.\n *\n * Note that this does not do anything to prevent the case where items have\n * explicitly been given duplicate ids.\n */\nexport function ensureItemIds(\n  template: ReadonlyArray<Electron.MenuItemConstructorOptions>,\n  prefix = '@',\n  seenIds = new Set<string>()\n) {\n  for (const item of template) {\n    let counter = 0\n    let id = item.id\n\n    // Automatically generate an id if one hasn't been explicitly provided\n    if (!id) {\n      // Ensure that multiple items with the same key gets suffixed with a number\n      // i.e. @.separator, @.separator1 @.separator2 etc\n      do {\n        id = `${prefix}.${getItemId(item)}${counter++ || ''}`\n      } while (seenIds.has(id))\n    }\n\n    item.id = id\n    seenIds.add(id)\n\n    if (item.submenu) {\n      const subMenuTemplate = item.submenu as ReadonlyArray<\n        Electron.MenuItemConstructorOptions\n      >\n      ensureItemIds(subMenuTemplate, item.id, seenIds)\n    }\n  }\n}\n","export * from './build-default-menu'\nexport * from './ensure-item-ids'\nexport * from './menu-event'\nexport * from './crash-menu'\nexport * from './get-all-menu-items'\n","/**\n * Get the time from some arbitrary fixed starting point. The time will not be\n * based on clock time.\n *\n * Ideally we'd just use `performance.now` but that's a browser API and not\n * available in our Plain Old Node main process environment.\n */\nexport function now(): number {\n  const time = process.hrtime()\n  return time[0] * 1000 + time[1] / 1000000\n}\n","/** Throw an error. */\nexport function fatalError(msg: string): never {\n  throw new Error(msg)\n}\n\n/**\n * Utility function used to achieve exhaustive type checks at compile time.\n *\n * If the type system is bypassed or this method will throw an exception\n * using the second parameter as the message.\n *\n * @param x         Placeholder parameter in order to leverage the type\n *                  system. Pass the variable which has been type narrowed\n *                  in an exhaustive check.\n *\n * @param message   The message to be used in the runtime exception.\n *\n */\nexport function assertNever(x: never, message: string): never {\n  throw new Error(message)\n}\n\n/**\n * Unwrap a value that, according to the type system, could be null or\n * undefined, but which we know is not. If the value _is_ null or undefined,\n * this will throw. The message should contain the rationale for knowing the\n * value is defined.\n */\nexport function forceUnwrap<T>(message: string, x: T | null | undefined): T {\n  if (x == null) {\n    return fatalError(message)\n  } else {\n    return x\n  }\n}\n","// The name of the ipc channel over which state changes are communicated.\nexport const windowStateChannelName = 'window-state-changed'\n\nexport type WindowState =\n  | 'minimized'\n  | 'normal'\n  | 'maximized'\n  | 'full-screen'\n  | 'hidden'\n\nexport function getWindowState(window: Electron.BrowserWindow): WindowState {\n  if (window.isFullScreen()) {\n    return 'full-screen'\n  } else if (window.isMaximized()) {\n    return 'maximized'\n  } else if (window.isMinimized()) {\n    return 'minimized'\n  } else if (!window.isVisible()) {\n    return 'hidden'\n  } else {\n    return 'normal'\n  }\n}\n\n/**\n * Registers event handlers for all window state transition events and\n * forwards those to the renderer process for a given window.\n */\nexport function registerWindowStateChangedEvents(\n  window: Electron.BrowserWindow\n) {\n  window.on('enter-full-screen', () =>\n    sendWindowStateEvent(window, 'full-screen')\n  )\n\n  // So this is a bit of a hack. If we call window.isFullScreen directly after\n  // receiving the leave-full-screen event it'll return true which isn't what\n  // we're after. So we'll say that we're transitioning to 'normal' even though\n  // we might be maximized. This works because electron will emit a 'maximized'\n  // event after 'leave-full-screen' if the state prior to full-screen was maximized.\n  window.on('leave-full-screen', () => sendWindowStateEvent(window, 'normal'))\n\n  window.on('maximize', () => sendWindowStateEvent(window, 'maximized'))\n  window.on('minimize', () => sendWindowStateEvent(window, 'minimized'))\n  window.on('unmaximize', () => sendWindowStateEvent(window, 'normal'))\n  window.on('restore', () => sendWindowStateEvent(window, 'normal'))\n  window.on('hide', () => sendWindowStateEvent(window, 'hidden'))\n  window.on('show', () => {\n    // because the app can be maximized before being closed - which will restore it\n    // maximized on the next launch - this function should inspect the current state\n    // rather than always assume it is a 'normal' launch\n    sendWindowStateEvent(window, getWindowState(window))\n  })\n}\n\n/**\n * Short hand convenience function for sending a window state change event\n * over the window-state-changed channel to the render process.\n */\nfunction sendWindowStateEvent(\n  window: Electron.BrowserWindow,\n  state: WindowState\n) {\n  window.webContents.send(windowStateChannelName, state)\n}\n","(function() {\n  exports.Emitter = require('./emitter');\n\n  exports.Disposable = require('./disposable');\n\n  exports.CompositeDisposable = require('./composite-disposable');\n\n}).call(this);\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n","import * as Path from 'path'\nimport * as Fs from 'fs'\n\nconst fileUriToPath: (uri: string) => string = require('file-uri-to-path')\nconst sourceMapSupport = require('source-map-support')\n\n/**\n * This array tells the source map logic which files that we can expect to\n * be able to resolve a source map for and they should reflect the chunks\n * entry names from our webpack config.\n *\n * Note that we explicitly don't enable source maps for the crash process\n * since it's possible that the error which caused us to spawn the crash\n * process was related to source maps.\n */\nconst knownFilesWithSourceMap = ['renderer.js', 'main.js']\n\nfunction retrieveSourceMap(source: string) {\n  // This is a happy path in case we know for certain that we won't be\n  // able to resolve a source map for the given location.\n  if (!knownFilesWithSourceMap.some(file => source.endsWith(file))) {\n    return null\n  }\n\n  // We get a file uri when we're inside a renderer, convert to a path\n  if (source.startsWith('file://')) {\n    source = fileUriToPath(source)\n  }\n\n  // We store our source maps right next to the bundle\n  const path = `${source}.map`\n\n  if (__DEV__ && path.startsWith('http://')) {\n    try {\n      const xhr = new XMLHttpRequest()\n      xhr.open('GET', path, false)\n      xhr.send(null)\n      if (xhr.readyState === 4 && xhr.status === 200) {\n        return { url: Path.basename(path), map: xhr.responseText }\n      }\n    } catch (error) {\n      return\n    }\n    return\n  }\n\n  // We don't have an option here, see\n  //  https://github.com/v8/v8/wiki/Stack-Trace-API#customizing-stack-traces\n  // This happens on-demand when someone accesses the stack\n  // property on an error object and has to be synchronous :/\n  // eslint-disable-next-line no-sync\n  if (!Fs.existsSync(path)) {\n    return\n  }\n\n  try {\n    // eslint-disable-next-line no-sync\n    const map = Fs.readFileSync(path, 'utf8')\n    return { url: Path.basename(path), map }\n  } catch (error) {\n    return\n  }\n}\n\n/** A map from errors to their stack frames. */\nconst stackFrameMap = new WeakMap<Error, ReadonlyArray<any>>()\n\n/**\n * The `prepareStackTrace` that comes from the `source-map-support` module.\n * We'll use this when the user explicitly wants the stack source mapped.\n */\nlet prepareStackTraceWithSourceMap: (\n  error: Error,\n  frames: ReadonlyArray<any>\n) => string\n\n/**\n * Capture the error's stack frames and return a standard, un-source mapped\n * stack trace.\n */\nfunction prepareStackTrace(error: Error, frames: ReadonlyArray<any>) {\n  stackFrameMap.set(error, frames)\n\n  // Ideally we'd use the default `Error.prepareStackTrace` here but it's\n  // undefined so V8 must doing something fancy. Instead we'll do a decent\n  // impression.\n  return error + frames.map(frame => `\\n    at ${frame}`).join('')\n}\n\n/** Enable source map support in the current process. */\nexport function enableSourceMaps() {\n  sourceMapSupport.install({\n    environment: 'node',\n    handleUncaughtExceptions: false,\n    retrieveSourceMap,\n  })\n\n  const AnyError = Error as any\n  // We want to keep `source-map-support`s `prepareStackTrace` around to use\n  // later, but our cheaper `prepareStackTrace` should be the default.\n  prepareStackTraceWithSourceMap = AnyError.prepareStackTrace\n  AnyError.prepareStackTrace = prepareStackTrace\n}\n\n/**\n * Make a copy of the error with a source-mapped stack trace. If it couldn't\n * perform the source mapping, it'll use the original error stack.\n */\nexport function withSourceMappedStack(error: Error): Error {\n  return {\n    name: error.name,\n    message: error.message,\n    stack: sourceMappedStackTrace(error),\n  }\n}\n\n/** Get the source mapped stack trace for the error. */\nfunction sourceMappedStackTrace(error: Error): string | undefined {\n  let frames = stackFrameMap.get(error)\n\n  if (!frames) {\n    // At this point there's no guarantee that anyone has actually retrieved the\n    // stack on this error which means that our custom prepareStackTrace handler\n    // hasn't run and as a result of that we don't have the native frames stored\n    // in our weak map. In order to get around that we'll eagerly access the\n    // stack, forcing our handler to run which should ensure that the native\n    // frames are stored in our weak map.\n    ;(error.stack || '').toString()\n    frames = stackFrameMap.get(error)\n  }\n\n  if (!frames) {\n    return error.stack\n  }\n\n  return prepareStackTraceWithSourceMap(error, frames)\n}\n","import { withSourceMappedStack } from '../source-map-support'\n\n/**\n * Formats an error for log file output. Use this instead of\n * multiple calls to log.error.\n */\nexport function formatError(error: Error, title?: string) {\n  error = withSourceMappedStack(error)\n\n  if (error.stack) {\n    return title ? `${title}\\n${error.stack}` : error.stack.trim()\n  } else {\n    return title\n      ? `${title}\\n${error.name}: ${error.message}`\n      : `${error.name}: ${error.message}`\n  }\n}\n","var path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n","var _fs\ntry {\n  _fs = require('graceful-fs')\n} catch (_) {\n  _fs = require('fs')\n}\n\nfunction readFile (file, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  fs.readFile(file, options, function (err, data) {\n    if (err) return callback(err)\n\n    data = stripBom(data)\n\n    var obj\n    try {\n      obj = JSON.parse(data, options ? options.reviver : null)\n    } catch (err2) {\n      if (shouldThrow) {\n        err2.message = file + ': ' + err2.message\n        return callback(err2)\n      } else {\n        return callback(null, null)\n      }\n    }\n\n    callback(null, obj)\n  })\n}\n\nfunction readFileSync (file, options) {\n  options = options || {}\n  if (typeof options === 'string') {\n    options = {encoding: options}\n  }\n\n  var fs = options.fs || _fs\n\n  var shouldThrow = true\n  if ('throws' in options) {\n    shouldThrow = options.throws\n  }\n\n  try {\n    var content = fs.readFileSync(file, options)\n    content = stripBom(content)\n    return JSON.parse(content, options.reviver)\n  } catch (err) {\n    if (shouldThrow) {\n      err.message = file + ': ' + err.message\n      throw err\n    } else {\n      return null\n    }\n  }\n}\n\nfunction stringify (obj, options) {\n  var spaces\n  var EOL = '\\n'\n  if (typeof options === 'object' && options !== null) {\n    if (options.spaces) {\n      spaces = options.spaces\n    }\n    if (options.EOL) {\n      EOL = options.EOL\n    }\n  }\n\n  var str = JSON.stringify(obj, options ? options.replacer : null, spaces)\n\n  return str.replace(/\\n/g, EOL) + EOL\n}\n\nfunction writeFile (file, obj, options, callback) {\n  if (callback == null) {\n    callback = options\n    options = {}\n  }\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var str = ''\n  try {\n    str = stringify(obj, options)\n  } catch (err) {\n    // Need to return whether a callback was passed or not\n    if (callback) callback(err, null)\n    return\n  }\n\n  fs.writeFile(file, str, options, callback)\n}\n\nfunction writeFileSync (file, obj, options) {\n  options = options || {}\n  var fs = options.fs || _fs\n\n  var str = stringify(obj, options)\n  // not sure if fs.writeFileSync returns anything, but just in case\n  return fs.writeFileSync(file, str, options)\n}\n\nfunction stripBom (content) {\n  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified\n  if (Buffer.isBuffer(content)) content = content.toString('utf8')\n  content = content.replace(/^\\uFEFF/, '')\n  return content\n}\n\nvar jsonfile = {\n  readFile: readFile,\n  readFileSync: readFileSync,\n  writeFile: writeFile,\n  writeFileSync: writeFileSync\n}\n\nmodule.exports = jsonfile\n","'use strict'\n\nconst u = require('universalify').fromCallback\nmodule.exports = {\n  copy: u(require('./copy'))\n}\n","'use strict'\n/* eslint-disable node/no-deprecated-api */\nmodule.exports = function (size) {\n  if (typeof Buffer.allocUnsafe === 'function') {\n    try {\n      return Buffer.allocUnsafe(size)\n    } catch (e) {\n      return new Buffer(size)\n    }\n  }\n  return new Buffer(size)\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst os = require('os')\nconst path = require('path')\n\n// HFS, ext{2,3}, FAT do not, Node.js v0.10 does not\nfunction hasMillisResSync () {\n  let tmpfile = path.join('millis-test-sync' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFileSync(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141')\n  const fd = fs.openSync(tmpfile, 'r+')\n  fs.futimesSync(fd, d, d)\n  fs.closeSync(fd)\n  return fs.statSync(tmpfile).mtime > 1435410243000\n}\n\nfunction hasMillisRes (callback) {\n  let tmpfile = path.join('millis-test' + Date.now().toString() + Math.random().toString().slice(2))\n  tmpfile = path.join(os.tmpdir(), tmpfile)\n\n  // 550 millis past UNIX epoch\n  const d = new Date(1435410243862)\n  fs.writeFile(tmpfile, 'https://github.com/jprichardson/node-fs-extra/pull/141', err => {\n    if (err) return callback(err)\n    fs.open(tmpfile, 'r+', (err, fd) => {\n      if (err) return callback(err)\n      fs.futimes(fd, d, d, err => {\n        if (err) return callback(err)\n        fs.close(fd, err => {\n          if (err) return callback(err)\n          fs.stat(tmpfile, (err, stats) => {\n            if (err) return callback(err)\n            callback(null, stats.mtime > 1435410243000)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction timeRemoveMillis (timestamp) {\n  if (typeof timestamp === 'number') {\n    return Math.floor(timestamp / 1000) * 1000\n  } else if (timestamp instanceof Date) {\n    return new Date(Math.floor(timestamp.getTime() / 1000) * 1000)\n  } else {\n    throw new Error('fs-extra: timeRemoveMillis() unknown parameter type')\n  }\n}\n\nfunction utimesMillis (path, atime, mtime, callback) {\n  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)\n  fs.open(path, 'r+', (err, fd) => {\n    if (err) return callback(err)\n    fs.futimes(fd, atime, mtime, futimesErr => {\n      fs.close(fd, closeErr => {\n        if (callback) callback(futimesErr || closeErr)\n      })\n    })\n  })\n}\n\nfunction utimesMillisSync (path, atime, mtime) {\n  const fd = fs.openSync(path, 'r+')\n  fs.futimesSync(fd, atime, mtime)\n  return fs.closeSync(fd)\n}\n\nmodule.exports = {\n  hasMillisRes,\n  hasMillisResSync,\n  timeRemoveMillis,\n  utimesMillis,\n  utimesMillisSync\n}\n","'use strict'\n\nconst path = require('path')\n\n// get drive on windows\nfunction getRootPath (p) {\n  p = path.normalize(path.resolve(p)).split(path.sep)\n  if (p.length > 0) return p[0]\n  return null\n}\n\n// http://stackoverflow.com/a/62888/10333 contains more accurate\n// TODO: expand to include the rest\nconst INVALID_PATH_CHARS = /[<>:\"|?*]/\n\nfunction invalidWin32Path (p) {\n  const rp = getRootPath(p)\n  p = p.replace(rp, '')\n  return INVALID_PATH_CHARS.test(p)\n}\n\nmodule.exports = {\n  getRootPath,\n  invalidWin32Path\n}\n","'use strict'\n\nmodule.exports = {\n  copySync: require('./copy-sync')\n}\n","module.exports = require(\"assert\");","'use strict'\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchown',\n  'lchmod',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'readFile',\n  'readdir',\n  'readlink',\n  'realpath',\n  'rename',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.copyFile was added in Node.js v8.5.0\n  // fs.mkdtemp was added in Node.js v5.10.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export all keys:\nObject.keys(fs).forEach(key => {\n  if (key === 'promises') {\n    // fs.promises is a getter property that triggers ExperimentalWarning\n    // Don't re-export it here, the getter is defined in \"lib/index.js\"\n    return\n  }\n  exports[key] = fs[key]\n})\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read() & fs.write need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n","import * as Path from 'path'\nimport { app } from 'electron'\n\nlet logDirectoryPath: string | null = null\n\nexport function getLogDirectoryPath() {\n  if (!logDirectoryPath) {\n    const userData = app.getPath('userData')\n    logDirectoryPath = Path.join(userData, 'logs')\n  }\n\n  return logDirectoryPath\n}\n","/*\n * exception.js: Utility methods for gathing information about uncaughtExceptions.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar os = require('os'),\n    stackTrace = require('stack-trace');\n\nvar exception = exports;\n\nexception.getAllInfo = function (err) {\n  return {\n    date:    new Date().toString(),\n    process: exception.getProcessInfo(),\n    os:      exception.getOsInfo(),\n    trace:   exception.getTrace(err),\n    stack:   err.stack && err.stack.split('\\n')\n  };\n};\n\nexception.getProcessInfo = function () {\n  return {\n    pid:         process.pid,\n    uid:         process.getuid ? process.getuid() : null,\n    gid:         process.getgid ? process.getgid() : null,\n    cwd:         process.cwd(),\n    execPath:    process.execPath,\n    version:     process.version,\n    argv:        process.argv,\n    memoryUsage: process.memoryUsage()\n  };\n};\n\nexception.getOsInfo = function () {\n  return {\n    loadavg: os.loadavg(),\n    uptime:  os.uptime()\n  };\n};\n\nexception.getTrace = function (err) {\n  var trace = err ? stackTrace.parse(err) : stackTrace.get();\n  return trace.map(function (site) {\n    return {\n      column:   site.getColumnNumber(),\n      file:     site.getFileName(),\n      function: site.getFunctionName(),\n      line:     site.getLineNumber(),\n      method:   site.getMethodName(),\n      native:   site.isNative(),\n    }\n  });\n};\n","module.exports = require(\"zlib\");","/*!\n * async\n * https://github.com/caolan/async\n *\n * Copyright 2010-2014 Caolan McMahon\n * Released under the MIT license\n */\n(function () {\n\n    var async = {};\n    var noop = function () {};\n\n    // global on the server, window in the browser\n    var root, previous_async;\n\n    if (typeof window == 'object' && this === window) {\n        root = window;\n    }\n    else if (typeof global == 'object' && this === global) {\n        root = global;\n    }\n    else {\n        root = this;\n    }\n\n    if (root != null) {\n      previous_async = root.async;\n    }\n\n    async.noConflict = function () {\n        root.async = previous_async;\n        return async;\n    };\n\n    function only_once(fn) {\n        var called = false;\n        return function() {\n            if (called) throw new Error(\"Callback was already called.\");\n            called = true;\n            fn.apply(root, arguments);\n        };\n    }\n\n    //// cross-browser compatiblity functions ////\n\n    var _toString = Object.prototype.toString;\n\n    var _isArray = Array.isArray || function (obj) {\n        return _toString.call(obj) === '[object Array]';\n    };\n\n    var _each = function (arr, iterator) {\n      var index = -1,\n          length = arr.length;\n\n      while (++index < length) {\n        iterator(arr[index], index, arr);\n      }\n    };\n\n    var _map = function (arr, iterator) {\n      var index = -1,\n          length = arr.length,\n          result = Array(length);\n\n      while (++index < length) {\n        result[index] = iterator(arr[index], index, arr);\n      }\n      return result;\n    };\n\n    var _reduce = function (arr, iterator, memo) {\n        _each(arr, function (x, i, a) {\n            memo = iterator(memo, x, i, a);\n        });\n        return memo;\n    };\n\n    var _forEachOf = function (object, iterator) {\n        _each(_keys(object), function (key) {\n            iterator(object[key], key);\n        });\n    };\n\n    var _keys = Object.keys || function (obj) {\n        var keys = [];\n        for (var k in obj) {\n            if (obj.hasOwnProperty(k)) {\n                keys.push(k);\n            }\n        }\n        return keys;\n    };\n\n    var _baseSlice = function (arr, start) {\n        start = start || 0;\n        var index = -1;\n        var length = arr.length;\n\n        if (start) {\n          length -= start;\n          length = length < 0 ? 0 : length;\n        }\n        var result = Array(length);\n\n        while (++index < length) {\n          result[index] = arr[index + start];\n        }\n        return result;\n    };\n\n    //// exported async module functions ////\n\n    //// nextTick implementation with browser-compatible fallback ////\n\n    // capture the global reference to guard against fakeTimer mocks\n    var _setImmediate;\n    if (typeof setImmediate === 'function') {\n        _setImmediate = setImmediate;\n    }\n\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (_setImmediate) {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                _setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (_setImmediate) {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              _setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.each = function (arr, iterator, callback) {\n        callback = callback || noop;\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        _each(arr, function (x) {\n            iterator(x, only_once(done) );\n        });\n        function done(err) {\n          if (err) {\n              callback(err);\n              callback = noop;\n          }\n          else {\n              completed += 1;\n              if (completed >= arr.length) {\n                  callback();\n              }\n          }\n        }\n    };\n    async.forEach = async.each;\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || noop;\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = noop;\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback();\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n\n    async.eachLimit = function (arr, limit, iterator, callback) {\n        var fn = _eachLimit(limit);\n        fn.apply(null, [arr, iterator, callback]);\n    };\n    async.forEachLimit = async.eachLimit;\n\n    var _eachLimit = function (limit) {\n\n        return function (arr, iterator, callback) {\n            callback = callback || noop;\n            if (!arr.length || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= arr.length) {\n                    return callback();\n                }\n\n                while (running < limit && started < arr.length) {\n                    started += 1;\n                    running += 1;\n                    iterator(arr[started - 1], function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = noop;\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= arr.length) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n\n    async.forEachOf = async.eachOf = function (object, iterator, callback) {\n        callback = callback || function () {};\n        var size = object.length || _keys(object).length;\n        var completed = 0;\n        if (!size) {\n            return callback();\n        }\n        _forEachOf(object, function (value, key) {\n            iterator(object[key], key, function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                } else {\n                    completed += 1;\n                    if (completed === size) {\n                        callback(null);\n                    }\n                }\n            });\n        });\n    };\n\n    async.forEachOfSeries = async.eachOfSeries = function (obj, iterator, callback) {\n        callback = callback || function () {};\n        var keys = _keys(obj);\n        var size = keys.length;\n        if (!size) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            var sync = true;\n            var key = keys[completed];\n            iterator(obj[key], key, function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= size) {\n                        callback(null);\n                    }\n                    else {\n                        if (sync) {\n                            async.nextTick(iterate);\n                        }\n                        else {\n                            iterate();\n                        }\n                    }\n                }\n            });\n            sync = false;\n        };\n        iterate();\n    };\n\n\n\n    async.forEachOfLimit = async.eachOfLimit = function (obj, limit, iterator, callback) {\n        _forEachOfLimit(limit)(obj, iterator, callback);\n    };\n\n    var _forEachOfLimit = function (limit) {\n\n        return function (obj, iterator, callback) {\n            callback = callback || function () {};\n            var keys = _keys(obj);\n            var size = keys.length;\n            if (!size || limit <= 0) {\n                return callback();\n            }\n            var completed = 0;\n            var started = 0;\n            var running = 0;\n\n            (function replenish () {\n                if (completed >= size) {\n                    return callback();\n                }\n\n                while (running < limit && started < size) {\n                    started += 1;\n                    running += 1;\n                    var key = keys[started - 1];\n                    iterator(obj[key], key, function (err) {\n                        if (err) {\n                            callback(err);\n                            callback = function () {};\n                        }\n                        else {\n                            completed += 1;\n                            running -= 1;\n                            if (completed >= size) {\n                                callback();\n                            }\n                            else {\n                                replenish();\n                            }\n                        }\n                    });\n                }\n            })();\n        };\n    };\n\n\n    var doParallel = function (fn) {\n        return function () {\n            var args = _baseSlice(arguments);\n            return fn.apply(null, [async.each].concat(args));\n        };\n    };\n    var doParallelLimit = function(limit, fn) {\n        return function () {\n            var args = _baseSlice(arguments);\n            return fn.apply(null, [_eachLimit(limit)].concat(args));\n        };\n    };\n    var doSeries = function (fn) {\n        return function () {\n            var args = _baseSlice(arguments);\n            return fn.apply(null, [async.eachSeries].concat(args));\n        };\n    };\n\n\n    var _asyncMap = function (eachfn, arr, iterator, callback) {\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        if (!callback) {\n            eachfn(arr, function (x, callback) {\n                iterator(x.value, function (err) {\n                    callback(err);\n                });\n            });\n        } else {\n            var results = [];\n            eachfn(arr, function (x, callback) {\n                iterator(x.value, function (err, v) {\n                    results[x.index] = v;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n    async.map = doParallel(_asyncMap);\n    async.mapSeries = doSeries(_asyncMap);\n    async.mapLimit = function (arr, limit, iterator, callback) {\n        return _mapLimit(limit)(arr, iterator, callback);\n    };\n\n    var _mapLimit = function(limit) {\n        return doParallelLimit(limit, _asyncMap);\n    };\n\n    // reduce only has a series version, as doing reduce in parallel won't\n    // work in many situations.\n    async.reduce = function (arr, memo, iterator, callback) {\n        async.eachSeries(arr, function (x, callback) {\n            iterator(memo, x, function (err, v) {\n                memo = v;\n                callback(err);\n            });\n        }, function (err) {\n            callback(err, memo);\n        });\n    };\n    // inject alias\n    async.inject = async.reduce;\n    // foldl alias\n    async.foldl = async.reduce;\n\n    async.reduceRight = function (arr, memo, iterator, callback) {\n        var reversed = _map(arr, function (x) {\n            return x;\n        }).reverse();\n        async.reduce(reversed, memo, iterator, callback);\n    };\n    // foldr alias\n    async.foldr = async.reduceRight;\n\n    var _filter = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.filter = doParallel(_filter);\n    async.filterSeries = doSeries(_filter);\n    // select alias\n    async.select = async.filter;\n    async.selectSeries = async.filterSeries;\n\n    var _reject = function (eachfn, arr, iterator, callback) {\n        var results = [];\n        arr = _map(arr, function (x, i) {\n            return {index: i, value: x};\n        });\n        eachfn(arr, function (x, callback) {\n            iterator(x.value, function (v) {\n                if (!v) {\n                    results.push(x);\n                }\n                callback();\n            });\n        }, function (err) {\n            callback(_map(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), function (x) {\n                return x.value;\n            }));\n        });\n    };\n    async.reject = doParallel(_reject);\n    async.rejectSeries = doSeries(_reject);\n\n    var _detect = function (eachfn, arr, iterator, main_callback) {\n        eachfn(arr, function (x, callback) {\n            iterator(x, function (result) {\n                if (result) {\n                    main_callback(x);\n                    main_callback = noop;\n                }\n                else {\n                    callback();\n                }\n            });\n        }, function (err) {\n            main_callback();\n        });\n    };\n    async.detect = doParallel(_detect);\n    async.detectSeries = doSeries(_detect);\n\n    async.some = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (v) {\n                    main_callback(true);\n                    main_callback = noop;\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(false);\n        });\n    };\n    // any alias\n    async.any = async.some;\n\n    async.every = function (arr, iterator, main_callback) {\n        async.each(arr, function (x, callback) {\n            iterator(x, function (v) {\n                if (!v) {\n                    main_callback(false);\n                    main_callback = noop;\n                }\n                callback();\n            });\n        }, function (err) {\n            main_callback(true);\n        });\n    };\n    // all alias\n    async.all = async.every;\n\n    async.sortBy = function (arr, iterator, callback) {\n        async.map(arr, function (x, callback) {\n            iterator(x, function (err, criteria) {\n                if (err) {\n                    callback(err);\n                }\n                else {\n                    callback(null, {value: x, criteria: criteria});\n                }\n            });\n        }, function (err, results) {\n            if (err) {\n                return callback(err);\n            }\n            else {\n                var fn = function (left, right) {\n                    var a = left.criteria, b = right.criteria;\n                    return a < b ? -1 : a > b ? 1 : 0;\n                };\n                callback(null, _map(results.sort(fn), function (x) {\n                    return x.value;\n                }));\n            }\n        });\n    };\n\n    async.auto = function (tasks, callback) {\n        callback = callback || noop;\n        var keys = _keys(tasks);\n        var remainingTasks = keys.length;\n        if (!remainingTasks) {\n            return callback();\n        }\n\n        var results = {};\n\n        var listeners = [];\n        var addListener = function (fn) {\n            listeners.unshift(fn);\n        };\n        var removeListener = function (fn) {\n            for (var i = 0; i < listeners.length; i += 1) {\n                if (listeners[i] === fn) {\n                    listeners.splice(i, 1);\n                    return;\n                }\n            }\n        };\n        var taskComplete = function () {\n            remainingTasks--;\n            _each(listeners.slice(0), function (fn) {\n                fn();\n            });\n        };\n\n        addListener(function () {\n            if (!remainingTasks) {\n                var theCallback = callback;\n                // prevent final callback from calling itself if it errors\n                callback = noop;\n\n                theCallback(null, results);\n            }\n        });\n\n        _each(keys, function (k) {\n            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n            var taskCallback = function (err) {\n                var args = _baseSlice(arguments, 1);\n                if (args.length <= 1) {\n                    args = args[0];\n                }\n                if (err) {\n                    var safeResults = {};\n                    _each(_keys(results), function(rkey) {\n                        safeResults[rkey] = results[rkey];\n                    });\n                    safeResults[k] = args;\n                    callback(err, safeResults);\n                    // stop subsequent errors hitting callback multiple times\n                    callback = noop;\n                }\n                else {\n                    results[k] = args;\n                    async.setImmediate(taskComplete);\n                }\n            };\n            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n            // prevent dead-locks\n            var len = requires.length;\n            var dep;\n            while (len--) {\n                if (!(dep = tasks[requires[len]])) {\n                    throw new Error('Has inexistant dependency');\n                }\n                if (_isArray(dep) && !!~dep.indexOf(k)) {\n                    throw new Error('Has cyclic dependencies');\n                }\n            }\n            var ready = function () {\n                return _reduce(requires, function (a, x) {\n                    return (a && results.hasOwnProperty(x));\n                }, true) && !results.hasOwnProperty(k);\n            };\n            if (ready()) {\n                task[task.length - 1](taskCallback, results);\n            }\n            else {\n                var listener = function () {\n                    if (ready()) {\n                        removeListener(listener);\n                        task[task.length - 1](taskCallback, results);\n                    }\n                };\n                addListener(listener);\n            }\n        });\n    };\n\n    async.retry = function(times, task, callback) {\n        var DEFAULT_TIMES = 5;\n        var attempts = [];\n        // Use defaults if times not passed\n        if (typeof times === 'function') {\n            callback = task;\n            task = times;\n            times = DEFAULT_TIMES;\n        }\n        // Make sure times is a number\n        times = parseInt(times, 10) || DEFAULT_TIMES;\n        var wrappedTask = function(wrappedCallback, wrappedResults) {\n            var retryAttempt = function(task, finalAttempt) {\n                return function(seriesCallback) {\n                    task(function(err, result){\n                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n                    }, wrappedResults);\n                };\n            };\n            while (times) {\n                attempts.push(retryAttempt(task, !(times-=1)));\n            }\n            async.series(attempts, function(done, data){\n                data = data[data.length - 1];\n                (wrappedCallback || callback)(data.err, data.result);\n            });\n        };\n        // If a callback is passed, run this as a controll flow\n        return callback ? wrappedTask() : wrappedTask;\n    };\n\n    async.waterfall = function (tasks, callback) {\n        callback = callback || noop;\n        if (!_isArray(tasks)) {\n          var err = new Error('First argument to waterfall must be an array of functions');\n          return callback(err);\n        }\n        if (!tasks.length) {\n            return callback();\n        }\n        var wrapIterator = function (iterator) {\n            return function (err) {\n                if (err) {\n                    callback.apply(null, arguments);\n                    callback = noop;\n                }\n                else {\n                    var args = _baseSlice(arguments, 1);\n                    var next = iterator.next();\n                    if (next) {\n                        args.push(wrapIterator(next));\n                    }\n                    else {\n                        args.push(callback);\n                    }\n                    async.setImmediate(function () {\n                        iterator.apply(null, args);\n                    });\n                }\n            };\n        };\n        wrapIterator(async.iterator(tasks))();\n    };\n\n    var _parallel = function(eachfn, tasks, callback) {\n        callback = callback || noop;\n        if (_isArray(tasks)) {\n            eachfn.map(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = _baseSlice(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            eachfn.each(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = _baseSlice(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.parallel = function (tasks, callback) {\n        _parallel({ map: async.map, each: async.each }, tasks, callback);\n    };\n\n    async.parallelLimit = function(tasks, limit, callback) {\n        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n    };\n\n    async.series = function (tasks, callback) {\n        callback = callback || noop;\n        if (_isArray(tasks)) {\n            async.mapSeries(tasks, function (fn, callback) {\n                if (fn) {\n                    fn(function (err) {\n                        var args = _baseSlice(arguments, 1);\n                        if (args.length <= 1) {\n                            args = args[0];\n                        }\n                        callback.call(null, err, args);\n                    });\n                }\n            }, callback);\n        }\n        else {\n            var results = {};\n            async.eachSeries(_keys(tasks), function (k, callback) {\n                tasks[k](function (err) {\n                    var args = _baseSlice(arguments, 1);\n                    if (args.length <= 1) {\n                        args = args[0];\n                    }\n                    results[k] = args;\n                    callback(err);\n                });\n            }, function (err) {\n                callback(err, results);\n            });\n        }\n    };\n\n    async.iterator = function (tasks) {\n        var makeCallback = function (index) {\n            var fn = function () {\n                if (tasks.length) {\n                    tasks[index].apply(null, arguments);\n                }\n                return fn.next();\n            };\n            fn.next = function () {\n                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n            };\n            return fn;\n        };\n        return makeCallback(0);\n    };\n\n    async.apply = function (fn) {\n        var args = _baseSlice(arguments, 1);\n        return function () {\n            return fn.apply(\n                null, args.concat(_baseSlice(arguments))\n            );\n        };\n    };\n\n    var _concat = function (eachfn, arr, fn, callback) {\n        var r = [];\n        eachfn(arr, function (x, cb) {\n            fn(x, function (err, y) {\n                r = r.concat(y || []);\n                cb(err);\n            });\n        }, function (err) {\n            callback(err, r);\n        });\n    };\n    async.concat = doParallel(_concat);\n    async.concatSeries = doSeries(_concat);\n\n    async.whilst = function (test, iterator, callback) {\n        if (test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.whilst(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doWhilst = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            var args = _baseSlice(arguments, 1);\n            if (test.apply(null, args)) {\n                async.doWhilst(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.until = function (test, iterator, callback) {\n        if (!test()) {\n            iterator(function (err) {\n                if (err) {\n                    return callback(err);\n                }\n                async.until(test, iterator, callback);\n            });\n        }\n        else {\n            callback();\n        }\n    };\n\n    async.doUntil = function (iterator, test, callback) {\n        iterator(function (err) {\n            if (err) {\n                return callback(err);\n            }\n            var args = _baseSlice(arguments, 1);\n            if (!test.apply(null, args)) {\n                async.doUntil(iterator, test, callback);\n            }\n            else {\n                callback();\n            }\n        });\n    };\n\n    async.queue = function (worker, concurrency) {\n        if (concurrency === undefined) {\n            concurrency = 1;\n        }\n        else if(concurrency === 0) {\n            throw new Error('Concurrency must not be zero');\n        }\n        function _insert(q, data, pos, callback) {\n          if (!q.started){\n            q.started = true;\n          }\n          if (!_isArray(data)) {\n              data = [data];\n          }\n          if(data.length === 0) {\n             // call drain immediately if there are no tasks\n             return async.setImmediate(function() {\n                 if (q.drain) {\n                     q.drain();\n                 }\n             });\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              if (pos) {\n                q.tasks.unshift(item);\n              } else {\n                q.tasks.push(item);\n              }\n\n              if (q.saturated && q.tasks.length === q.concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        var workers = 0;\n        var q = {\n            tasks: [],\n            concurrency: concurrency,\n            saturated: null,\n            empty: null,\n            drain: null,\n            started: false,\n            paused: false,\n            push: function (data, callback) {\n              _insert(q, data, false, callback);\n            },\n            kill: function () {\n              q.drain = null;\n              q.tasks = [];\n            },\n            unshift: function (data, callback) {\n              _insert(q, data, true, callback);\n            },\n            process: function () {\n                if (!q.paused && workers < q.concurrency && q.tasks.length) {\n                    var task = q.tasks.shift();\n                    if (q.empty && q.tasks.length === 0) {\n                        q.empty();\n                    }\n                    workers += 1;\n                    var next = function () {\n                        workers -= 1;\n                        if (task.callback) {\n                            task.callback.apply(task, arguments);\n                        }\n                        if (q.drain && q.tasks.length + workers === 0) {\n                            q.drain();\n                        }\n                        q.process();\n                    };\n                    var cb = only_once(next);\n                    worker(task.data, cb);\n                }\n            },\n            length: function () {\n                return q.tasks.length;\n            },\n            running: function () {\n                return workers;\n            },\n            idle: function() {\n                return q.tasks.length + workers === 0;\n            },\n            pause: function () {\n                if (q.paused === true) { return; }\n                q.paused = true;\n            },\n            resume: function () {\n                if (q.paused === false) { return; }\n                q.paused = false;\n                var resumeCount = Math.min(q.concurrency, q.tasks.length);\n                // Need to call q.process once per concurrent\n                // worker to preserve full concurrency after pause\n                for (var w = 1; w <= resumeCount; w++) {\n                    async.setImmediate(q.process);\n                }\n            }\n        };\n        return q;\n    };\n\n    async.priorityQueue = function (worker, concurrency) {\n\n        function _compareTasks(a, b){\n          return a.priority - b.priority;\n        }\n\n        function _binarySearch(sequence, item, compare) {\n          var beg = -1,\n              end = sequence.length - 1;\n          while (beg < end) {\n            var mid = beg + ((end - beg + 1) >>> 1);\n            if (compare(item, sequence[mid]) >= 0) {\n              beg = mid;\n            } else {\n              end = mid - 1;\n            }\n          }\n          return beg;\n        }\n\n        function _insert(q, data, priority, callback) {\n          if (!q.started){\n            q.started = true;\n          }\n          if (!_isArray(data)) {\n              data = [data];\n          }\n          if(data.length === 0) {\n             // call drain immediately if there are no tasks\n             return async.setImmediate(function() {\n                 if (q.drain) {\n                     q.drain();\n                 }\n             });\n          }\n          _each(data, function(task) {\n              var item = {\n                  data: task,\n                  priority: priority,\n                  callback: typeof callback === 'function' ? callback : null\n              };\n\n              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n\n              if (q.saturated && q.tasks.length === q.concurrency) {\n                  q.saturated();\n              }\n              async.setImmediate(q.process);\n          });\n        }\n\n        // Start with a normal queue\n        var q = async.queue(worker, concurrency);\n\n        // Override push to accept second parameter representing priority\n        q.push = function (data, priority, callback) {\n          _insert(q, data, priority, callback);\n        };\n\n        // Remove unshift function\n        delete q.unshift;\n\n        return q;\n    };\n\n    async.cargo = function (worker, payload) {\n        var working     = false,\n            tasks       = [];\n\n        var cargo = {\n            tasks: tasks,\n            payload: payload,\n            saturated: null,\n            empty: null,\n            drain: null,\n            drained: true,\n            push: function (data, callback) {\n                if (!_isArray(data)) {\n                    data = [data];\n                }\n                _each(data, function(task) {\n                    tasks.push({\n                        data: task,\n                        callback: typeof callback === 'function' ? callback : null\n                    });\n                    cargo.drained = false;\n                    if (cargo.saturated && tasks.length === payload) {\n                        cargo.saturated();\n                    }\n                });\n                async.setImmediate(cargo.process);\n            },\n            process: function process() {\n                if (working) return;\n                if (tasks.length === 0) {\n                    if(cargo.drain && !cargo.drained) cargo.drain();\n                    cargo.drained = true;\n                    return;\n                }\n\n                var ts = typeof payload === 'number' ?\n                    tasks.splice(0, payload) :\n                    tasks.splice(0, tasks.length);\n\n                var ds = _map(ts, function (task) {\n                    return task.data;\n                });\n\n                if(cargo.empty) cargo.empty();\n                working = true;\n                worker(ds, function () {\n                    working = false;\n\n                    var args = arguments;\n                    _each(ts, function (data) {\n                        if (data.callback) {\n                            data.callback.apply(null, args);\n                        }\n                    });\n\n                    process();\n                });\n            },\n            length: function () {\n                return tasks.length;\n            },\n            running: function () {\n                return working;\n            }\n        };\n        return cargo;\n    };\n\n    var _console_fn = function (name) {\n        return function (fn) {\n            var args = _baseSlice(arguments, 1);\n            fn.apply(null, args.concat([function (err) {\n                var args = _baseSlice(arguments, 1);\n                if (typeof console !== 'undefined') {\n                    if (err) {\n                        if (console.error) {\n                            console.error(err);\n                        }\n                    }\n                    else if (console[name]) {\n                        _each(args, function (x) {\n                            console[name](x);\n                        });\n                    }\n                }\n            }]));\n        };\n    };\n    async.log = _console_fn('log');\n    async.dir = _console_fn('dir');\n    /*async.info = _console_fn('info');\n    async.warn = _console_fn('warn');\n    async.error = _console_fn('error');*/\n\n    async.memoize = function (fn, hasher) {\n        var memo = {};\n        var queues = {};\n        hasher = hasher || function (x) {\n            return x;\n        };\n        var memoized = function () {\n            var args = _baseSlice(arguments);\n            var callback = args.pop();\n            var key = hasher.apply(null, args);\n            if (key in memo) {\n                async.nextTick(function () {\n                    callback.apply(null, memo[key]);\n                });\n            }\n            else if (key in queues) {\n                queues[key].push(callback);\n            }\n            else {\n                queues[key] = [callback];\n                fn.apply(null, args.concat([function () {\n                    memo[key] = _baseSlice(arguments);\n                    var q = queues[key];\n                    delete queues[key];\n                    for (var i = 0, l = q.length; i < l; i++) {\n                      q[i].apply(null, arguments);\n                    }\n                }]));\n            }\n        };\n        memoized.memo = memo;\n        memoized.unmemoized = fn;\n        return memoized;\n    };\n\n    async.unmemoize = function (fn) {\n      return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n      };\n    };\n\n    async.times = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.map(counter, iterator, callback);\n    };\n\n    async.timesSeries = function (count, iterator, callback) {\n        var counter = [];\n        for (var i = 0; i < count; i++) {\n            counter.push(i);\n        }\n        return async.mapSeries(counter, iterator, callback);\n    };\n\n    async.seq = function (/* functions... */) {\n        var fns = arguments;\n        return function () {\n            var that = this;\n            var args = _baseSlice(arguments);\n            var callback = args.pop();\n            async.reduce(fns, args, function (newargs, fn, cb) {\n                fn.apply(that, newargs.concat([function () {\n                    var err = arguments[0];\n                    var nextargs = _baseSlice(arguments, 1);\n                    cb(err, nextargs);\n                }]));\n            },\n            function (err, results) {\n                callback.apply(that, [err].concat(results));\n            });\n        };\n    };\n\n    async.compose = function (/* functions... */) {\n      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n    };\n\n    var _applyEach = function (eachfn, fns /*args...*/) {\n        var go = function () {\n            var that = this;\n            var args = _baseSlice(arguments);\n            var callback = args.pop();\n            return eachfn(fns, function (fn, cb) {\n                fn.apply(that, args.concat([cb]));\n            },\n            callback);\n        };\n        if (arguments.length > 2) {\n            var args = _baseSlice(arguments, 2);\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n    async.applyEach = doParallel(_applyEach);\n    async.applyEachSeries = doSeries(_applyEach);\n\n    async.forever = function (fn, callback) {\n        function next(err) {\n            if (err) {\n                if (callback) {\n                    return callback(err);\n                }\n                throw err;\n            }\n            fn(next);\n        }\n        next();\n    };\n\n    // Node.js\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // AMD / RequireJS\n    else if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","import * as Path from 'path'\nimport * as winston from 'winston'\n\nimport { getLogDirectoryPath } from '../lib/logging/get-log-path'\nimport { LogLevel } from '../lib/logging/log-level'\nimport { ensureDir } from 'fs-extra'\n\nrequire('winston-daily-rotate-file')\n\n/**\n * The maximum number of log files we should have on disk before pruning old\n * ones.\n */\nconst MaxLogFiles = 14\n\n/** resolve the log file location based on the current channel */\nfunction getLogFilePath(directory: string): string {\n  const channel = __RELEASE_CHANNEL__\n  const fileName = `desktop.${channel}.log`\n  return Path.join(directory, fileName)\n}\n\n/**\n * Initializes winston and returns a subset of the available log level\n * methods (debug, info, error). This method should only be called once\n * during an application's lifetime.\n *\n * @param path The path where to write log files. This path will have\n *             the current date prepended to the basename part of the\n *             path such that passing a path '/logs/foo' will end up\n *             writing to '/logs/2017-05-17.foo'\n */\nfunction initializeWinston(path: string): winston.LogMethod {\n  const fileLogger = new winston.transports.DailyRotateFile({\n    filename: path,\n    // We'll do this ourselves, thank you\n    handleExceptions: false,\n    json: false,\n    datePattern: 'yyyy-MM-dd.',\n    prepend: true,\n    // log everything interesting (info and up)\n    level: 'info',\n    maxFiles: MaxLogFiles,\n  })\n\n  // The file logger handles errors when it can't write to an\n  // existing file but emits an error when attempting to create\n  // a file and failing (for example due to permissions or the\n  // disk being full). If logging fails that's not a big deal\n  // so we'll just suppress any error, besides, the console\n  // logger will likely still work.\n  fileLogger.on('error', () => {})\n\n  const consoleLogger = new winston.transports.Console({\n    level: process.env.NODE_ENV === 'development' ? 'debug' : 'error',\n  })\n\n  winston.configure({\n    transports: [consoleLogger, fileLogger],\n  })\n\n  return winston.log\n}\n\nlet loggerPromise: Promise<winston.LogMethod> | null = null\n\n/**\n * Initializes and configures winston (if necessary) to write to Electron's\n * console as well as to disk.\n *\n * @returns a function reference which can be used to write log entries,\n *          this function is equivalent to that of winston.log in that\n *          it accepts a log level, a message and an optional callback\n *          for when the event has been written to all destinations.\n */\nfunction getLogger(): Promise<winston.LogMethod> {\n  if (loggerPromise) {\n    return loggerPromise\n  }\n\n  loggerPromise = new Promise<winston.LogMethod>((resolve, reject) => {\n    const logDirectory = getLogDirectoryPath()\n\n    ensureDir(logDirectory)\n      .then(() => {\n        try {\n          const logger = initializeWinston(getLogFilePath(logDirectory))\n          resolve(logger)\n        } catch (err) {\n          reject(err)\n        }\n      })\n      .catch(error => {\n        reject(error)\n      })\n  })\n\n  return loggerPromise\n}\n\n/**\n * Write the given log entry to all configured transports,\n * see initializeWinston in logger.ts for more details about\n * what transports we set up.\n *\n * Returns a promise that will never yield an error and which\n * resolves when the log entry has been written to all transports\n * or if the entry could not be written due to an error.\n */\nexport async function log(level: LogLevel, message: string) {\n  try {\n    const logger = await getLogger()\n    await new Promise<void>((resolve, reject) => {\n      logger(level, message, error => {\n        if (error) {\n          reject(error)\n        } else {\n          resolve()\n        }\n      })\n    })\n  } catch (error) {\n    /**\n     * Welp. I guess we have to ignore this for now, we\n     * don't have any good mechanisms for reporting this.\n     * In the future we can discuss whether we should\n     * IPC to the renderer or dump it somewhere else\n     * but for now logging isn't a critical thing.\n     */\n  }\n}\n","/**\n * Send a caught (ie. non-fatal) exception to the\n * non-fatal error bucket\n *\n * The intended use of this message is for getting insight into\n * areas of the code where we suspect alternate failure modes\n * other than those accounted for.\n *\n * Example: In the Desktop tutorial creation logic we handle\n * all errors and our initial belief was that the only two failure\n * modes we would have to account for were either the repo existing\n * on disk or on the user's account. We now suspect that there might\n * be other reasons why the creation logic is failing and therefore\n * want to send all errors encountered during creation to central\n * where we can determine if there are additional failure modes\n * for us to consider.\n *\n * @param kind - a grouping key that allows us to group all errors\n * originating in the same area of the code base or relating to the\n * same kind of failure (recommend a single non-hyphenated word)\n * Example: tutorialRepoCreation\n *\n * @param error - the caught error\n */\n\nexport function sendNonFatalException(kind: string, error: Error) {\n  process.emit('send-non-fatal-exception', error, { kind })\n}\n","import { IMenuItem } from '../../lib/menu-item'\nimport { Menu, MenuItem } from 'electron'\n\n/**\n * Gets a value indicating whether or not two roles are considered\n * equal using a case-insensitive comparison.\n */\nfunction roleEquals(x: string | undefined, y: string | undefined) {\n  return (x ? x.toLowerCase() : x) === (y ? y.toLowerCase() : y)\n}\n\n/**\n * Get platform-specific edit menu items by leveraging Electron's\n * built-in editMenu role.\n */\nfunction getEditMenuItems(): ReadonlyArray<MenuItem> {\n  const menu = Menu.buildFromTemplate([{ role: 'editMenu' }]).items[0]\n\n  // Electron is violating its contract if there's no subMenu but\n  // we'd rather just ignore it than crash. It's not the end of\n  // the world if we don't have edit menu items.\n  const items = menu && menu.submenu ? menu.submenu.items : []\n\n  // We don't use styled inputs anywhere at the moment\n  // so let's skip this for now and when/if we do we\n  // can make it configurable from the callee\n  return items.filter(x => !roleEquals(x.role, 'pasteandmatchstyle'))\n}\n\n/**\n * Create an Electron menu object for use in a context menu based on\n * a template provided by the renderer.\n *\n * If the template contains a menu item with the role 'editMenu' the\n * platform standard edit menu items will be inserted at the position\n * of the 'editMenu' template.\n *\n * @param template One or more menu item templates as passed from\n *                 the renderer.\n * @param onClick  A callback function for when one of the menu items\n *                 constructed from the template is clicked. Callback\n *                 is passed an array of indices corresponding to the\n *                 positions of each of the parent menus of the clicked\n *                 item (so when clicking a top-level menu item an array\n *                 with a single element will be passed). Note that the\n *                 callback will not be called when expanded/automatically\n *                 created edit menu items are clicked.\n */\nexport function buildContextMenu(\n  template: ReadonlyArray<IMenuItem>,\n  onClick: (indices: ReadonlyArray<number>) => void\n): Menu {\n  return buildRecursiveContextMenu(template, onClick)\n}\n\nfunction buildRecursiveContextMenu(\n  menuItems: ReadonlyArray<IMenuItem>,\n  actionFn: (indices: ReadonlyArray<number>) => void,\n  currentIndices: ReadonlyArray<number> = []\n): Menu {\n  const menu = new Menu()\n\n  for (const [idx, item] of menuItems.entries()) {\n    if (roleEquals(item.role, 'editmenu')) {\n      for (const editItem of getEditMenuItems()) {\n        menu.append(editItem)\n      }\n    } else {\n      const indices = [...currentIndices, idx]\n\n      menu.append(\n        new MenuItem({\n          label: item.label,\n          type: item.type,\n          enabled: item.enabled,\n          role: item.role,\n          click: () => actionFn(indices),\n          submenu: item.submenu\n            ? buildRecursiveContextMenu(item.submenu, actionFn, indices)\n            : undefined,\n        })\n      )\n    }\n  }\n\n  return menu\n}\n","import { BrowserWindow, ipcMain } from 'electron'\nimport { Emitter, Disposable } from 'event-kit'\nimport { ICrashDetails, ErrorType } from '../crash/shared'\nimport { registerWindowStateChangedEvents } from '../lib/window-state'\n\nconst minWidth = 600\nconst minHeight = 500\n\n/**\n * A wrapper around the BrowserWindow instance for our crash process.\n *\n * The crash process is responsible for presenting the user with an\n * error after the main process or any renderer process has crashed due\n * to an uncaught exception or when the main renderer has failed to load.\n */\nexport class CrashWindow {\n  private readonly window: Electron.BrowserWindow\n  private readonly emitter = new Emitter()\n  private readonly errorType: ErrorType\n  private readonly error: Error\n\n  private hasFinishedLoading = false\n  private hasSentReadyEvent = false\n\n  public constructor(errorType: ErrorType, error: Error) {\n    const windowOptions: Electron.BrowserWindowConstructorOptions = {\n      width: minWidth,\n      height: minHeight,\n      minWidth: minWidth,\n      minHeight: minHeight,\n      show: false,\n      // This fixes subpixel aliasing on Windows\n      // See https://github.com/atom/atom/commit/683bef5b9d133cb194b476938c77cc07fd05b972\n      backgroundColor: '#fff',\n      webPreferences: {\n        // Disable auxclick event\n        // See https://developers.google.com/web/updates/2016/10/auxclick\n        disableBlinkFeatures: 'Auxclick',\n        // Explicitly disable experimental features for the crash process\n        // since, theoretically it might be these features that caused the\n        // the crash in the first place. As of writing we don't use any\n        // components that relies on experimental features in the crash\n        // process but our components which relies on ResizeObserver should\n        // be able to degrade gracefully.\n        experimentalFeatures: false,\n        nodeIntegration: true,\n      },\n    }\n\n    if (__DARWIN__) {\n      windowOptions.titleBarStyle = 'hidden'\n    } else if (__WIN32__) {\n      windowOptions.frame = false\n    }\n\n    this.window = new BrowserWindow(windowOptions)\n    this.error = error\n    this.errorType = errorType\n  }\n\n  public load() {\n    log.debug('Starting crash process')\n\n    // We only listen for the first of the loading events to avoid a bug in\n    // Electron/Chromium where they can sometimes fire more than once. See\n    // See\n    // https://github.com/desktop/desktop/pull/513#issuecomment-253028277. This\n    // shouldn't really matter as in production builds loading _should_ only\n    // happen once.\n    this.window.webContents.once('did-start-loading', () => {\n      log.debug('Crash process in startup')\n    })\n\n    this.window.webContents.once('did-finish-load', () => {\n      log.debug('Crash process started')\n      if (process.env.NODE_ENV === 'development') {\n        this.window.webContents.openDevTools()\n      }\n\n      this.hasFinishedLoading = true\n      this.maybeEmitDidLoad()\n    })\n\n    this.window.webContents.on('did-finish-load', () => {\n      this.window.webContents.setVisualZoomLevelLimits(1, 1)\n    })\n\n    this.window.webContents.on('did-fail-load', () => {\n      log.error('Crash process failed to load')\n      if (__DEV__) {\n        this.window.webContents.openDevTools()\n        this.window.show()\n      } else {\n        this.emitter.emit('did-fail-load', null)\n      }\n    })\n\n    ipcMain.on('crash-ready', (event: Electron.IpcMainEvent) => {\n      log.debug(`Crash process is ready`)\n\n      this.hasSentReadyEvent = true\n\n      this.sendError()\n      this.maybeEmitDidLoad()\n    })\n\n    ipcMain.on('crash-quit', (event: Electron.IpcMainEvent) => {\n      log.debug('Got quit signal from crash process')\n      this.window.close()\n    })\n\n    registerWindowStateChangedEvents(this.window)\n\n    this.window.loadURL(`file://${__dirname}/crash.html`)\n  }\n\n  /**\n   * Emit the `onDidLoad` event if the page has loaded and the renderer has\n   * signalled that it's ready.\n   */\n  private maybeEmitDidLoad() {\n    if (this.hasFinishedLoading && this.hasSentReadyEvent) {\n      this.emitter.emit('did-load', null)\n    }\n  }\n\n  public onClose(fn: () => void) {\n    this.window.on('closed', fn)\n  }\n\n  public onFailedToLoad(fn: () => void) {\n    this.emitter.on('did-fail-load', fn)\n  }\n\n  /**\n   * Register a function to call when the window is done loading. At that point\n   * the page has loaded and the renderer has signalled that it is ready.\n   */\n  public onDidLoad(fn: () => void): Disposable {\n    return this.emitter.on('did-load', fn)\n  }\n\n  public focus() {\n    this.window.focus()\n  }\n\n  /** Show the window. */\n  public show() {\n    log.debug('Showing crash process window')\n    this.window.show()\n  }\n\n  /** Report the error to the renderer. */\n  private sendError() {\n    // `Error` can't be JSONified so it doesn't transport nicely over IPC. So\n    // we'll just manually copy the properties we care about.\n    const friendlyError = {\n      stack: this.error.stack,\n      message: this.error.message,\n      name: this.error.name,\n    }\n\n    const details: ICrashDetails = {\n      type: this.errorType,\n      error: friendlyError,\n    }\n\n    this.window.webContents.send('error', details)\n  }\n\n  public destroy() {\n    this.window.destroy()\n  }\n}\n","import { app, dialog } from 'electron'\nimport { setCrashMenu } from './menu'\nimport { formatError } from '../lib/logging/format-error'\nimport { CrashWindow } from './crash-window'\n\nlet hasReportedUncaughtException = false\n\n/** Show the uncaught exception UI. */\nexport function showUncaughtException(isLaunchError: boolean, error: Error) {\n  log.error(formatError(error))\n\n  if (hasReportedUncaughtException) {\n    return\n  }\n\n  hasReportedUncaughtException = true\n\n  setCrashMenu()\n\n  const crashWindow = new CrashWindow(\n    isLaunchError ? 'launch' : 'generic',\n    error\n  )\n\n  crashWindow.onDidLoad(() => {\n    crashWindow.show()\n  })\n\n  crashWindow.onFailedToLoad(async () => {\n    await dialog.showMessageBox({\n      type: 'error',\n      title: __DARWIN__ ? `Unrecoverable Error` : 'Unrecoverable error',\n      message:\n        `GitHub Desktop has encountered an unrecoverable error and will need to restart.\\n\\n` +\n        `This has been reported to the team, but if you encounter this repeatedly please report ` +\n        `this issue to the GitHub Desktop issue tracker.\\n\\n${error.stack ||\n          error.message}`,\n    })\n\n    if (!__DEV__) {\n      app.relaunch()\n    }\n    app.quit()\n  })\n\n  crashWindow.onClose(() => {\n    if (!__DEV__) {\n      app.relaunch()\n    }\n    app.quit()\n  })\n\n  crashWindow.load()\n}\n","import { app, net } from 'electron'\n\nconst ErrorEndpoint = 'https://central.github.com/api/desktop/exception'\nconst NonFatalErrorEndpoint =\n  'https://central.github.com/api/desktop-non-fatal/exception'\n\n/** Report the error to Central. */\nexport async function reportError(\n  error: Error,\n  extra?: { [key: string]: string },\n  nonFatal?: boolean\n) {\n  if (__DEV__) {\n    return\n  }\n\n  const data = new Map<string, string>()\n\n  data.set('name', error.name)\n  data.set('message', error.message)\n\n  if (error.stack) {\n    data.set('stack', error.stack)\n  }\n\n  data.set('platform', process.platform)\n  data.set('sha', __SHA__)\n  data.set('version', app.getVersion())\n\n  if (extra) {\n    for (const key of Object.keys(extra)) {\n      data.set(key, extra[key])\n    }\n  }\n\n  const requestOptions: Electron.RequestOptions = {\n    method: 'POST',\n    url: nonFatal ? NonFatalErrorEndpoint : ErrorEndpoint,\n    headers: {\n      'Content-Type': 'application/x-www-form-urlencoded',\n    },\n  }\n\n  const body = [...data.entries()]\n    .map(\n      ([key, value]) =>\n        `${encodeURIComponent(key)}=${encodeURIComponent(value)}`\n    )\n    .join('&')\n\n  try {\n    await new Promise<void>((resolve, reject) => {\n      const request = net.request(requestOptions)\n\n      request.on('response', response => {\n        if (response.statusCode === 200) {\n          resolve()\n        } else {\n          reject(\n            `Got ${response.statusCode} - ${\n              response.statusMessage\n            } from central`\n          )\n        }\n      })\n\n      request.on('error', reject)\n\n      request.end(body)\n    })\n    log.info('Error report submitted')\n  } catch (e) {\n    log.error('Failed submitting error report', error)\n  }\n}\n","import { spawn as spawnInternal } from 'child_process'\nimport * as Path from 'path'\n\n/** Get the path segments in the user's `Path`. */\nexport async function getPathSegments(): Promise<ReadonlyArray<string>> {\n  let powershellPath: string\n  const systemRoot = process.env.SystemRoot\n  if (systemRoot != null) {\n    const system32Path = Path.join(systemRoot, 'System32')\n    powershellPath = Path.join(\n      system32Path,\n      'WindowsPowerShell',\n      'v1.0',\n      'powershell.exe'\n    )\n  } else {\n    powershellPath = 'powershell.exe'\n  }\n\n  const args = [\n    '-noprofile',\n    '-ExecutionPolicy',\n    'RemoteSigned',\n    '-command',\n    // Set encoding and execute the command, capture the output, and return it\n    // via .NET's console in order to have consistent UTF-8 encoding.\n    // See http://stackoverflow.com/questions/22349139/utf-8-output-from-powershell\n    // to address https://github.com/atom/atom/issues/5063\n    `\n      [Console]::OutputEncoding=[System.Text.Encoding]::UTF8\n      $output=[environment]::GetEnvironmentVariable('Path', 'User')\n      [Console]::WriteLine($output)\n    `,\n  ]\n\n  const stdout = await spawn(powershellPath, args)\n  const pathOutput = stdout.replace(/^\\s+|\\s+$/g, '')\n  return pathOutput.split(/;+/).filter(segment => segment.length)\n}\n\n/** Set the user's `Path`. */\nexport async function setPathSegments(\n  paths: ReadonlyArray<string>\n): Promise<void> {\n  let setxPath: string\n  const systemRoot = process.env['SystemRoot']\n  if (systemRoot) {\n    const system32Path = Path.join(systemRoot, 'System32')\n    setxPath = Path.join(system32Path, 'setx.exe')\n  } else {\n    setxPath = 'setx.exe'\n  }\n\n  await spawn(setxPath, ['Path', paths.join(';')])\n}\n\n/** Spawn a command with arguments and capture its output. */\nexport function spawn(\n  command: string,\n  args: ReadonlyArray<string>\n): Promise<string> {\n  try {\n    const child = spawnInternal(command, args as string[])\n    return new Promise<string>((resolve, reject) => {\n      let stdout = ''\n\n      // If Node.js encounters a synchronous runtime error while spawning\n      // `stdout` will be undefined and the error will be emitted asynchronously\n      if (child.stdout) {\n        child.stdout.on('data', data => {\n          stdout += data\n        })\n      }\n\n      child.on('close', code => {\n        if (code === 0) {\n          resolve(stdout)\n        } else {\n          reject(new Error(`Command \"${command} ${args}\" failed: \"${stdout}\"`))\n        }\n      })\n\n      child.on('error', (err: Error) => {\n        reject(err)\n      })\n\n      if (child.stdin) {\n        // This is necessary if using Powershell 2 on Windows 7 to get the events\n        // to raise.\n        // See http://stackoverflow.com/questions/9155289/calling-powershell-from-nodejs\n        child.stdin.end()\n      }\n    })\n  } catch (error) {\n    return Promise.reject(error)\n  }\n}\n","import * as Path from 'path'\nimport * as Os from 'os'\n\nimport { pathExists, ensureDir, writeFile } from 'fs-extra'\nimport { spawn, getPathSegments, setPathSegments } from '../lib/process/win32'\n\nconst appFolder = Path.resolve(process.execPath, '..')\nconst rootAppDir = Path.resolve(appFolder, '..')\nconst updateDotExe = Path.resolve(Path.join(rootAppDir, 'Update.exe'))\nconst exeName = Path.basename(process.execPath)\n\n// A lot of this code was cargo-culted from our Atom comrades:\n// https://github.com/atom/atom/blob/7c9f39e3f1d05ee423e0093e6b83f042ce11c90a/src/main-process/squirrel-update.coffee.\n\n/**\n * Handle Squirrel.Windows app lifecycle events.\n *\n * Returns a promise which will resolve when the work is done.\n */\nexport function handleSquirrelEvent(eventName: string): Promise<void> | null {\n  switch (eventName) {\n    case '--squirrel-install':\n      return handleInstalled()\n\n    case '--squirrel-updated':\n      return handleUpdated()\n\n    case '--squirrel-uninstall':\n      return handleUninstall()\n\n    case '--squirrel-obsolete':\n      return Promise.resolve()\n  }\n\n  return null\n}\n\nasync function handleInstalled(): Promise<void> {\n  await createShortcut(['StartMenu', 'Desktop'])\n  await installCLI()\n}\n\nasync function handleUpdated(): Promise<void> {\n  await updateShortcut()\n  await installCLI()\n}\n\nasync function installCLI(): Promise<void> {\n  const binPath = getBinPath()\n  await ensureDir(binPath)\n  await writeBatchScriptCLITrampoline(binPath)\n  await writeShellScriptCLITrampoline(binPath)\n  const paths = await getPathSegments()\n  if (paths.indexOf(binPath) < 0) {\n    await setPathSegments([...paths, binPath])\n  }\n}\n\n/**\n * Get the path for the `bin` directory which exists in our `AppData` but\n * outside path which includes the installed app version.\n */\nfunction getBinPath(): string {\n  return Path.resolve(process.execPath, '../../bin')\n}\n\nfunction resolveVersionedPath(binPath: string, relativePath: string): string {\n  const appFolder = Path.resolve(process.execPath, '..')\n  return Path.relative(binPath, Path.join(appFolder, relativePath))\n}\n\n/**\n * Here's the problem: our app's path contains its version number. So each time\n * we update, the path to our app changes. So it's Real Hard to add our path\n * directly to `Path`. We'd have to detect and remove stale entries, etc.\n *\n * So instead, we write a trampoline out to a fixed path, still inside our\n * `AppData` directory but outside the version-specific path. That trampoline\n * just launches the current version's CLI tool. Then, whenever we update, we\n * rewrite the trampoline to point to the new, version-specific path. Bingo\n * bango Bob's your uncle.\n */\nfunction writeBatchScriptCLITrampoline(binPath: string): Promise<void> {\n  const versionedPath = resolveVersionedPath(\n    binPath,\n    'resources/app/static/github.bat'\n  )\n\n  const trampoline = `@echo off\\n\"%~dp0\\\\${versionedPath}\" %*`\n  const trampolinePath = Path.join(binPath, 'github.bat')\n\n  return writeFile(trampolinePath, trampoline)\n}\n\nfunction writeShellScriptCLITrampoline(binPath: string): Promise<void> {\n  // The path we get from `resolveVersionedPath` is a Win32 relative\n  // path (something like `..\\app-2.5.0\\resources\\app\\static\\github.sh`).\n  // We need to make sure it's a POSIX path in order for WSL to be able\n  // to resolve it. See https://github.com/desktop/desktop/issues/4998\n  const versionedPath = resolveVersionedPath(\n    binPath,\n    'resources/app/static/github.sh'\n  ).replace(/\\\\/g, '/')\n\n  const trampoline = `#!/usr/bin/env bash\n  DIR=\"$( cd \"$( dirname \"\\$\\{BASH_SOURCE[0]\\}\" )\" && pwd )\"\n  sh \"$DIR/${versionedPath}\" \"$@\"`\n  const trampolinePath = Path.join(binPath, 'github')\n\n  return writeFile(trampolinePath, trampoline, { encoding: 'utf8', mode: 755 })\n}\n\n/** Spawn the Squirrel.Windows `Update.exe` with a command. */\nasync function spawnSquirrelUpdate(\n  commands: ReadonlyArray<string>\n): Promise<void> {\n  await spawn(updateDotExe, commands)\n}\n\ntype ShortcutLocations = ReadonlyArray<'StartMenu' | 'Desktop'>\n\nfunction createShortcut(locations: ShortcutLocations): Promise<void> {\n  return spawnSquirrelUpdate([\n    '--createShortcut',\n    exeName,\n    '-l',\n    locations.join(','),\n  ])\n}\n\nasync function handleUninstall(): Promise<void> {\n  await removeShortcut()\n\n  const paths = await getPathSegments()\n  const binPath = getBinPath()\n  const pathsWithoutBinPath = paths.filter(p => p !== binPath)\n  return setPathSegments(pathsWithoutBinPath)\n}\n\nfunction removeShortcut(): Promise<void> {\n  return spawnSquirrelUpdate(['--removeShortcut', exeName])\n}\n\nasync function updateShortcut(): Promise<void> {\n  const homeDirectory = Os.homedir()\n  if (homeDirectory) {\n    const desktopShortcutPath = Path.join(\n      homeDirectory,\n      'Desktop',\n      'GitHub Desktop.lnk'\n    )\n    const exists = await pathExists(desktopShortcutPath)\n    const locations: ShortcutLocations = exists\n      ? ['StartMenu', 'Desktop']\n      : ['StartMenu']\n    return createShortcut(locations)\n  } else {\n    return createShortcut(['StartMenu', 'Desktop'])\n  }\n}\n","// See https://www.kernel.org/pub/software/scm/git/docs/git-check-ref-format.html\n// ASCII Control chars and space, DEL, ~ ^ : ? * [ \\\n// | \" < and > is technically a valid refname but not on Windows\n// the magic sequence @{, consecutive dots, leading and trailing dot, ref ending in .lock\nconst invalidCharacterRegex = /[\\x00-\\x20\\x7F~^:?*\\[\\\\|\"\"<>]+|@{|\\.\\.+|^\\.|\\.$|\\.lock$|\\/$/g\n\n/** Sanitize a proposed reference name by replacing illegal characters. */\nexport function sanitizedRefName(name: string): string {\n  return name.replace(invalidCharacterRegex, '-').replace(/^[-\\+]*/g, '')\n}\n\n/** Validate that a reference does not contain any invalid characters */\nexport function testForInvalidChars(name: string): boolean {\n  return invalidCharacterRegex.test(name)\n}\n","import * as URL from 'url'\nimport { testForInvalidChars } from './sanitize-ref-name'\n\nexport interface IOAuthAction {\n  readonly name: 'oauth'\n  readonly code: string\n  readonly state: string\n}\n\nexport interface IOpenRepositoryFromURLAction {\n  readonly name: 'open-repository-from-url'\n\n  /** the remote repository location associated with the \"Open in Desktop\" action */\n  readonly url: string\n\n  /** the optional branch name which should be checked out. use the default branch otherwise. */\n  readonly branch: string | null\n\n  /** the pull request number, if pull request originates from a fork of the repository */\n  readonly pr: string | null\n\n  /** the file to open after cloning the repository */\n  readonly filepath: string | null\n}\n\nexport interface IOpenRepositoryFromPathAction {\n  readonly name: 'open-repository-from-path'\n\n  /** The local path to open. */\n  readonly path: string\n}\n\nexport interface IUnknownAction {\n  readonly name: 'unknown'\n  readonly url: string\n}\n\nexport type URLActionType =\n  | IOAuthAction\n  | IOpenRepositoryFromURLAction\n  | IOpenRepositoryFromPathAction\n  | IUnknownAction\n\n// eslint-disable-next-line @typescript-eslint/interface-name-prefix\ninterface ParsedUrlQueryWithUndefined {\n  // `undefined` is added here to ensure we handle the missing querystring key\n  // See https://github.com/Microsoft/TypeScript/issues/13778 for discussion about\n  // why this isn't supported natively in TypeScript\n  [key: string]: string | string[] | undefined\n}\n\n/**\n * Parse the URL to find a given key in the querystring text.\n *\n * @param url The source URL containing querystring key-value pairs\n * @param key The key to look for in the querystring\n */\nfunction getQueryStringValue(\n  query: ParsedUrlQueryWithUndefined,\n  key: string\n): string | null {\n  const value = query[key]\n  if (value == null) {\n    return null\n  }\n\n  if (Array.isArray(value)) {\n    return value[0]\n  }\n\n  return value\n}\n\nexport function parseAppURL(url: string): URLActionType {\n  const parsedURL = URL.parse(url, true)\n  const hostname = parsedURL.hostname\n  const unknown: IUnknownAction = { name: 'unknown', url }\n  if (!hostname) {\n    return unknown\n  }\n\n  const query = parsedURL.query\n\n  const actionName = hostname.toLowerCase()\n  if (actionName === 'oauth') {\n    const code = getQueryStringValue(query, 'code')\n    const state = getQueryStringValue(query, 'state')\n    if (code != null && state != null) {\n      return { name: 'oauth', code, state }\n    } else {\n      return unknown\n    }\n  }\n\n  // we require something resembling a URL first\n  // - bail out if it's not defined\n  // - bail out if you only have `/`\n  const pathName = parsedURL.pathname\n  if (!pathName || pathName.length <= 1) {\n    return unknown\n  }\n\n  // Trim the trailing / from the URL\n  const parsedPath = pathName.substr(1)\n\n  if (actionName === 'openrepo') {\n    const pr = getQueryStringValue(query, 'pr')\n    const branch = getQueryStringValue(query, 'branch')\n    const filepath = getQueryStringValue(query, 'filepath')\n\n    if (pr != null) {\n      if (!/^\\d+$/.test(pr)) {\n        return unknown\n      }\n\n      // we also expect the branch for a forked PR to be a given ref format\n      if (branch != null && !/^pr\\/\\d+$/.test(branch)) {\n        return unknown\n      }\n    }\n\n    if (branch != null && testForInvalidChars(branch)) {\n      return unknown\n    }\n\n    return {\n      name: 'open-repository-from-url',\n      url: parsedPath,\n      branch,\n      pr,\n      filepath,\n    }\n  }\n\n  if (actionName === 'openlocalrepo') {\n    return {\n      name: 'open-repository-from-path',\n      path: decodeURIComponent(parsedPath),\n    }\n  }\n\n  return unknown\n}\n","/* eslint-disable no-sync */\n\nimport * as ChildProcess from 'child_process'\nimport * as os from 'os'\n\ntype IndexLookup = {\n  [propName: string]: string\n}\n\n/**\n * The names of any env vars that we shouldn't copy from the shell environment.\n */\nconst ExcludedEnvironmentVars = new Set(['LOCAL_GIT_DIRECTORY'])\n\n/**\n * Inspect whether the current process needs to be patched to get important\n * environment variables for Desktop to work and integrate with other tools\n * the user may invoke as part of their workflow.\n *\n * This is only applied to macOS installations due to how the application\n * is launched.\n *\n * @param process The process to inspect.\n */\nexport function shellNeedsPatching(process: NodeJS.Process): boolean {\n  return __DARWIN__ && !process.env.PWD\n}\n\ntype ShellResult = {\n  stdout: string\n  error: Error | null\n}\n\n/**\n * Gets a dump of the user's configured shell environment.\n *\n * @returns the output of the `env` command or `null` if there was an error.\n */\nasync function getRawShellEnv(): Promise<string | null> {\n  const shell = getUserShell()\n\n  const promise = new Promise<ShellResult>(resolve => {\n    let child: ChildProcess.ChildProcess | null = null\n    let error: Error | null = null\n    let stdout = ''\n    let done = false\n\n    // ensure we clean up eventually, in case things go bad\n    const cleanup = () => {\n      if (!done && child) {\n        child.kill()\n        done = true\n      }\n    }\n    process.once('exit', cleanup)\n    setTimeout(() => {\n      cleanup()\n    }, 5000)\n\n    child = ChildProcess.spawn(shell, ['-ilc', 'command env'], {\n      detached: true,\n      stdio: ['ignore', 'pipe', process.stderr],\n    })\n\n    const buffers: Array<Buffer> = []\n\n    child.on('error', (e: Error) => {\n      done = true\n      error = e\n    })\n\n    // If Node.js encounters a synchronous runtime error while spawning\n    // `stdout` will be undefined and the error will be emitted asynchronously\n    if (child.stdout) {\n      child.stdout.on('data', (data: Buffer) => {\n        buffers.push(data)\n      })\n    }\n\n    child.on('close', (code: number, signal) => {\n      done = true\n      process.removeListener('exit', cleanup)\n      if (buffers.length) {\n        stdout = Buffer.concat(buffers).toString('utf8')\n      }\n\n      resolve({ stdout, error })\n    })\n  })\n\n  const { stdout, error } = await promise\n\n  if (error) {\n    // just swallow the error and move on with everything\n    return null\n  }\n\n  return stdout\n}\n\nfunction getUserShell() {\n  if (process.env.SHELL) {\n    return process.env.SHELL\n  }\n\n  return '/bin/bash'\n}\n\n/**\n * Get the environment variables from the user's current shell and update the\n * current environment.\n *\n * @param updateEnvironment a callback to fire if a valid environment is found\n */\nasync function getEnvironmentFromShell(\n  updateEnvironment: (env: IndexLookup) => void\n): Promise<void> {\n  if (__WIN32__) {\n    return\n  }\n\n  const shellEnvText = await getRawShellEnv()\n  if (!shellEnvText) {\n    return\n  }\n\n  const env: IndexLookup = {}\n\n  for (const line of shellEnvText.split(os.EOL)) {\n    if (line.includes('=')) {\n      const components = line.split('=')\n      if (components.length === 2) {\n        env[components[0]] = components[1]\n      } else {\n        const k = components.shift()\n        const v = components.join('=')\n        if (k) {\n          env[k] = v\n        }\n      }\n    }\n  }\n\n  updateEnvironment(env)\n}\n\n/**\n * Apply new environment variables to the current process, ignoring\n * Node-specific environment variables which need to be preserved.\n *\n * @param env The new environment variables from the user's shell.\n */\nfunction mergeEnvironmentVariables(env: IndexLookup) {\n  for (const key in env) {\n    if (ExcludedEnvironmentVars.has(key)) {\n      continue\n    }\n\n    process.env[key] = env[key]\n  }\n}\n\n/**\n * Update the current process's environment variables using environment\n * variables from the user's shell, if they can be retrieved successfully.\n */\nexport function updateEnvironmentForProcess(): Promise<void> {\n  return getEnvironmentFromShell(mergeEnvironmentVariables)\n}\n","import { Menu, MenuItem } from 'electron'\n\n/**\n * Returns an iterator that traverses the menu and all\n * submenus and yields each menu item therein.\n */\nexport function* getAllMenuItems(menu: Menu): IterableIterator<MenuItem> {\n  for (const menuItem of menu.items) {\n    yield menuItem\n\n    if (menuItem.type === 'submenu' && menuItem.submenu !== undefined) {\n      yield* getAllMenuItems(menuItem.submenu)\n    }\n  }\n}\n","import { Menu } from 'electron'\n\n/**\n * Update the menu to disable all non-essential menu items.\n *\n * Used when the app has detected a non-recoverable error and\n * the ui process has been terminated. Since most of the app\n * menu items require the ui process to work we'll have to\n * disable them.\n */\nexport function setCrashMenu() {\n  const menu = Menu.getApplicationMenu()\n\n  if (!menu) {\n    return\n  }\n\n  for (const topLevelItem of menu.items) {\n    disable(topLevelItem)\n  }\n}\n\nfunction disable(item: Electron.MenuItem) {\n  let anyEnabled = false\n\n  if (item.submenu instanceof Menu) {\n    for (const submenuItem of item.submenu.items) {\n      if (disable(submenuItem)) {\n        anyEnabled = true\n      }\n    }\n  }\n\n  if (anyEnabled || item.role) {\n    return true\n  }\n\n  const id = (item as any).id\n\n  if (id === 'show-devtools' || id === 'reload-window') {\n    return true\n  }\n\n  item.enabled = false\n  return false\n}\n","const RestrictedFileExtensions = ['.cmd', '.exe', '.bat', '.sh']\nexport const CopyFilePathLabel = __DARWIN__\n  ? 'Copy File Path'\n  : 'Copy file path'\n\nexport const DefaultEditorLabel = __DARWIN__\n  ? 'Open in External Editor'\n  : 'Open in external editor'\n\nexport const RevealInFileManagerLabel = __DARWIN__\n  ? 'Reveal in Finder'\n  : __WIN32__\n  ? 'Show in Explorer'\n  : 'Show in your File Manager'\n\nexport const TrashNameLabel = __DARWIN__ ? 'Trash' : 'Recycle Bin'\n\nexport const OpenWithDefaultProgramLabel = __DARWIN__\n  ? 'Open with Default Program'\n  : 'Open with default program'\n\nexport function isSafeFileExtension(extension: string): boolean {\n  if (__WIN32__) {\n    return RestrictedFileExtensions.indexOf(extension.toLowerCase()) === -1\n  }\n  return true\n}\n","const Disable = false\n\n/**\n * Enables the application to opt-in for preview features based on runtime\n * checks. This is backed by the GITHUB_DESKTOP_PREVIEW_FEATURES environment\n * variable, which is checked for non-development environments.\n */\nfunction enableDevelopmentFeatures(): boolean {\n  if (Disable) {\n    return false\n  }\n\n  if (__DEV__) {\n    return true\n  }\n\n  if (process.env.GITHUB_DESKTOP_PREVIEW_FEATURES === '1') {\n    return true\n  }\n\n  return false\n}\n\n/** Should we show progress bars on the Windows app taskbar icon? */\nexport function enableProgressBarOnIcon(): boolean {\n  return enableBetaFeatures()\n}\n\n/** Should the app enable beta features? */\n//@ts-ignore: this will be used again in the future\nfunction enableBetaFeatures(): boolean {\n  return enableDevelopmentFeatures() || __RELEASE_CHANNEL__ === 'beta'\n}\n\n/** Should git pass `--recurse-submodules` when performing operations? */\nexport function enableRecurseSubmodulesFlag(): boolean {\n  return enableBetaFeatures()\n}\n\nexport function enableReadmeOverwriteWarning(): boolean {\n  return enableBetaFeatures()\n}\n\n/** Should the app detect Windows Subsystem for Linux as a valid shell? */\nexport function enableWSLDetection(): boolean {\n  return enableBetaFeatures()\n}\n\n/**\n * Should we show the create fork dialog flow?\n */\nexport function enableCreateForkFlow(): boolean {\n  return true\n}\n\n/**\n * Whether or not we should attempt to detect the specific curl\n * error from the WinSSL (schannel) https backend when it fails\n * to check the revocation details of a certificate due to lacking\n * CRL distribution points and/or an offiline revocation server.\n */\nexport function enableSchannelCheckRevokeOptOut(): boolean {\n  return true\n}\n\n/**\n * Whether or not to enable support for automatically resolving the\n * system-configured proxy url and passing that to Git.\n */\nexport function enableAutomaticGitProxyConfiguration(): boolean {\n  return true\n}\n\n/**\n * Should we show the \"Create Issue on GitHub\" item under\n * \"Repository\" in the app menu?\n */\nexport function enableCreateGitHubIssueFromMenu(): boolean {\n  return true\n}\n\n/**\n * Should we update remote url if it has changed?\n */\nexport function enableUpdateRemoteUrl(): boolean {\n  return true\n}\n\n/**\n * Should we show the fork-specific, \"branch from the upstream\n * default branch\" version of the create branch dialog?\n */\nexport function enableForkyCreateBranchUI(): boolean {\n  return true\n}\n\n/**\n * Should we show the NDDB banner?\n *\n * (It's a notification in the history sidebar that there\n * are new commits upstream.)\n */\nexport function enableNDDBBanner(): boolean {\n  return false\n}\n\n/**\n * Should we show the git tag information in the app UI?\n */\nexport function enableGitTagsDisplay(): boolean {\n  return true\n}\n\n/**\n * Should we allow users to create git tags from the app?\n */\nexport function enableGitTagsCreation(): boolean {\n  return true\n}\n\n/**\n * Should we show the dialogs to allow users customize which is the\n * main repository when opening a fork?\n */\nexport function enableForkSettings(): boolean {\n  return true\n}\n\n/**\n * Should we show the discard lines/hunks context menu item?\n */\nexport function enableDiscardLines(): boolean {\n  return true\n}\n","/** Truncate a single line unicode string by a given maxLength and add ellipsis if necessary */\nexport function truncateWithEllipsis(str: string, maxLength: number) {\n  if (str.length <= maxLength) {\n    return str\n  }\n\n  // String.prototype[@@iterator]() is unicode-aware, using it here to get\n  // correct unicode string length\n  const codePoints = [...str]\n  if (codePoints.length <= maxLength) {\n    return str\n  }\n\n  // combine variation selectors with corresponding characters\n  const characters = codePoints.reduce((characters: Array<string>, code) => {\n    if (code >= '\\uFE00' && code <= '\\uFE0F') {\n      if (characters.length) {\n        characters.push(`${characters.pop()}${code}`)\n      }\n    } else {\n      characters.push(code)\n    }\n    return characters\n  }, [])\n\n  if (characters.length <= maxLength) {\n    return str\n  }\n\n  const result = characters.slice(0, maxLength).join('')\n  return `${result}…`\n}\n","import { Menu, ipcMain, shell, app } from 'electron'\nimport { ensureItemIds } from './ensure-item-ids'\nimport { MenuEvent } from './menu-event'\nimport { truncateWithEllipsis } from '../../lib/truncate-with-ellipsis'\nimport { getLogDirectoryPath } from '../../lib/logging/get-log-path'\nimport { ensureDir } from 'fs-extra'\nimport { openDirectorySafe } from '../shell'\nimport { enableCreateGitHubIssueFromMenu } from '../../lib/feature-flag'\nimport { MenuLabelsEvent } from '../../models/menu-labels'\nimport { DefaultEditorLabel } from '../../ui/lib/context-menu'\n\nconst defaultShellLabel = __DARWIN__\n  ? 'Open in Terminal'\n  : 'Open in Command Prompt'\nconst createPullRequestLabel = __DARWIN__\n  ? 'Create Pull Request'\n  : 'Create &pull request'\nconst showPullRequestLabel = __DARWIN__\n  ? 'Show Pull Request'\n  : 'Show &pull request'\nconst defaultBranchNameValue = __DARWIN__ ? 'Default Branch' : 'default branch'\nconst confirmRepositoryRemovalLabel = __DARWIN__ ? 'Remove…' : '&Remove…'\nconst repositoryRemovalLabel = __DARWIN__ ? 'Remove' : '&Remove'\nconst confirmStashAllChangesLabel = __DARWIN__\n  ? 'Stash All Changes…'\n  : '&Stash all changes…'\nconst stashAllChangesLabel = __DARWIN__\n  ? 'Stash All Changes'\n  : '&Stash all changes'\n\nenum ZoomDirection {\n  Reset,\n  In,\n  Out,\n}\n\nexport function buildDefaultMenu({\n  selectedExternalEditor,\n  selectedShell,\n  askForConfirmationOnForcePush,\n  askForConfirmationOnRepositoryRemoval,\n  hasCurrentPullRequest = false,\n  defaultBranchName = defaultBranchNameValue,\n  isForcePushForCurrentRepository = false,\n  isStashedChangesVisible = false,\n  askForConfirmationWhenStashingAllChanges = true,\n}: MenuLabelsEvent): Electron.Menu {\n  defaultBranchName = truncateWithEllipsis(defaultBranchName, 25)\n\n  const removeRepoLabel = askForConfirmationOnRepositoryRemoval\n    ? confirmRepositoryRemovalLabel\n    : repositoryRemovalLabel\n\n  const pullRequestLabel = hasCurrentPullRequest\n    ? showPullRequestLabel\n    : createPullRequestLabel\n\n  const shellLabel =\n    selectedShell === null ? defaultShellLabel : `Open in ${selectedShell}`\n\n  const editorLabel =\n    selectedExternalEditor === null\n      ? DefaultEditorLabel\n      : `Open in ${selectedExternalEditor}`\n\n  const template = new Array<Electron.MenuItemConstructorOptions>()\n  const separator: Electron.MenuItemConstructorOptions = { type: 'separator' }\n\n  if (__DARWIN__) {\n    template.push({\n      label: 'GitHub Desktop',\n      submenu: [\n        {\n          label: 'About GitHub Desktop',\n          click: emit('show-about'),\n          id: 'about',\n        },\n        separator,\n        {\n          label: 'Preferences…',\n          id: 'preferences',\n          accelerator: 'CmdOrCtrl+,',\n          click: emit('show-preferences'),\n        },\n        separator,\n        {\n          label: 'Install Command Line Tool…',\n          id: 'install-cli',\n          click: emit('install-cli'),\n        },\n        separator,\n        {\n          role: 'services',\n          submenu: [],\n        },\n        separator,\n        { role: 'hide' },\n        { role: 'hideOthers' },\n        { role: 'unhide' },\n        separator,\n        { role: 'quit' },\n      ],\n    })\n  }\n\n  const fileMenu: Electron.MenuItemConstructorOptions = {\n    label: __DARWIN__ ? 'File' : '&File',\n    submenu: [\n      {\n        label: __DARWIN__ ? 'New Repository…' : 'New &repository…',\n        id: 'new-repository',\n        click: emit('create-repository'),\n        accelerator: 'CmdOrCtrl+N',\n      },\n      separator,\n      {\n        label: __DARWIN__ ? 'Add Local Repository…' : 'Add &local repository…',\n        id: 'add-local-repository',\n        accelerator: 'CmdOrCtrl+O',\n        click: emit('add-local-repository'),\n      },\n      {\n        label: __DARWIN__ ? 'Clone Repository…' : 'Clo&ne repository…',\n        id: 'clone-repository',\n        accelerator: 'CmdOrCtrl+Shift+O',\n        click: emit('clone-repository'),\n      },\n    ],\n  }\n\n  if (!__DARWIN__) {\n    const fileItems = fileMenu.submenu as Electron.MenuItemConstructorOptions[]\n\n    fileItems.push(\n      separator,\n      {\n        label: '&Options…',\n        id: 'preferences',\n        accelerator: 'CmdOrCtrl+,',\n        click: emit('show-preferences'),\n      },\n      separator,\n      {\n        role: 'quit',\n        label: 'E&xit',\n        accelerator: 'Alt+F4',\n      }\n    )\n  }\n\n  template.push(fileMenu)\n\n  template.push({\n    label: __DARWIN__ ? 'Edit' : '&Edit',\n    submenu: [\n      { role: 'undo', label: __DARWIN__ ? 'Undo' : '&Undo' },\n      { role: 'redo', label: __DARWIN__ ? 'Redo' : '&Redo' },\n      separator,\n      { role: 'cut', label: __DARWIN__ ? 'Cut' : 'Cu&t' },\n      { role: 'copy', label: __DARWIN__ ? 'Copy' : '&Copy' },\n      { role: 'paste', label: __DARWIN__ ? 'Paste' : '&Paste' },\n      {\n        label: __DARWIN__ ? 'Select All' : 'Select &all',\n        accelerator: 'CmdOrCtrl+A',\n        click: emit('select-all'),\n      },\n      separator,\n      {\n        id: 'find',\n        label: __DARWIN__ ? 'Find' : '&Find',\n        accelerator: 'CmdOrCtrl+F',\n        click: emit('find-text'),\n      },\n    ],\n  })\n\n  template.push({\n    label: __DARWIN__ ? 'View' : '&View',\n    submenu: [\n      {\n        label: __DARWIN__ ? 'Show Changes' : '&Changes',\n        id: 'show-changes',\n        accelerator: 'CmdOrCtrl+1',\n        click: emit('show-changes'),\n      },\n      {\n        label: __DARWIN__ ? 'Show History' : '&History',\n        id: 'show-history',\n        accelerator: 'CmdOrCtrl+2',\n        click: emit('show-history'),\n      },\n      {\n        label: __DARWIN__ ? 'Show Repository List' : 'Repository &list',\n        id: 'show-repository-list',\n        accelerator: 'CmdOrCtrl+T',\n        click: emit('choose-repository'),\n      },\n      {\n        label: __DARWIN__ ? 'Show Branches List' : '&Branches list',\n        id: 'show-branches-list',\n        accelerator: 'CmdOrCtrl+B',\n        click: emit('show-branches'),\n      },\n      separator,\n      {\n        label: __DARWIN__ ? 'Go to Summary' : 'Go to &Summary',\n        id: 'go-to-commit-message',\n        accelerator: 'CmdOrCtrl+G',\n        click: emit('go-to-commit-message'),\n      },\n      {\n        label: getStashedChangesLabel(isStashedChangesVisible),\n        id: 'toggle-stashed-changes',\n        accelerator: 'Ctrl+H',\n        click: isStashedChangesVisible\n          ? emit('hide-stashed-changes')\n          : emit('show-stashed-changes'),\n      },\n      {\n        label: __DARWIN__ ? 'Toggle Full Screen' : 'Toggle &full screen',\n        role: 'togglefullscreen',\n      },\n      separator,\n      {\n        label: __DARWIN__ ? 'Reset Zoom' : 'Reset zoom',\n        accelerator: 'CmdOrCtrl+0',\n        click: zoom(ZoomDirection.Reset),\n      },\n      {\n        label: __DARWIN__ ? 'Zoom In' : 'Zoom in',\n        accelerator: 'CmdOrCtrl+=',\n        click: zoom(ZoomDirection.In),\n      },\n      {\n        label: __DARWIN__ ? 'Zoom Out' : 'Zoom out',\n        accelerator: 'CmdOrCtrl+-',\n        click: zoom(ZoomDirection.Out),\n      },\n      separator,\n      {\n        label: '&Reload',\n        id: 'reload-window',\n        // Ctrl+Alt is interpreted as AltGr on international keyboards and this\n        // can clash with other shortcuts. We should always use Ctrl+Shift for\n        // chorded shortcuts, but this menu item is not a user-facing feature\n        // so we are going to keep this one around.\n        accelerator: 'CmdOrCtrl+Alt+R',\n        click(item: any, focusedWindow: Electron.BrowserWindow) {\n          if (focusedWindow) {\n            focusedWindow.reload()\n          }\n        },\n        visible: __RELEASE_CHANNEL__ === 'development',\n      },\n      {\n        id: 'show-devtools',\n        label: __DARWIN__\n          ? 'Toggle Developer Tools'\n          : '&Toggle developer tools',\n        accelerator: (() => {\n          return __DARWIN__ ? 'Alt+Command+I' : 'Ctrl+Shift+I'\n        })(),\n        click(item: any, focusedWindow: Electron.BrowserWindow) {\n          if (focusedWindow) {\n            focusedWindow.webContents.toggleDevTools()\n          }\n        },\n      },\n    ],\n  })\n\n  const pushLabel = getPushLabel(\n    isForcePushForCurrentRepository,\n    askForConfirmationOnForcePush\n  )\n\n  const pushEventType = isForcePushForCurrentRepository ? 'force-push' : 'push'\n\n  template.push({\n    label: __DARWIN__ ? 'Repository' : '&Repository',\n    id: 'repository',\n    submenu: [\n      {\n        id: 'push',\n        label: pushLabel,\n        accelerator: 'CmdOrCtrl+P',\n        click: emit(pushEventType),\n      },\n      {\n        id: 'pull',\n        label: __DARWIN__ ? 'Pull' : 'Pu&ll',\n        accelerator: 'CmdOrCtrl+Shift+P',\n        click: emit('pull'),\n      },\n      {\n        label: removeRepoLabel,\n        id: 'remove-repository',\n        accelerator: 'CmdOrCtrl+Backspace',\n        click: emit('remove-repository'),\n      },\n      separator,\n      {\n        id: 'view-repository-on-github',\n        label: __DARWIN__ ? 'View on GitHub' : '&View on GitHub',\n        accelerator: 'CmdOrCtrl+Shift+G',\n        click: emit('view-repository-on-github'),\n      },\n      {\n        label: shellLabel,\n        id: 'open-in-shell',\n        accelerator: 'Ctrl+`',\n        click: emit('open-in-shell'),\n      },\n      {\n        label: __DARWIN__\n          ? 'Show in Finder'\n          : __WIN32__\n          ? 'Show in E&xplorer'\n          : 'Show in your File Manager',\n        id: 'open-working-directory',\n        accelerator: 'CmdOrCtrl+Shift+F',\n        click: emit('open-working-directory'),\n      },\n      {\n        label: editorLabel,\n        id: 'open-external-editor',\n        accelerator: 'CmdOrCtrl+Shift+A',\n        click: emit('open-external-editor'),\n      },\n      separator,\n      {\n        id: 'create-issue-in-repository-on-github',\n        label: __DARWIN__\n          ? 'Create Issue on GitHub'\n          : 'Create &issue on GitHub',\n        accelerator: 'CmdOrCtrl+I',\n        click: emit('create-issue-in-repository-on-github'),\n        visible: enableCreateGitHubIssueFromMenu(),\n      },\n      separator,\n      {\n        label: __DARWIN__ ? 'Repository Settings…' : 'Repository &settings…',\n        id: 'show-repository-settings',\n        click: emit('show-repository-settings'),\n      },\n    ],\n  })\n\n  template.push({\n    label: __DARWIN__ ? 'Branch' : '&Branch',\n    id: 'branch',\n    submenu: [\n      {\n        label: __DARWIN__ ? 'New Branch…' : 'New &branch…',\n        id: 'create-branch',\n        accelerator: 'CmdOrCtrl+Shift+N',\n        click: emit('create-branch'),\n      },\n      {\n        label: __DARWIN__ ? 'Rename…' : '&Rename…',\n        id: 'rename-branch',\n        accelerator: 'CmdOrCtrl+Shift+R',\n        click: emit('rename-branch'),\n      },\n      {\n        label: __DARWIN__ ? 'Delete…' : '&Delete…',\n        id: 'delete-branch',\n        accelerator: 'CmdOrCtrl+Shift+D',\n        click: emit('delete-branch'),\n      },\n      separator,\n      {\n        label: __DARWIN__ ? 'Discard All Changes…' : 'Discard all changes…',\n        id: 'discard-all-changes',\n        accelerator: 'CmdOrCtrl+Shift+Backspace',\n        click: emit('discard-all-changes'),\n      },\n      {\n        label: askForConfirmationWhenStashingAllChanges\n          ? confirmStashAllChangesLabel\n          : stashAllChangesLabel,\n        id: 'stash-all-changes',\n        accelerator: 'CmdOrCtrl+Shift+S',\n        click: emit('stash-all-changes'),\n      },\n      separator,\n      {\n        label: __DARWIN__\n          ? `Update from ${defaultBranchName}`\n          : `&Update from ${defaultBranchName}`,\n        id: 'update-branch',\n        accelerator: 'CmdOrCtrl+Shift+U',\n        click: emit('update-branch'),\n      },\n      {\n        label: __DARWIN__ ? 'Compare to Branch' : '&Compare to branch',\n        id: 'compare-to-branch',\n        accelerator: 'CmdOrCtrl+Shift+B',\n        click: emit('compare-to-branch'),\n      },\n      {\n        label: __DARWIN__\n          ? 'Merge into Current Branch…'\n          : '&Merge into current branch…',\n        id: 'merge-branch',\n        accelerator: 'CmdOrCtrl+Shift+M',\n        click: emit('merge-branch'),\n      },\n      {\n        label: __DARWIN__\n          ? 'Rebase Current Branch…'\n          : 'R&ebase current branch…',\n        id: 'rebase-branch',\n        accelerator: 'CmdOrCtrl+Shift+E',\n        click: emit('rebase-branch'),\n      },\n      separator,\n      {\n        label: __DARWIN__ ? 'Compare on GitHub' : 'Compare on &GitHub',\n        id: 'compare-on-github',\n        accelerator: 'CmdOrCtrl+Shift+C',\n        click: emit('compare-on-github'),\n      },\n      {\n        label: pullRequestLabel,\n        id: 'create-pull-request',\n        accelerator: 'CmdOrCtrl+R',\n        click: emit('open-pull-request'),\n      },\n    ],\n  })\n\n  if (__DARWIN__) {\n    template.push({\n      role: 'window',\n      submenu: [\n        { role: 'minimize' },\n        { role: 'zoom' },\n        { role: 'close' },\n        separator,\n        { role: 'front' },\n      ],\n    })\n  }\n\n  const submitIssueItem: Electron.MenuItemConstructorOptions = {\n    label: __DARWIN__ ? 'Report Issue…' : 'Report issue…',\n    click() {\n      shell\n        .openExternal('https://github.com/desktop/desktop/issues/new/choose')\n        .catch(err => log.error('Failed opening issue creation page', err))\n    },\n  }\n\n  const contactSupportItem: Electron.MenuItemConstructorOptions = {\n    label: __DARWIN__ ? 'Contact GitHub Support…' : '&Contact GitHub support…',\n    click() {\n      shell\n        .openExternal(\n          `https://github.com/contact?from_desktop_app=1&app_version=${app.getVersion()}`\n        )\n        .catch(err => log.error('Failed opening contact support page', err))\n    },\n  }\n\n  const showUserGuides: Electron.MenuItemConstructorOptions = {\n    label: 'Show User Guides',\n    click() {\n      shell\n        .openExternal('https://help.github.com/desktop/guides/')\n        .catch(err => log.error('Failed opening user guides page', err))\n    },\n  }\n\n  const showKeyboardShortcuts: Electron.MenuItemConstructorOptions = {\n    label: __DARWIN__ ? 'Show Keyboard Shortcuts' : 'Show keyboard shortcuts',\n    click() {\n      shell\n        .openExternal(\n          'https://help.github.com/en/desktop/getting-started-with-github-desktop/keyboard-shortcuts-in-github-desktop'\n        )\n        .catch(err => log.error('Failed opening keyboard shortcuts page', err))\n    },\n  }\n\n  const showLogsLabel = __DARWIN__\n    ? 'Show Logs in Finder'\n    : __WIN32__\n    ? 'S&how logs in Explorer'\n    : 'S&how logs in your File Manager'\n\n  const showLogsItem: Electron.MenuItemConstructorOptions = {\n    label: showLogsLabel,\n    click() {\n      const logPath = getLogDirectoryPath()\n      ensureDir(logPath)\n        .then(() => {\n          openDirectorySafe(logPath)\n        })\n        .catch(err => {\n          log.error('Failed opening logs directory', err)\n        })\n    },\n  }\n\n  const helpItems = [\n    submitIssueItem,\n    contactSupportItem,\n    showUserGuides,\n    showKeyboardShortcuts,\n    showLogsItem,\n  ]\n\n  if (__DEV__) {\n    helpItems.push(\n      separator,\n      {\n        label: 'Crash main process…',\n        click() {\n          throw new Error('Boomtown!')\n        },\n      },\n      {\n        label: 'Crash renderer process…',\n        click: emit('boomtown'),\n      },\n      {\n        label: 'Show popup',\n        submenu: [\n          {\n            label: 'Release notes',\n            click: emit('show-release-notes-popup'),\n          },\n        ],\n      },\n      {\n        label: 'Prune branches',\n        click: emit('test-prune-branches'),\n      }\n    )\n  }\n\n  if (__DARWIN__) {\n    template.push({\n      role: 'help',\n      submenu: helpItems,\n    })\n  } else {\n    template.push({\n      label: '&Help',\n      submenu: [\n        ...helpItems,\n        separator,\n        {\n          label: '&About GitHub Desktop',\n          click: emit('show-about'),\n          id: 'about',\n        },\n      ],\n    })\n  }\n\n  ensureItemIds(template)\n\n  return Menu.buildFromTemplate(template)\n}\n\nfunction getPushLabel(\n  isForcePushForCurrentRepository: boolean,\n  askForConfirmationOnForcePush: boolean\n): string {\n  if (!isForcePushForCurrentRepository) {\n    return __DARWIN__ ? 'Push' : 'P&ush'\n  }\n\n  if (askForConfirmationOnForcePush) {\n    return __DARWIN__ ? 'Force Push…' : 'Force P&ush…'\n  }\n\n  return __DARWIN__ ? 'Force Push' : 'Force P&ush'\n}\n\nfunction getStashedChangesLabel(isStashedChangesVisible: boolean): string {\n  if (isStashedChangesVisible) {\n    return __DARWIN__ ? 'Hide Stashed Changes' : 'H&ide stashed changes'\n  }\n\n  return __DARWIN__ ? 'Show Stashed Changes' : 'Sho&w stashed changes'\n}\n\ntype ClickHandler = (\n  menuItem: Electron.MenuItem,\n  browserWindow: Electron.BrowserWindow,\n  event: Electron.Event\n) => void\n\n/**\n * Utility function returning a Click event handler which, when invoked, emits\n * the provided menu event over IPC.\n */\nfunction emit(name: MenuEvent): ClickHandler {\n  return (menuItem, window) => {\n    if (window) {\n      window.webContents.send('menu-event', { name })\n    } else {\n      ipcMain.emit('menu-event', { name })\n    }\n  }\n}\n\n/** The zoom steps that we support, these factors must sorted */\nconst ZoomInFactors = [1, 1.1, 1.25, 1.5, 1.75, 2]\nconst ZoomOutFactors = ZoomInFactors.slice().reverse()\n\n/**\n * Returns the element in the array that's closest to the value parameter. Note\n * that this function will throw if passed an empty array.\n */\nfunction findClosestValue(arr: Array<number>, value: number) {\n  return arr.reduce((previous, current) => {\n    return Math.abs(current - value) < Math.abs(previous - value)\n      ? current\n      : previous\n  })\n}\n\n/**\n * Figure out the next zoom level for the given direction and alert the renderer\n * about a change in zoom factor if necessary.\n */\nfunction zoom(direction: ZoomDirection): ClickHandler {\n  return (menuItem, window) => {\n    if (!window) {\n      return\n    }\n\n    const { webContents } = window\n\n    if (direction === ZoomDirection.Reset) {\n      webContents.zoomFactor = 1\n      webContents.send('zoom-factor-changed', 1)\n    } else {\n      const rawZoom = webContents.zoomFactor\n      const zoomFactors =\n        direction === ZoomDirection.In ? ZoomInFactors : ZoomOutFactors\n\n      // So the values that we get from zoomFactor property are floating point\n      // precision numbers from chromium, that don't always round nicely, so\n      // we'll have to do a little trick to figure out which of our supported\n      // zoom factors the value is referring to.\n      const currentZoom = findClosestValue(zoomFactors, rawZoom)\n\n      const nextZoomLevel = zoomFactors.find(f =>\n        direction === ZoomDirection.In ? f > currentZoom : f < currentZoom\n      )\n\n      // If we couldn't find a zoom level (likely due to manual manipulation\n      // of the zoom factor in devtools) we'll just snap to the closest valid\n      // factor we've got.\n      const newZoom = nextZoomLevel === undefined ? currentZoom : nextZoomLevel\n\n      webContents.zoomFactor = newZoom\n      webContents.send('zoom-factor-changed', newZoom)\n    }\n  }\n}\n","'use strict';\n\nconst path = require('path');\nconst electron = require('electron');\nconst jsonfile = require('jsonfile');\nconst mkdirp = require('mkdirp');\n\nmodule.exports = function (options) {\n  const app = electron.app || electron.remote.app;\n  const screen = electron.screen || electron.remote.screen;\n  let state;\n  let winRef;\n  let stateChangeTimer;\n  const eventHandlingDelay = 100;\n  const config = Object.assign({\n    file: 'window-state.json',\n    path: app.getPath('userData'),\n    maximize: true,\n    fullScreen: true\n  }, options);\n  const fullStoreFileName = path.join(config.path, config.file);\n\n  function isNormal(win) {\n    return !win.isMaximized() && !win.isMinimized() && !win.isFullScreen();\n  }\n\n  function hasBounds() {\n    return state &&\n      Number.isInteger(state.x) &&\n      Number.isInteger(state.y) &&\n      Number.isInteger(state.width) && state.width > 0 &&\n      Number.isInteger(state.height) && state.height > 0;\n  }\n\n  function resetStateToDefault() {\n    const displayBounds = screen.getPrimaryDisplay().bounds;\n\n    // Reset state to default values on the primary display\n    state = {\n      width: config.defaultWidth || 800,\n      height: config.defaultHeight || 600,\n      x: 0,\n      y: 0,\n      displayBounds\n    };\n  }\n\n  function windowWithinBounds(bounds) {\n    return (\n      state.x >= bounds.x &&\n      state.y >= bounds.y &&\n      state.x + state.width <= bounds.x + bounds.width &&\n      state.y + state.height <= bounds.y + bounds.height\n    );\n  }\n\n  function ensureWindowVisibleOnSomeDisplay() {\n    const visible = screen.getAllDisplays().some(display => {\n      return windowWithinBounds(display.bounds);\n    });\n\n    if (!visible) {\n      // Window is partially or fully not visible now.\n      // Reset it to safe defaults.\n      return resetStateToDefault();\n    }\n  }\n\n  function validateState() {\n    const isValid = state && (hasBounds() || state.isMaximized || state.isFullScreen);\n    if (!isValid) {\n      state = null;\n      return;\n    }\n\n    if (hasBounds() && state.displayBounds) {\n      ensureWindowVisibleOnSomeDisplay();\n    }\n  }\n\n  function updateState(win) {\n    win = win || winRef;\n    if (!win) {\n      return;\n    }\n    // Don't throw an error when window was closed\n    try {\n      const winBounds = win.getBounds();\n      if (isNormal(win)) {\n        state.x = winBounds.x;\n        state.y = winBounds.y;\n        state.width = winBounds.width;\n        state.height = winBounds.height;\n      }\n      state.isMaximized = win.isMaximized();\n      state.isFullScreen = win.isFullScreen();\n      state.displayBounds = screen.getDisplayMatching(winBounds).bounds;\n    } catch (err) {}\n  }\n\n  function saveState(win) {\n    // Update window state only if it was provided\n    if (win) {\n      updateState(win);\n    }\n\n    // Save state\n    try {\n      mkdirp.sync(path.dirname(fullStoreFileName));\n      jsonfile.writeFileSync(fullStoreFileName, state);\n    } catch (err) {\n      // Don't care\n    }\n  }\n\n  function stateChangeHandler() {\n    // Handles both 'resize' and 'move'\n    clearTimeout(stateChangeTimer);\n    stateChangeTimer = setTimeout(updateState, eventHandlingDelay);\n  }\n\n  function closeHandler() {\n    updateState();\n  }\n\n  function closedHandler() {\n    // Unregister listeners and save state\n    unmanage();\n    saveState();\n  }\n\n  function manage(win) {\n    if (config.maximize && state.isMaximized) {\n      win.maximize();\n    }\n    if (config.fullScreen && state.isFullScreen) {\n      win.setFullScreen(true);\n    }\n    win.on('resize', stateChangeHandler);\n    win.on('move', stateChangeHandler);\n    win.on('close', closeHandler);\n    win.on('closed', closedHandler);\n    winRef = win;\n  }\n\n  function unmanage() {\n    if (winRef) {\n      winRef.removeListener('resize', stateChangeHandler);\n      winRef.removeListener('move', stateChangeHandler);\n      clearTimeout(stateChangeTimer);\n      winRef.removeListener('close', closeHandler);\n      winRef.removeListener('closed', closedHandler);\n      winRef = null;\n    }\n  }\n\n  // Load previous state\n  try {\n    state = jsonfile.readFileSync(fullStoreFileName);\n  } catch (err) {\n    // Don't care\n  }\n\n  // Check state validity\n  validateState();\n\n  // Set state fallback values\n  state = Object.assign({\n    width: config.defaultWidth || 800,\n    height: config.defaultHeight || 600\n  }, state);\n\n  return {\n    get x() { return state.x; },\n    get y() { return state.y; },\n    get width() { return state.width; },\n    get height() { return state.height; },\n    get displayBounds() { return state.displayBounds; },\n    get isMaximized() { return state.isMaximized; },\n    get isFullScreen() { return state.isFullScreen; },\n    saveState,\n    unmanage,\n    manage,\n    resetStateToDefault\n  };\n};\n","import { assertNever } from '../lib/fatal-error'\n\n/** A type union of all possible types of menu items */\nexport type MenuItem =\n  | IMenuItem\n  | ISubmenuItem\n  | ISeparatorMenuItem\n  | ICheckboxMenuItem\n  | IRadioMenuItem\n\n/** A type union of all types of menu items which can be executed */\nexport type ExecutableMenuItem = IMenuItem | ICheckboxMenuItem | IRadioMenuItem\n\n/**\n * Common properties for all item types except separator.\n * Only useful for declaring the types, not for consumption\n */\ninterface IBaseMenuItem {\n  readonly id: string\n  readonly enabled: boolean\n  readonly visible: boolean\n  readonly label: string\n}\n\n/**\n * An interface describing the properties of a 'normal'\n * menu item, i.e. a clickable item with a label but no\n * other special properties.\n */\nexport interface IMenuItem extends IBaseMenuItem {\n  readonly type: 'menuItem'\n  readonly accelerator: string | null\n  readonly accessKey: string | null\n}\n\n/**\n * An interface describing the properties of a\n * submenu menu item, i.e. an item which has an associated\n * submenu which can be expanded to reveal more menu\n * item. Not in itself executable, only a container.\n */\nexport interface ISubmenuItem extends IBaseMenuItem {\n  readonly type: 'submenuItem'\n  readonly menu: IMenu\n  readonly accessKey: string | null\n}\n\n/**\n * An interface describing the properties of a checkbox\n * menu item, i.e. an item which has an associated checked\n * state that can be toggled by executing it.\n */\nexport interface ICheckboxMenuItem extends IBaseMenuItem {\n  readonly type: 'checkbox'\n  readonly accelerator: string | null\n  readonly accessKey: string | null\n  readonly checked: boolean\n}\n\n/**\n * An interface describing the properties of a checkbox\n * menu item, i.e. an item which has an associated checked\n * state that is checked or unchecked based on application logic.\n *\n * The radio menu item is probably going to be used in a collection\n * of more radio menu items where the checked item is assigned\n * based on the last executed item in that group.\n */\nexport interface IRadioMenuItem extends IBaseMenuItem {\n  readonly type: 'radio'\n  readonly accelerator: string | null\n  readonly accessKey: string | null\n  readonly checked: boolean\n}\n\n/**\n * An interface describing the properties of a separator menu\n * item, i.e. an item which sole purpose is to create separation\n * between menu items. It has no other semantics and is purely\n * a visual hint.\n */\nexport interface ISeparatorMenuItem {\n  readonly id: string\n  readonly type: 'separator'\n  readonly visible: boolean\n}\n\n/**\n * An interface describing a menu.\n *\n * Holds collection of menu items and an indication of which item (if any)\n * in the menu is selected.\n */\nexport interface IMenu {\n  /**\n   * The id of this menu. For the root menu this will be undefined. For all\n   * other menus it will be the same as the id of the submenu item which\n   * owns this menu.\n   *\n   * +---------------------------+\n   * | Root menu (id: undefined) |\n   * +---------------------------+  +--------------------------+\n   * |  File (id File)           +--> File menu (id: File)     |\n   * +---------------------------+  +--------------------------+\n   * |  Edit (id Edit)           |  |  Open (id File.Open)     |\n   * +---------------------------+  +--------------------------+\n   *                                |  Close (id File.Close)   |\n   *                                +--------------------------+\n   */\n  readonly id?: string\n\n  /** Type identifier, used for type narrowing */\n  readonly type: 'menu'\n\n  /** A collection of zero or more menu items */\n  readonly items: ReadonlyArray<MenuItem>\n\n  /** The selected item in the menu or undefined if no item is selected */\n  readonly selectedItem?: MenuItem\n}\n\n/**\n * Gets the accelerator for a given menu item. If the menu item doesn't\n * have an explicitly defined accelerator but does have a defined role\n * the default accelerator (if any) for that particular role will be\n * returned.\n */\nfunction getAccelerator(menuItem: Electron.MenuItem): string | null {\n  if (menuItem.accelerator) {\n    return menuItem.accelerator as string\n  }\n\n  if (menuItem.role) {\n    const unsafeItem = menuItem as any\n    // https://github.com/electron/electron/blob/d4a8a64ba/lib/browser/api/menu-item.js#L62\n    const getDefaultRoleAccelerator = unsafeItem.getDefaultRoleAccelerator\n\n    if (typeof getDefaultRoleAccelerator === 'function') {\n      try {\n        const defaultRoleAccelerator = getDefaultRoleAccelerator.call(menuItem)\n        if (typeof defaultRoleAccelerator === 'string') {\n          return defaultRoleAccelerator\n        }\n      } catch (err) {\n        console.error('Could not retrieve default accelerator', err)\n      }\n    }\n  }\n\n  return null\n}\n\n/**\n * Return the access key (applicable on Windows) from a menu item label.\n *\n * An access key is a letter or symbol preceded by an ampersand, i.e. in\n * the string \"Check for &updates\" the access key is 'u'. Access keys are\n * case insensitive and are unique per menu.\n */\nfunction getAccessKey(text: string): string | null {\n  const m = text.match(/&([^&])/)\n  return m ? m[1] : null\n}\n\n/** Workaround for missing type information on Electron.MenuItem.type */\nfunction parseMenuItem(\n  type: string\n): 'normal' | 'separator' | 'submenu' | 'checkbox' | 'radio' {\n  switch (type) {\n    case 'normal':\n    case 'separator':\n    case 'submenu':\n    case 'checkbox':\n    case 'radio':\n      return type\n    default:\n      throw new Error(\n        `Unable to parse string ${type} to a valid menu item type`\n      )\n  }\n}\n\n/**\n * Creates an instance of one of the types in the MenuItem type union based\n * on an Electron MenuItem instance. Will recurse through all sub menus and\n * convert each item.\n */\nfunction menuItemFromElectronMenuItem(menuItem: Electron.MenuItem): MenuItem {\n  // Our menu items always have ids and Electron.MenuItem takes on whatever\n  // properties was defined on the MenuItemOptions template used to create it\n  // but doesn't surface those in the type declaration.\n  const id: string | undefined = (menuItem as any).id\n  if (!id) {\n    throw new Error(`menuItem must specify id: ${menuItem.label}`)\n  }\n  const enabled = menuItem.enabled\n  const visible = menuItem.visible\n  const label = menuItem.label\n  const checked = menuItem.checked\n  const accelerator = getAccelerator(menuItem)\n  const accessKey = getAccessKey(menuItem.label)\n\n  const type = parseMenuItem(menuItem.type)\n\n  // normal, separator, submenu, checkbox or radio.\n  switch (type) {\n    case 'normal':\n      return {\n        id,\n        type: 'menuItem',\n        label,\n        enabled,\n        visible,\n        accelerator,\n        accessKey,\n      }\n    case 'separator':\n      return { id, type: 'separator', visible }\n    case 'submenu':\n      const menu = menuFromElectronMenu(menuItem.submenu as Electron.Menu, id)\n      return {\n        id,\n        type: 'submenuItem',\n        label,\n        enabled,\n        visible,\n        menu,\n        accessKey,\n      }\n    case 'checkbox':\n      return {\n        id,\n        type: 'checkbox',\n        label,\n        enabled,\n        visible,\n        accelerator,\n        checked,\n        accessKey,\n      }\n    case 'radio':\n      return {\n        id,\n        type: 'radio',\n        label,\n        enabled,\n        visible,\n        accelerator,\n        checked,\n        accessKey,\n      }\n    default:\n      return assertNever(type, `Unknown menu item type ${type}`)\n  }\n}\n/**\n * Creates a IMenu instance based on an Electron Menu instance.\n * Will recurse through all sub menus and convert each item using\n * menuItemFromElectronMenuItem.\n *\n * @param menu - The electron menu instance to convert into an\n *               IMenu instance\n *\n * @param id   - The id of the menu. Menus share their id with\n *               their parent item. The root menu id is undefined.\n */\nexport function menuFromElectronMenu(menu: Electron.Menu, id?: string): IMenu {\n  const items = menu.items.map(menuItemFromElectronMenuItem)\n\n  if (__DEV__) {\n    const seenAccessKeys = new Set<string>()\n\n    for (const item of items) {\n      if (item.visible) {\n        if (itemMayHaveAccessKey(item) && item.accessKey) {\n          if (seenAccessKeys.has(item.accessKey.toLowerCase())) {\n            throw new Error(\n              `Duplicate access key '${item.accessKey}' for item ${item.label}`\n            )\n          } else {\n            seenAccessKeys.add(item.accessKey.toLowerCase())\n          }\n        }\n      }\n    }\n  }\n\n  return { id, type: 'menu', items }\n}\n\n/**\n * Creates a map between MenuItem ids and MenuItems by recursing\n * through all items and all submenus.\n */\nfunction buildIdMap(\n  menu: IMenu,\n  map = new Map<string, MenuItem>()\n): Map<string, MenuItem> {\n  for (const item of menu.items) {\n    map.set(item.id, item)\n    if (item.type === 'submenuItem') {\n      buildIdMap(item.menu, map)\n    }\n  }\n\n  return map\n}\n\n/** Type guard which narrows a MenuItem to one which supports access keys */\nexport function itemMayHaveAccessKey(\n  item: MenuItem\n): item is IMenuItem | ISubmenuItem | ICheckboxMenuItem | IRadioMenuItem {\n  return (\n    item.type === 'menuItem' ||\n    item.type === 'submenuItem' ||\n    item.type === 'checkbox' ||\n    item.type === 'radio'\n  )\n}\n\n/**\n * Returns a value indicating whether or not the given menu item can be\n * selected. Selectable items are non-separator items which are enabled\n * and visible.\n */\nexport function itemIsSelectable(item: MenuItem) {\n  return item.type !== 'separator' && item.enabled && item.visible\n}\n\n/**\n * Attempts to locate a menu item matching the provided access key in a\n * given list of items. The access key comparison is case-insensitive.\n *\n * Note that this function does not take into account whether or not the\n * item is selectable, consumers of this function need to perform that\n * check themselves when applicable.\n */\nexport function findItemByAccessKey(\n  accessKey: string,\n  items: ReadonlyArray<MenuItem>\n): IMenuItem | ISubmenuItem | ICheckboxMenuItem | IRadioMenuItem | null {\n  const lowerCaseAccessKey = accessKey.toLowerCase()\n\n  for (const item of items) {\n    if (itemMayHaveAccessKey(item)) {\n      if (\n        item.accessKey &&\n        item.accessKey.toLowerCase() === lowerCaseAccessKey\n      ) {\n        return item\n      }\n    }\n  }\n\n  return null\n}\n\n/**\n * An immutable, transformable object which represents an application menu\n * and its current state (which menus are open, which items are selected).\n *\n * The primary use case for this is for rendering a custom application menu\n * on non-macOS systems. As such some interactions are explicitly made to\n * conform to Windows menu interactions. This includes things like selecting\n * the entire path up until the last selected item. This is necessary since,\n * on Windows, the parent menu item of a menu might not be selected even\n * though the submenu is. This is in order to allow for some delay when\n * moving the cursor from one menu pane to another.\n *\n * In general, however, this object is not platform specific and much of\n * the interactions are defined by the component using it.\n */\nexport class AppMenu {\n  /**\n   * Static constructor for the initial creation of an AppMenu instance\n   * from an IMenu instance.\n   */\n  public static fromMenu(menu: IMenu): AppMenu {\n    const map = buildIdMap(menu)\n    const openMenus = [menu]\n\n    return new AppMenu(menu, openMenus, map)\n  }\n\n  /**\n   * Used by static constructors and transformers.\n   *\n   * @param menu  The menu that this instance operates on, taken from an\n   *              electron Menu instance and converted into an IMenu model\n   *              by menuFromElectronMenu.\n   * @param openMenus A list of currently open menus with their selected items\n   *                  in the application menu.\n   *\n   *                  The semantics around what constitutes an open menu and how\n   *                  selection works is defined within this class class as well as\n   *                  in the individual components transforming that state.\n   * @param menuItemById A map between menu item ids and their corresponding MenuItem.\n   */\n  private constructor(\n    private readonly menu: IMenu,\n    public readonly openMenus: ReadonlyArray<IMenu>,\n    private readonly menuItemById: Map<string, MenuItem>\n  ) {}\n\n  /**\n   * Retrieves a menu item by its id.\n   */\n  public getItemById(id: string): MenuItem | undefined {\n    return this.menuItemById.get(id)\n  }\n\n  /**\n   * Merges the current AppMenu state with a new menu while\n   * attempting to maintain selection state.\n   */\n  public withMenu(newMenu: IMenu): AppMenu {\n    const newMap = buildIdMap(newMenu)\n    const newOpenMenus = new Array<IMenu>()\n\n    // Enumerate all currently open menus and attempt to recreate\n    // the openMenus array with the new menu instances\n    for (const openMenu of this.openMenus) {\n      let newOpenMenu: IMenu\n\n      // No id means it's the root menu, simple enough.\n      if (!openMenu.id) {\n        newOpenMenu = newMenu\n      } else {\n        // Menus share id with their parent item\n        const item = newMap.get(openMenu.id)\n\n        if (item && item.type === 'submenuItem') {\n          newOpenMenu = item.menu\n        } else {\n          // This particular menu can't be found in the new menu\n          // structure, we have no choice but to bail here and\n          // not open this particular menu.\n          break\n        }\n      }\n\n      let newSelectedItem: MenuItem | undefined = undefined\n\n      if (openMenu.selectedItem) {\n        newSelectedItem = newMap.get(openMenu.selectedItem.id)\n      }\n\n      newOpenMenus.push({\n        id: newOpenMenu.id,\n        type: 'menu',\n        items: newOpenMenu.items,\n        selectedItem: newSelectedItem,\n      })\n    }\n\n    return new AppMenu(newMenu, newOpenMenus, newMap)\n  }\n\n  /**\n   * Creates a new copy of this AppMenu instance with the given submenu open.\n   *\n   * @param submenuItem     - The item which submenu should be appended\n   *                          to the list of open menus.\n   *\n   * @param selectFirstItem - A convenience item for automatically selecting\n   *                          the first item in the newly opened menu.\n   *\n   *                          If false the new menu is opened without a selection.\n   *\n   *                          Defaults to false.\n   */\n  public withOpenedMenu(\n    submenuItem: ISubmenuItem,\n    selectFirstItem = false\n  ): AppMenu {\n    const ourMenuItem = this.menuItemById.get(submenuItem.id)\n\n    if (!ourMenuItem) {\n      return this\n    }\n\n    if (ourMenuItem.type !== 'submenuItem') {\n      throw new Error(\n        `Attempt to open a submenu from an item of wrong type: ${\n          ourMenuItem.type\n        }`\n      )\n    }\n\n    const parentMenuIndex = this.openMenus.findIndex(\n      m => m.items.indexOf(ourMenuItem) !== -1\n    )\n\n    // The parent menu has apparently been closed in between, we could go and\n    // recreate it but it's probably not worth it.\n    if (parentMenuIndex === -1) {\n      return this\n    }\n\n    const newOpenMenus = this.openMenus.slice(0, parentMenuIndex + 1)\n\n    if (selectFirstItem) {\n      // First selectable item.\n      const selectedItem = ourMenuItem.menu.items.find(itemIsSelectable)\n      newOpenMenus.push({ ...ourMenuItem.menu, selectedItem })\n    } else {\n      newOpenMenus.push(ourMenuItem.menu)\n    }\n\n    return new AppMenu(this.menu, newOpenMenus, this.menuItemById)\n  }\n\n  /**\n   * Creates a new copy of this AppMenu instance with the given menu removed from\n   * the list of open menus.\n   *\n   * @param menu - The menu which is to be closed, i.e. removed from the\n   *               list of open menus.\n   */\n  public withClosedMenu(menu: IMenu) {\n    // Root menu is always open and can't be closed\n    if (!menu.id) {\n      return this\n    }\n\n    const ourMenuIndex = this.openMenus.findIndex(m => m.id === menu.id)\n\n    if (ourMenuIndex === -1) {\n      return this\n    }\n\n    const newOpenMenus = this.openMenus.slice(0, ourMenuIndex)\n\n    return new AppMenu(this.menu, newOpenMenus, this.menuItemById)\n  }\n\n  /**\n   * Creates a new copy of this AppMenu instance with the list of open menus trimmed\n   * to not include any menus below the given menu.\n   *\n   * @param menu - The last menu which is to remain in the list of open\n   *               menus, all menus below this level will be pruned from\n   *               the list of open menus.\n   */\n  public withLastMenu(menu: IMenu) {\n    const ourMenuIndex = this.openMenus.findIndex(m => m.id === menu.id)\n\n    if (ourMenuIndex === -1) {\n      return this\n    }\n\n    const newOpenMenus = this.openMenus.slice(0, ourMenuIndex + 1)\n\n    return new AppMenu(this.menu, newOpenMenus, this.menuItemById)\n  }\n\n  /**\n   * Creates a new copy of this AppMenu instance in which the given menu item\n   * is selected.\n   *\n   * Additional semantics:\n   *\n   *  All menus leading up to the given menu item will have their\n   *  selection reset in such a fashion that the selection path\n   *  points to the given menu item.\n   *\n   *  All menus after the menu in which the given item resides\n   *  will have their selections cleared.\n   *\n   * @param menuItem - The menu item which is to be selected.\n   */\n  public withSelectedItem(menuItem: MenuItem) {\n    const ourMenuItem = this.menuItemById.get(menuItem.id)\n\n    // The item that someone is trying to select no longer\n    // exists, not much we can do about that.\n    if (!ourMenuItem) {\n      return this\n    }\n\n    const parentMenuIndex = this.openMenus.findIndex(\n      m => m.items.indexOf(ourMenuItem) !== -1\n    )\n\n    // The menu which the selected item belongs to is no longer open,\n    // not much we can do about that.\n    if (parentMenuIndex === -1) {\n      return this\n    }\n\n    const newOpenMenus = this.openMenus.slice()\n\n    const parentMenu = newOpenMenus[parentMenuIndex]\n\n    newOpenMenus[parentMenuIndex] = { ...parentMenu, selectedItem: ourMenuItem }\n\n    // All submenus below the active menu should have their selection cleared\n    for (let i = parentMenuIndex + 1; i < newOpenMenus.length; i++) {\n      newOpenMenus[i] = { ...newOpenMenus[i], selectedItem: undefined }\n    }\n\n    // Ensure that the path that lead us to the currently selected menu is\n    // selected. i.e. all menus above the currently active menu should have\n    // their selection reset to point to the currently active menu.\n    for (let i = parentMenuIndex - 1; i >= 0; i--) {\n      const menu = newOpenMenus[i]\n      const childMenu = newOpenMenus[i + 1]\n\n      const selectedItem = menu.items.find(\n        item => item.type === 'submenuItem' && item.id === childMenu.id\n      )\n\n      newOpenMenus[i] = { ...menu, selectedItem }\n    }\n\n    return new AppMenu(this.menu, newOpenMenus, this.menuItemById)\n  }\n\n  /**\n   * Creates a new copy of this AppMenu instance in which the given menu has had\n   * its selection state cleared.\n   *\n   * Additional semantics:\n   *\n   *  All menus leading up to the given menu item will have their\n   *  selection reset in such a fashion that the selection path\n   *  points to the given menu.\n   *\n   * @param menu - The menu which is to have its selection state\n   *               cleared.\n   */\n  public withDeselectedMenu(menu: IMenu) {\n    const ourMenuIndex = this.openMenus.findIndex(m => m.id === menu.id)\n\n    // The menu that someone is trying to deselect is no longer open\n    // so no need to worry about selection\n    if (ourMenuIndex === -1) {\n      return this\n    }\n\n    const ourMenu = this.openMenus[ourMenuIndex]\n    const newOpenMenus = this.openMenus.slice()\n\n    newOpenMenus[ourMenuIndex] = { ...ourMenu, selectedItem: undefined }\n\n    // Ensure that the path to the menu without an active selection is\n    // selected. i.e. all menus above should have their selection reset\n    // to point to the menu which no longer has an active selection.\n    for (let i = ourMenuIndex - 1; i >= 0; i--) {\n      const menu = newOpenMenus[i]\n      const childMenu = newOpenMenus[i + 1]\n\n      const selectedItem = menu.items.find(\n        item => item.type === 'submenuItem' && item.id === childMenu.id\n      )\n\n      newOpenMenus[i] = { ...menu, selectedItem }\n    }\n\n    return new AppMenu(this.menu, newOpenMenus, this.menuItemById)\n  }\n\n  /**\n   * Creates a new copy of this AppMenu instance in which all state\n   * is reset. Resetting means that only the root menu is open and\n   * all selection state is cleared.\n   */\n  public withReset() {\n    return new AppMenu(this.menu, [this.menu], this.menuItemById)\n  }\n}\n","'use strict';\nconst path = require('path');\n\nmodule.exports = (str, opts) => {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError(`Expected a string, got ${typeof str}`);\n\t}\n\n\topts = Object.assign({resolve: true}, opts);\n\n\tlet pathName = str;\n\n\tif (opts.resolve) {\n\t\tpathName = path.resolve(str);\n\t}\n\n\tpathName = pathName.replace(/\\\\/g, '/');\n\n\t// Windows drive letter must be prefixed with a slash\n\tif (pathName[0] !== '/') {\n\t\tpathName = `/${pathName}`;\n\t}\n\n\t// Escape required characters for path components\n\t// See: https://tools.ietf.org/html/rfc3986#section-3.3\n\treturn encodeURI(`file://${pathName}`).replace(/[?#]/g, encodeURIComponent);\n};\n","import * as Path from 'path'\nimport fileUrl = require('file-url')\n\n/**\n * Resolve and encode the path information into a URL.\n *\n * @param pathSegments array of path segments to resolve\n */\nexport function encodePathAsUrl(...pathSegments: string[]): string {\n  const path = Path.resolve(...pathSegments)\n  return fileUrl(path)\n}\n","(function() {\n  var CompositeDisposable, Disposable, assertDisposable;\n\n  Disposable = null;\n\n  module.exports = CompositeDisposable = (function() {\n    CompositeDisposable.prototype.disposed = false;\n\n\n    /*\n    Section: Construction and Destruction\n     */\n\n    function CompositeDisposable() {\n      var disposable, _i, _len;\n      this.disposables = new Set;\n      for (_i = 0, _len = arguments.length; _i < _len; _i++) {\n        disposable = arguments[_i];\n        this.add(disposable);\n      }\n    }\n\n    CompositeDisposable.prototype.dispose = function() {\n      if (!this.disposed) {\n        this.disposed = true;\n        this.disposables.forEach(function(disposable) {\n          return disposable.dispose();\n        });\n        this.disposables = null;\n      }\n    };\n\n\n    /*\n    Section: Managing Disposables\n     */\n\n    CompositeDisposable.prototype.add = function() {\n      var disposable, _i, _len;\n      if (!this.disposed) {\n        for (_i = 0, _len = arguments.length; _i < _len; _i += 1) {\n          disposable = arguments[_i];\n          assertDisposable(disposable);\n          this.disposables.add(disposable);\n        }\n      }\n    };\n\n    CompositeDisposable.prototype.remove = function(disposable) {\n      if (!this.disposed) {\n        this.disposables[\"delete\"](disposable);\n      }\n    };\n\n    CompositeDisposable.prototype[\"delete\"] = function(disposable) {\n      this.remove(disposable);\n    };\n\n    CompositeDisposable.prototype.clear = function() {\n      if (!this.disposed) {\n        this.disposables.clear();\n      }\n    };\n\n    return CompositeDisposable;\n\n  })();\n\n  assertDisposable = function(disposable) {\n    if (Disposable == null) {\n      Disposable = require('./disposable');\n    }\n    if (!Disposable.isDisposable(disposable)) {\n      throw new TypeError('Arguments to CompositeDisposable.add must have a .dispose() method');\n    }\n  };\n\n}).call(this);\n","(function() {\n  var Disposable, Emitter;\n\n  Disposable = require('./disposable');\n\n  module.exports = Emitter = (function() {\n    Emitter.exceptionHandlers = [];\n\n    Emitter.onEventHandlerException = function(exceptionHandler) {\n      if (this.exceptionHandlers.length === 0) {\n        this.dispatch = this.exceptionHandlingDispatch;\n      }\n      this.exceptionHandlers.push(exceptionHandler);\n      return new Disposable((function(_this) {\n        return function() {\n          _this.exceptionHandlers.splice(_this.exceptionHandlers.indexOf(exceptionHandler), 1);\n          if (_this.exceptionHandlers.length === 0) {\n            return _this.dispatch = _this.simpleDispatch;\n          }\n        };\n      })(this));\n    };\n\n    Emitter.simpleDispatch = function(handler, value) {\n      return handler(value);\n    };\n\n    Emitter.exceptionHandlingDispatch = function(handler, value) {\n      var exception, exceptionHandler, _i, _len, _ref, _results;\n      try {\n        return handler(value);\n      } catch (_error) {\n        exception = _error;\n        _ref = this.exceptionHandlers;\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          exceptionHandler = _ref[_i];\n          _results.push(exceptionHandler(exception));\n        }\n        return _results;\n      }\n    };\n\n    Emitter.dispatch = Emitter.simpleDispatch;\n\n    Emitter.prototype.disposed = false;\n\n\n    /*\n    Section: Construction and Destruction\n     */\n\n    function Emitter() {\n      this.clear();\n    }\n\n    Emitter.prototype.clear = function() {\n      return this.handlersByEventName = {};\n    };\n\n    Emitter.prototype.dispose = function() {\n      this.handlersByEventName = null;\n      return this.disposed = true;\n    };\n\n\n    /*\n    Section: Event Subscription\n     */\n\n    Emitter.prototype.on = function(eventName, handler, unshift) {\n      var currentHandlers;\n      if (unshift == null) {\n        unshift = false;\n      }\n      if (this.disposed) {\n        throw new Error(\"Emitter has been disposed\");\n      }\n      if (typeof handler !== 'function') {\n        throw new Error(\"Handler must be a function\");\n      }\n      if (currentHandlers = this.handlersByEventName[eventName]) {\n        if (unshift) {\n          this.handlersByEventName[eventName] = [handler].concat(currentHandlers);\n        } else {\n          this.handlersByEventName[eventName] = currentHandlers.concat(handler);\n        }\n      } else {\n        this.handlersByEventName[eventName] = [handler];\n      }\n      return new Disposable(this.off.bind(this, eventName, handler));\n    };\n\n    Emitter.prototype.once = function(eventName, handler, unshift) {\n      var disposable, wrapped;\n      if (unshift == null) {\n        unshift = false;\n      }\n      wrapped = function(value) {\n        disposable.dispose();\n        return handler(value);\n      };\n      return disposable = this.on(eventName, wrapped, unshift);\n    };\n\n    Emitter.prototype.preempt = function(eventName, handler) {\n      return this.on(eventName, handler, true);\n    };\n\n    Emitter.prototype.off = function(eventName, handlerToRemove) {\n      var handler, newHandlers, oldHandlers, _i, _len;\n      if (this.disposed) {\n        return;\n      }\n      if (oldHandlers = this.handlersByEventName[eventName]) {\n        newHandlers = [];\n        for (_i = 0, _len = oldHandlers.length; _i < _len; _i++) {\n          handler = oldHandlers[_i];\n          if (handler !== handlerToRemove) {\n            newHandlers.push(handler);\n          }\n        }\n        if (newHandlers.length > 0) {\n          this.handlersByEventName[eventName] = newHandlers;\n        } else {\n          delete this.handlersByEventName[eventName];\n        }\n      }\n    };\n\n\n    /*\n    Section: Event Emission\n     */\n\n    Emitter.prototype.emit = function(eventName, value) {\n      var handler, handlers, _i, _len, _ref;\n      if (handlers = (_ref = this.handlersByEventName) != null ? _ref[eventName] : void 0) {\n        for (_i = 0, _len = handlers.length; _i < _len; _i++) {\n          handler = handlers[_i];\n          this.constructor.dispatch(handler, value);\n        }\n      }\n    };\n\n    Emitter.prototype.emitAsync = function(eventName, value) {\n      var handler, handlers, promises, _ref;\n      if (handlers = (_ref = this.handlersByEventName) != null ? _ref[eventName] : void 0) {\n        promises = (function() {\n          var _i, _len, _results;\n          _results = [];\n          for (_i = 0, _len = handlers.length; _i < _len; _i++) {\n            handler = handlers[_i];\n            _results.push(this.constructor.dispatch(handler, value));\n          }\n          return _results;\n        }).call(this);\n        return Promise.all(promises).then(function() {});\n      }\n      return Promise.resolve();\n    };\n\n    Emitter.prototype.getEventNames = function() {\n      return Object.keys(this.handlersByEventName);\n    };\n\n    Emitter.prototype.listenerCountForEventName = function(eventName) {\n      var _ref, _ref1;\n      return (_ref = (_ref1 = this.handlersByEventName[eventName]) != null ? _ref1.length : void 0) != null ? _ref : 0;\n    };\n\n    Emitter.prototype.getTotalListenerCount = function() {\n      var eventName, result, _i, _len, _ref;\n      result = 0;\n      _ref = Object.keys(this.handlersByEventName);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        eventName = _ref[_i];\n        result += this.handlersByEventName[eventName].length;\n      }\n      return result;\n    };\n\n    return Emitter;\n\n  })();\n\n}).call(this);\n","import { BrowserWindow, ipcMain, Menu, app, dialog } from 'electron'\nimport { Emitter, Disposable } from 'event-kit'\nimport { encodePathAsUrl } from '../lib/path'\nimport { registerWindowStateChangedEvents } from '../lib/window-state'\nimport { MenuEvent } from './menu'\nimport { URLActionType } from '../lib/parse-app-url'\nimport { ILaunchStats } from '../lib/stats'\nimport { menuFromElectronMenu } from '../models/app-menu'\nimport { now } from './now'\nimport * as path from 'path'\nimport * as windowStateKeeper from 'electron-window-state'\n\nexport class AppWindow {\n  private window: Electron.BrowserWindow\n  private emitter = new Emitter()\n\n  private _loadTime: number | null = null\n  private _rendererReadyTime: number | null = null\n\n  private minWidth = 960\n  private minHeight = 660\n\n  public constructor() {\n    const savedWindowState = windowStateKeeper({\n      defaultWidth: this.minWidth,\n      defaultHeight: this.minHeight,\n    })\n\n    const windowOptions: Electron.BrowserWindowConstructorOptions = {\n      x: savedWindowState.x,\n      y: savedWindowState.y,\n      width: savedWindowState.width,\n      height: savedWindowState.height,\n      minWidth: this.minWidth,\n      minHeight: this.minHeight,\n      show: false,\n      // This fixes subpixel aliasing on Windows\n      // See https://github.com/atom/atom/commit/683bef5b9d133cb194b476938c77cc07fd05b972\n      backgroundColor: '#fff',\n      webPreferences: {\n        // Disable auxclick event\n        // See https://developers.google.com/web/updates/2016/10/auxclick\n        disableBlinkFeatures: 'Auxclick',\n        // Enable, among other things, the ResizeObserver\n        experimentalFeatures: true,\n        nodeIntegration: true,\n      },\n      acceptFirstMouse: true,\n    }\n\n    if (__DARWIN__) {\n      windowOptions.titleBarStyle = 'hidden'\n    } else if (__WIN32__) {\n      windowOptions.frame = false\n    } else if (__LINUX__) {\n      windowOptions.icon = path.join(__dirname, 'static', 'icon-logo.png')\n    }\n\n    this.window = new BrowserWindow(windowOptions)\n    savedWindowState.manage(this.window)\n\n    let quitting = false\n    app.on('before-quit', () => {\n      quitting = true\n    })\n\n    ipcMain.on('will-quit', (event: Electron.IpcMainEvent) => {\n      quitting = true\n      event.returnValue = true\n    })\n\n    // on macOS, when the user closes the window we really just hide it. This\n    // lets us activate quickly and keep all our interesting logic in the\n    // renderer.\n    if (__DARWIN__) {\n      this.window.on('close', e => {\n        if (!quitting) {\n          e.preventDefault()\n          Menu.sendActionToFirstResponder('hide:')\n        }\n      })\n    }\n\n    if (__WIN32__) {\n      // workaround for known issue with fullscreen-ing the app and restoring\n      // is that some Chromium API reports the incorrect bounds, so that it\n      // will leave a small space at the top of the screen on every other\n      // maximize\n      //\n      // adapted from https://github.com/electron/electron/issues/12971#issuecomment-403956396\n      //\n      // can be tidied up once https://github.com/electron/electron/issues/12971\n      // has been confirmed as resolved\n      this.window.once('ready-to-show', () => {\n        this.window.on('unmaximize', () => {\n          setTimeout(() => {\n            const bounds = this.window.getBounds()\n            bounds.width += 1\n            this.window.setBounds(bounds)\n            bounds.width -= 1\n            this.window.setBounds(bounds)\n          }, 5)\n        })\n      })\n    }\n  }\n\n  public load() {\n    let startLoad = 0\n    // We only listen for the first of the loading events to avoid a bug in\n    // Electron/Chromium where they can sometimes fire more than once. See\n    // See\n    // https://github.com/desktop/desktop/pull/513#issuecomment-253028277. This\n    // shouldn't really matter as in production builds loading _should_ only\n    // happen once.\n    this.window.webContents.once('did-start-loading', () => {\n      this._rendererReadyTime = null\n      this._loadTime = null\n\n      startLoad = now()\n    })\n\n    this.window.webContents.once('did-finish-load', () => {\n      if (process.env.NODE_ENV === 'development') {\n        this.window.webContents.openDevTools()\n      }\n\n      this._loadTime = now() - startLoad\n\n      this.maybeEmitDidLoad()\n    })\n\n    this.window.webContents.on('did-finish-load', () => {\n      this.window.webContents.setVisualZoomLevelLimits(1, 1)\n    })\n\n    this.window.webContents.on('did-fail-load', () => {\n      this.window.webContents.openDevTools()\n      this.window.show()\n    })\n\n    // TODO: This should be scoped by the window.\n    ipcMain.once(\n      'renderer-ready',\n      (event: Electron.IpcMainEvent, readyTime: number) => {\n        this._rendererReadyTime = readyTime\n\n        this.maybeEmitDidLoad()\n      }\n    )\n\n    this.window.on('focus', () => this.window.webContents.send('focus'))\n    this.window.on('blur', () => this.window.webContents.send('blur'))\n\n    registerWindowStateChangedEvents(this.window)\n    this.window.loadURL(encodePathAsUrl(__dirname, 'index.html'))\n  }\n\n  /**\n   * Emit the `onDidLoad` event if the page has loaded and the renderer has\n   * signalled that it's ready.\n   */\n  private maybeEmitDidLoad() {\n    if (!this.rendererLoaded) {\n      return\n    }\n\n    this.emitter.emit('did-load', null)\n  }\n\n  /** Is the page loaded and has the renderer signalled it's ready? */\n  private get rendererLoaded(): boolean {\n    return !!this.loadTime && !!this.rendererReadyTime\n  }\n\n  public onClose(fn: () => void) {\n    this.window.on('closed', fn)\n  }\n\n  /**\n   * Register a function to call when the window is done loading. At that point\n   * the page has loaded and the renderer has signalled that it is ready.\n   */\n  public onDidLoad(fn: () => void): Disposable {\n    return this.emitter.on('did-load', fn)\n  }\n\n  public isMinimized() {\n    return this.window.isMinimized()\n  }\n\n  /** Is the window currently visible? */\n  public isVisible() {\n    return this.window.isVisible()\n  }\n\n  public restore() {\n    this.window.restore()\n  }\n\n  public focus() {\n    this.window.focus()\n  }\n\n  /** Show the window. */\n  public show() {\n    this.window.show()\n  }\n\n  /** Send the menu event to the renderer. */\n  public sendMenuEvent(name: MenuEvent) {\n    this.show()\n\n    this.window.webContents.send('menu-event', { name })\n  }\n\n  /** Send the URL action to the renderer. */\n  public sendURLAction(action: URLActionType) {\n    this.show()\n\n    this.window.webContents.send('url-action', { action })\n  }\n\n  /** Send the app launch timing stats to the renderer. */\n  public sendLaunchTimingStats(stats: ILaunchStats) {\n    this.window.webContents.send('launch-timing-stats', { stats })\n  }\n\n  /** Send the app menu to the renderer. */\n  public sendAppMenu() {\n    const appMenu = Menu.getApplicationMenu()\n    if (appMenu) {\n      const menu = menuFromElectronMenu(appMenu)\n      this.window.webContents.send('app-menu', { menu })\n    }\n  }\n\n  /** Send a certificate error to the renderer. */\n  public sendCertificateError(\n    certificate: Electron.Certificate,\n    error: string,\n    url: string\n  ) {\n    this.window.webContents.send('certificate-error', {\n      certificate,\n      error,\n      url,\n    })\n  }\n\n  public showCertificateTrustDialog(\n    certificate: Electron.Certificate,\n    message: string\n  ) {\n    // The Electron type definitions don't include `showCertificateTrustDialog`\n    // yet.\n    const d = dialog as any\n    d.showCertificateTrustDialog(\n      this.window,\n      { certificate, message },\n      () => {}\n    )\n  }\n\n  /** Report the exception to the renderer. */\n  public sendException(error: Error) {\n    // `Error` can't be JSONified so it doesn't transport nicely over IPC. So\n    // we'll just manually copy the properties we care about.\n    const friendlyError = {\n      stack: error.stack,\n      message: error.message,\n      name: error.name,\n    }\n    this.window.webContents.send('main-process-exception', friendlyError)\n  }\n\n  /**\n   * Get the time (in milliseconds) spent loading the page.\n   *\n   * This will be `null` until `onDidLoad` is called.\n   */\n  public get loadTime(): number | null {\n    return this._loadTime\n  }\n\n  /**\n   * Get the time (in milliseconds) elapsed from the renderer being loaded to it\n   * signaling it was ready.\n   *\n   * This will be `null` until `onDidLoad` is called.\n   */\n  public get rendererReadyTime(): number | null {\n    return this._rendererReadyTime\n  }\n\n  public destroy() {\n    this.window.destroy()\n  }\n}\n","module.exports = require(\"module\");","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\nvar util = require('./util');\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nvar REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nvar NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nvar isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n\n/**\n * Creates a SourceNode from generated code and a SourceMapConsumer.\n *\n * @param aGeneratedCode The generated code\n * @param aSourceMapConsumer The SourceMap for the generated code\n * @param aRelativePath Optional. The path that relative sources in the\n *        SourceMapConsumer should be relative to.\n */\nSourceNode.fromStringWithSourceMap =\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    var node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    var remainingLinesIndex = 0;\n    var shiftNextLine = function() {\n      var lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      var newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length ?\n            remainingLines[remainingLinesIndex++] : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    var lastMapping = null;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          var nextLine = remainingLines[remainingLinesIndex];\n          var code = nextLine.substr(0, mapping.generatedColumn -\n                                        lastGeneratedColumn);\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\n                                              lastGeneratedColumn);\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        var nextLine = remainingLines[remainingLinesIndex];\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        var source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(new SourceNode(mapping.originalLine,\n                                mapping.originalColumn,\n                                source,\n                                code,\n                                mapping.name));\n      }\n    }\n  };\n\n/**\n * Add a chunk of generated JS to this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Add a chunk of generated JS to the beginning of this source node.\n *\n * @param aChunk A string snippet of generated JS code, another instance of\n *        SourceNode, or an array where each member is one of those things.\n */\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length-1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  }\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  }\n  else {\n    throw new TypeError(\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\n    );\n  }\n  return this;\n};\n\n/**\n * Walk over the tree of JS snippets in this node and its children. The\n * walking function is called once for each snippet of JS and is passed that\n * snippet and the its original associated source's line/column location.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    }\n    else {\n      if (chunk !== '') {\n        aFn(chunk, { source: this.source,\n                     line: this.line,\n                     column: this.column,\n                     name: this.name });\n      }\n    }\n  }\n};\n\n/**\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n * each of `this.children`.\n *\n * @param aSep The separator.\n */\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n  if (len > 0) {\n    newChildren = [];\n    for (i = 0; i < len-1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n  return this;\n};\n\n/**\n * Call String.prototype.replace on the very right-most source snippet. Useful\n * for trimming whitespace from the end of a source node, etc.\n *\n * @param aPattern The pattern to replace.\n * @param aReplacement The thing to replace the pattern with.\n */\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  }\n  else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  }\n  else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n  return this;\n};\n\n/**\n * Set the source content for a source file. This will be added to the SourceMapGenerator\n * in the sourcesContent field.\n *\n * @param aSourceFile The filename of the source file\n * @param aSourceContent The content of the source file\n */\nSourceNode.prototype.setSourceContent =\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  };\n\n/**\n * Walk over the tree of SourceNodes. The walking function is called for each\n * source file content and is passed the filename and source content.\n *\n * @param aFn The traversal function.\n */\nSourceNode.prototype.walkSourceContents =\n  function SourceNode_walkSourceContents(aFn) {\n    for (var i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    var sources = Object.keys(this.sourceContents);\n    for (var i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  };\n\n/**\n * Return the string representation of this source node. Walks over the tree\n * and concatenates all the various snippets together to one string.\n */\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n\n/**\n * Returns the string representation of this source node along with a source\n * map.\n */\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n    if (original.source !== null\n        && original.line !== null\n        && original.column !== null) {\n      if(lastOriginalSource !== original.source\n         || lastOriginalLine !== original.line\n         || lastOriginalColumn !== original.column\n         || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0;\n        // Mappings end at eol\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n\n  return { code: generated.code, map: map };\n};\n\nexports.SourceNode = SourceNode;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  var mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  var cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  }\n  else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    } else {\n      return mid;\n    }\n  }\n  else {\n    // Our needle is less than aHaystack[mid].\n    if (mid - aLow > 1) {\n      // The element is in the lower half.\n      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias == exports.LEAST_UPPER_BOUND) {\n      return mid;\n    } else {\n      return aLow < 0 ? -1 : aLow;\n    }\n  }\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,\n                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element than\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar binarySearch = require('./binary-search');\nvar ArraySet = require('./array-set').ArraySet;\nvar base64VLQ = require('./base64-vlq');\nvar quickSort = require('./quick-sort').quickSort;\n\nfunction SourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  return sourceMap.sections != null\n    ? new IndexedSourceMapConsumer(sourceMap)\n    : new BasicSourceMapConsumer(sourceMap);\n}\n\nSourceMapConsumer.fromSourceMap = function(aSourceMap) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\n\n// `__generatedMappings` and `__originalMappings` are arrays that hold the\n// parsed mapping coordinates from the source map's \"mappings\" attribute. They\n// are lazily instantiated, accessed via the `_generatedMappings` and\n// `_originalMappings` getters respectively, and we only parse the mappings\n// and create these arrays once queried for a source location. We jump through\n// these hoops because there can be many thousands of mappings, and parsing\n// them is expensive, so we only want to do it if we must.\n//\n// Each object in the arrays is of the form:\n//\n//     {\n//       generatedLine: The line number in the generated code,\n//       generatedColumn: The column number in the generated code,\n//       source: The path to the original source file that generated this\n//               chunk of code,\n//       originalLine: The line number in the original source that\n//                     corresponds to this chunk of generated code,\n//       originalColumn: The column number in the original source that\n//                       corresponds to this chunk of generated code,\n//       name: The name of the original symbol which generated this chunk of\n//             code.\n//     }\n//\n// All properties except for `generatedLine` and `generatedColumn` can be\n// `null`.\n//\n// `_generatedMappings` is ordered by the generated positions.\n//\n// `_originalMappings` is ordered by the original positions.\n\nSourceMapConsumer.prototype.__generatedMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n  get: function () {\n    if (!this.__generatedMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__generatedMappings;\n  }\n});\n\nSourceMapConsumer.prototype.__originalMappings = null;\nObject.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n  get: function () {\n    if (!this.__originalMappings) {\n      this._parseMappings(this._mappings, this.sourceRoot);\n    }\n\n    return this.__originalMappings;\n  }\n});\n\nSourceMapConsumer.prototype._charIsMappingSeparator =\n  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {\n    var c = aStr.charAt(index);\n    return c === \";\" || c === \",\";\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    throw new Error(\"Subclasses must implement _parseMappings\");\n  };\n\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\n/**\n * Iterate over each mapping between an original source/line/column and a\n * generated line/column in this source map.\n *\n * @param Function aCallback\n *        The function that is called with each mapping.\n * @param Object aContext\n *        Optional. If specified, this object will be the value of `this` every\n *        time that `aCallback` is called.\n * @param aOrder\n *        Either `SourceMapConsumer.GENERATED_ORDER` or\n *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n *        iterate over the mappings sorted by the generated file's line/column\n *        order or the original's source/line/column order, respectively. Defaults to\n *        `SourceMapConsumer.GENERATED_ORDER`.\n */\nSourceMapConsumer.prototype.eachMapping =\n  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    var mappings;\n    switch (order) {\n    case SourceMapConsumer.GENERATED_ORDER:\n      mappings = this._generatedMappings;\n      break;\n    case SourceMapConsumer.ORIGINAL_ORDER:\n      mappings = this._originalMappings;\n      break;\n    default:\n      throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source === null ? null : this._sources.at(mapping.source);\n      if (source != null && sourceRoot != null) {\n        source = util.join(sourceRoot, source);\n      }\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name === null ? null : this._names.at(mapping.name)\n      };\n    }, this).forEach(aCallback, context);\n  };\n\n/**\n * Returns all generated line and column information for the original source,\n * line, and column provided. If no column is provided, returns all mappings\n * corresponding to a either the line we are searching for or the next\n * closest line that has any mappings. Otherwise, returns all mappings\n * corresponding to the given line and either the column we are searching for\n * or the next closest column that has any offsets.\n *\n * The only argument is an object with the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: Optional. the column number in the original source.\n *\n * and an array of objects is returned, each with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nSourceMapConsumer.prototype.allGeneratedPositionsFor =\n  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    var line = util.getArg(aArgs, 'line');\n\n    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to 0, we thus find the last mapping for\n    // the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: line,\n      originalColumn: util.getArg(aArgs, 'column', 0)\n    };\n\n    if (this.sourceRoot != null) {\n      needle.source = util.relative(this.sourceRoot, needle.source);\n    }\n    if (!this._sources.has(needle.source)) {\n      return [];\n    }\n    needle.source = this._sources.indexOf(needle.source);\n\n    var mappings = [];\n\n    var index = this._findMapping(needle,\n                                  this._originalMappings,\n                                  \"originalLine\",\n                                  \"originalColumn\",\n                                  util.compareByOriginalPositions,\n                                  binarySearch.LEAST_UPPER_BOUND);\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (aArgs.column === undefined) {\n        var originalLine = mapping.originalLine;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we found. Since\n        // mappings are sorted, this is guaranteed to find all mappings for\n        // the line we found.\n        while (mapping && mapping.originalLine === originalLine) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      } else {\n        var originalColumn = mapping.originalColumn;\n\n        // Iterate until either we run out of mappings, or we run into\n        // a mapping for a different line than the one we were searching for.\n        // Since mappings are sorted, this is guaranteed to find all mappings for\n        // the line we are searching for.\n        while (mapping &&\n               mapping.originalLine === line &&\n               mapping.originalColumn == originalColumn) {\n          mappings.push({\n            line: util.getArg(mapping, 'generatedLine', null),\n            column: util.getArg(mapping, 'generatedColumn', null),\n            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n          });\n\n          mapping = this._originalMappings[++index];\n        }\n      }\n    }\n\n    return mappings;\n  };\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The only parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referrenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nfunction BasicSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sources = util.getArg(sourceMap, 'sources');\n  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n  // requires the array) to play nice here.\n  var names = util.getArg(sourceMap, 'names', []);\n  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n  var mappings = util.getArg(sourceMap, 'mappings');\n  var file = util.getArg(sourceMap, 'file', null);\n\n  // Once again, Sass deviates from the spec and supplies the version as a\n  // string rather than a number, so we use loose equality checking here.\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  sources = sources\n    .map(String)\n    // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n    .map(util.normalize)\n    // Always ensure that absolute sources are internally stored relative to\n    // the source root, if the source root is absolute. Not doing this would\n    // be particularly problematic when the source root is a prefix of the\n    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.\n    .map(function (source) {\n      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)\n        ? util.relative(sourceRoot, source)\n        : source;\n    });\n\n  // Pass `true` below to allow duplicate names and sources. While source maps\n  // are intended to be compressed and deduplicated, the TypeScript compiler\n  // sometimes generates source maps with duplicates in them. See Github issue\n  // #72 and bugzil.la/889492.\n  this._names = ArraySet.fromArray(names.map(String), true);\n  this._sources = ArraySet.fromArray(sources, true);\n\n  this.sourceRoot = sourceRoot;\n  this.sourcesContent = sourcesContent;\n  this._mappings = mappings;\n  this.file = file;\n}\n\nBasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\n\n/**\n * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n *\n * @param SourceMapGenerator aSourceMap\n *        The source map that will be consumed.\n * @returns BasicSourceMapConsumer\n */\nBasicSourceMapConsumer.fromSourceMap =\n  function SourceMapConsumer_fromSourceMap(aSourceMap) {\n    var smc = Object.create(BasicSourceMapConsumer.prototype);\n\n    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),\n                                                            smc.sourceRoot);\n    smc.file = aSourceMap._file;\n\n    // Because we are modifying the entries (by converting string sources and\n    // names to indices into the sources and names ArraySets), we have to make\n    // a copy of the entry or else bad things happen. Shared mutable state\n    // strikes again! See github issue #191.\n\n    var generatedMappings = aSourceMap._mappings.toArray().slice();\n    var destGeneratedMappings = smc.__generatedMappings = [];\n    var destOriginalMappings = smc.__originalMappings = [];\n\n    for (var i = 0, length = generatedMappings.length; i < length; i++) {\n      var srcMapping = generatedMappings[i];\n      var destMapping = new Mapping;\n      destMapping.generatedLine = srcMapping.generatedLine;\n      destMapping.generatedColumn = srcMapping.generatedColumn;\n\n      if (srcMapping.source) {\n        destMapping.source = sources.indexOf(srcMapping.source);\n        destMapping.originalLine = srcMapping.originalLine;\n        destMapping.originalColumn = srcMapping.originalColumn;\n\n        if (srcMapping.name) {\n          destMapping.name = names.indexOf(srcMapping.name);\n        }\n\n        destOriginalMappings.push(destMapping);\n      }\n\n      destGeneratedMappings.push(destMapping);\n    }\n\n    quickSort(smc.__originalMappings, util.compareByOriginalPositions);\n\n    return smc;\n  };\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nBasicSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    return this._sources.toArray().map(function (s) {\n      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n    }, this);\n  }\n});\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nBasicSourceMapConsumer.prototype._parseMappings =\n  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var length = aStr.length;\n    var index = 0;\n    var cachedSegments = {};\n    var temp = {};\n    var originalMappings = [];\n    var generatedMappings = [];\n    var mapping, str, segment, end, value;\n\n    while (index < length) {\n      if (aStr.charAt(index) === ';') {\n        generatedLine++;\n        index++;\n        previousGeneratedColumn = 0;\n      }\n      else if (aStr.charAt(index) === ',') {\n        index++;\n      }\n      else {\n        mapping = new Mapping();\n        mapping.generatedLine = generatedLine;\n\n        // Because each offset is encoded relative to the previous one,\n        // many segments often have the same encoding. We can exploit this\n        // fact by caching the parsed variable length fields of each segment,\n        // allowing us to avoid a second parse if we encounter the same\n        // segment again.\n        for (end = index; end < length; end++) {\n          if (this._charIsMappingSeparator(aStr, end)) {\n            break;\n          }\n        }\n        str = aStr.slice(index, end);\n\n        segment = cachedSegments[str];\n        if (segment) {\n          index += str.length;\n        } else {\n          segment = [];\n          while (index < end) {\n            base64VLQ.decode(aStr, index, temp);\n            value = temp.value;\n            index = temp.rest;\n            segment.push(value);\n          }\n\n          if (segment.length === 2) {\n            throw new Error('Found a source, but no line and column');\n          }\n\n          if (segment.length === 3) {\n            throw new Error('Found a source and line, but no column');\n          }\n\n          cachedSegments[str] = segment;\n        }\n\n        // Generated column.\n        mapping.generatedColumn = previousGeneratedColumn + segment[0];\n        previousGeneratedColumn = mapping.generatedColumn;\n\n        if (segment.length > 1) {\n          // Original source.\n          mapping.source = previousSource + segment[1];\n          previousSource += segment[1];\n\n          // Original line.\n          mapping.originalLine = previousOriginalLine + segment[2];\n          previousOriginalLine = mapping.originalLine;\n          // Lines are stored 0-based\n          mapping.originalLine += 1;\n\n          // Original column.\n          mapping.originalColumn = previousOriginalColumn + segment[3];\n          previousOriginalColumn = mapping.originalColumn;\n\n          if (segment.length > 4) {\n            // Original name.\n            mapping.name = previousName + segment[4];\n            previousName += segment[4];\n          }\n        }\n\n        generatedMappings.push(mapping);\n        if (typeof mapping.originalLine === 'number') {\n          originalMappings.push(mapping);\n        }\n      }\n    }\n\n    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);\n    this.__generatedMappings = generatedMappings;\n\n    quickSort(originalMappings, util.compareByOriginalPositions);\n    this.__originalMappings = originalMappings;\n  };\n\n/**\n * Find the mapping that best matches the hypothetical \"needle\" mapping that\n * we are searching for in the given \"haystack\" of mappings.\n */\nBasicSourceMapConsumer.prototype._findMapping =\n  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,\n                                         aColumnName, aComparator, aBias) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got '\n                          + aNeedle[aLineName]);\n    }\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got '\n                          + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);\n  };\n\n/**\n * Compute the last column for each generated mapping. The last column is\n * inclusive.\n */\nBasicSourceMapConsumer.prototype.computeColumnSpans =\n  function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index];\n\n      // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      }\n\n      // The last mapping for each line spans the entire line.\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nBasicSourceMapConsumer.prototype.originalPositionFor =\n  function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._generatedMappings,\n      \"generatedLine\",\n      \"generatedColumn\",\n      util.compareByGeneratedPositionsDeflated,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n        if (source !== null) {\n          source = this._sources.at(source);\n          if (this.sourceRoot != null) {\n            source = util.join(this.sourceRoot, source);\n          }\n        }\n        var name = util.getArg(mapping, 'name', null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: name\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nBasicSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function BasicSourceMapConsumer_hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) { return sc == null; });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nBasicSourceMapConsumer.prototype.sourceContentFor =\n  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    if (this.sourceRoot != null) {\n      aSource = util.relative(this.sourceRoot, aSource);\n    }\n\n    if (this._sources.has(aSource)) {\n      return this.sourcesContent[this._sources.indexOf(aSource)];\n    }\n\n    var url;\n    if (this.sourceRoot != null\n        && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n      if (url.scheme == \"file\"\n          && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]\n      }\n\n      if ((!url.path || url.path == \"/\")\n          && this._sources.has(\"/\" + aSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n      }\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nBasicSourceMapConsumer.prototype.generatedPositionFor =\n  function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var source = util.getArg(aArgs, 'source');\n    if (this.sourceRoot != null) {\n      source = util.relative(this.sourceRoot, source);\n    }\n    if (!this._sources.has(source)) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null\n      };\n    }\n    source = this._sources.indexOf(source);\n\n    var needle = {\n      source: source,\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(\n      needle,\n      this._originalMappings,\n      \"originalLine\",\n      \"originalColumn\",\n      util.compareByOriginalPositions,\n      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)\n    );\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      if (mapping.source === needle.source) {\n        return {\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The only parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nfunction IndexedSourceMapConsumer(aSourceMap) {\n  var sourceMap = aSourceMap;\n  if (typeof aSourceMap === 'string') {\n    sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n  }\n\n  var version = util.getArg(sourceMap, 'version');\n  var sections = util.getArg(sourceMap, 'sections');\n\n  if (version != this._version) {\n    throw new Error('Unsupported version: ' + version);\n  }\n\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n\n  var lastOffset = {\n    line: -1,\n    column: 0\n  };\n  this._sections = sections.map(function (s) {\n    if (s.url) {\n      // The url field will require support for asynchronicity.\n      // See https://github.com/mozilla/source-map/issues/16\n      throw new Error('Support for url field in sections not implemented.');\n    }\n    var offset = util.getArg(s, 'offset');\n    var offsetLine = util.getArg(offset, 'line');\n    var offsetColumn = util.getArg(offset, 'column');\n\n    if (offsetLine < lastOffset.line ||\n        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {\n      throw new Error('Section offsets must be ordered and non-overlapping.');\n    }\n    lastOffset = offset;\n\n    return {\n      generatedOffset: {\n        // The offset fields are 0-based, but we use 1-based indices when\n        // encoding/decoding from VLQ.\n        generatedLine: offsetLine + 1,\n        generatedColumn: offsetColumn + 1\n      },\n      consumer: new SourceMapConsumer(util.getArg(s, 'map'))\n    }\n  });\n}\n\nIndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);\nIndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nIndexedSourceMapConsumer.prototype._version = 3;\n\n/**\n * The list of original sources.\n */\nObject.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {\n  get: function () {\n    var sources = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n});\n\n/**\n * Returns the original source, line, and column information for the generated\n * source's line and column positions provided. The only argument is an object\n * with the following properties:\n *\n *   - line: The line number in the generated source.\n *   - column: The column number in the generated source.\n *\n * and an object is returned with the following properties:\n *\n *   - source: The original source file, or null.\n *   - line: The line number in the original source, or null.\n *   - column: The column number in the original source, or null.\n *   - name: The original identifier, or null.\n */\nIndexedSourceMapConsumer.prototype.originalPositionFor =\n  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    var sectionIndex = binarySearch.search(needle, this._sections,\n      function(needle, section) {\n        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        return (needle.generatedColumn -\n                section.generatedOffset.generatedColumn);\n      });\n    var section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine -\n        (section.generatedOffset.generatedLine - 1),\n      column: needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n         ? section.generatedOffset.generatedColumn - 1\n         : 0),\n      bias: aArgs.bias\n    });\n  };\n\n/**\n * Return true if we have the source content for every source in the source\n * map, false otherwise.\n */\nIndexedSourceMapConsumer.prototype.hasContentsOfAllSources =\n  function IndexedSourceMapConsumer_hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  };\n\n/**\n * Returns the original source content. The only argument is the url of the\n * original source file. Returns null if no original source content is\n * available.\n */\nIndexedSourceMapConsumer.prototype.sourceContentFor =\n  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      var content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    else {\n      throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n    }\n  };\n\n/**\n * Returns the generated line and column information for the original source,\n * line, and column positions provided. The only argument is an object with\n * the following properties:\n *\n *   - source: The filename of the original source.\n *   - line: The line number in the original source.\n *   - column: The column number in the original source.\n *\n * and an object is returned with the following properties:\n *\n *   - line: The line number in the generated source, or null.\n *   - column: The column number in the generated source, or null.\n */\nIndexedSourceMapConsumer.prototype.generatedPositionFor =\n  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n\n      // Only consider this section if the requested source is in the list of\n      // sources of the consumer.\n      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {\n        continue;\n      }\n      var generatedPosition = section.consumer.generatedPositionFor(aArgs);\n      if (generatedPosition) {\n        var ret = {\n          line: generatedPosition.line +\n            (section.generatedOffset.generatedLine - 1),\n          column: generatedPosition.column +\n            (section.generatedOffset.generatedLine === generatedPosition.line\n             ? section.generatedOffset.generatedColumn - 1\n             : 0)\n        };\n        return ret;\n      }\n    }\n\n    return {\n      line: null,\n      column: null\n    };\n  };\n\n/**\n * Parse the mappings in a string in to a data structure which we can easily\n * query (the ordered arrays in the `this.__generatedMappings` and\n * `this.__originalMappings` properties).\n */\nIndexedSourceMapConsumer.prototype._parseMappings =\n  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    this.__generatedMappings = [];\n    this.__originalMappings = [];\n    for (var i = 0; i < this._sections.length; i++) {\n      var section = this._sections[i];\n      var sectionMappings = section.consumer._generatedMappings;\n      for (var j = 0; j < sectionMappings.length; j++) {\n        var mapping = sectionMappings[j];\n\n        var source = section.consumer._sources.at(mapping.source);\n        if (section.consumer.sourceRoot !== null) {\n          source = util.join(section.consumer.sourceRoot, source);\n        }\n        this._sources.add(source);\n        source = this._sources.indexOf(source);\n\n        var name = section.consumer._names.at(mapping.name);\n        this._names.add(name);\n        name = this._names.indexOf(name);\n\n        // The mappings coming from the consumer for the section have\n        // generated positions relative to the start of the section, so we\n        // need to offset them to be relative to the start of the concatenated\n        // generated file.\n        var adjustedMapping = {\n          source: source,\n          generatedLine: mapping.generatedLine +\n            (section.generatedOffset.generatedLine - 1),\n          generatedColumn: mapping.generatedColumn +\n            (section.generatedOffset.generatedLine === mapping.generatedLine\n            ? section.generatedOffset.generatedColumn - 1\n            : 0),\n          originalLine: mapping.originalLine,\n          originalColumn: mapping.originalColumn,\n          name: name\n        };\n\n        this.__generatedMappings.push(adjustedMapping);\n        if (typeof adjustedMapping.originalLine === 'number') {\n          this.__originalMappings.push(adjustedMapping);\n        }\n      }\n    }\n\n    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);\n    quickSort(this.__originalMappings, util.compareByOriginalPositions);\n  };\n\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE.txt or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;\nexports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;\nexports.SourceNode = require('./lib/source-node').SourceNode;\n","var SourceMapConsumer = require('source-map').SourceMapConsumer;\nvar path = require('path');\n\nvar fs;\ntry {\n  fs = require('fs');\n  if (!fs.existsSync || !fs.readFileSync) {\n    // fs doesn't have all methods we need\n    fs = null;\n  }\n} catch (err) {\n  /* nop */\n}\n\n// Only install once if called multiple times\nvar errorFormatterInstalled = false;\nvar uncaughtShimInstalled = false;\n\n// If true, the caches are reset before a stack trace formatting operation\nvar emptyCacheBetweenOperations = false;\n\n// Supports {browser, node, auto}\nvar environment = \"auto\";\n\n// Maps a file path to a string containing the file contents\nvar fileContentsCache = {};\n\n// Maps a file path to a source map for that file\nvar sourceMapCache = {};\n\n// Regex for detecting source maps\nvar reSourceMap = /^data:application\\/json[^,]+base64,/;\n\n// Priority list of retrieve handlers\nvar retrieveFileHandlers = [];\nvar retrieveMapHandlers = [];\n\nfunction isInBrowser() {\n  if (environment === \"browser\")\n    return true;\n  if (environment === \"node\")\n    return false;\n  return ((typeof window !== 'undefined') && (typeof XMLHttpRequest === 'function') && !(window.require && window.module && window.process && window.process.type === \"renderer\"));\n}\n\nfunction hasGlobalProcessEventEmitter() {\n  return ((typeof process === 'object') && (process !== null) && (typeof process.on === 'function'));\n}\n\nfunction handlerExec(list) {\n  return function(arg) {\n    for (var i = 0; i < list.length; i++) {\n      var ret = list[i](arg);\n      if (ret) {\n        return ret;\n      }\n    }\n    return null;\n  };\n}\n\nvar retrieveFile = handlerExec(retrieveFileHandlers);\n\nretrieveFileHandlers.push(function(path) {\n  // Trim the path to make sure there is no extra whitespace.\n  path = path.trim();\n  if (path in fileContentsCache) {\n    return fileContentsCache[path];\n  }\n\n  var contents = null;\n  if (!fs) {\n    // Use SJAX if we are in the browser\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', path, false);\n    xhr.send(null);\n    var contents = null\n    if (xhr.readyState === 4 && xhr.status === 200) {\n      contents = xhr.responseText\n    }\n  } else if (fs.existsSync(path)) {\n    // Otherwise, use the filesystem\n    try {\n      contents = fs.readFileSync(path, 'utf8');\n    } catch (er) {\n      contents = '';\n    }\n  }\n\n  return fileContentsCache[path] = contents;\n});\n\n// Support URLs relative to a directory, but be careful about a protocol prefix\n// in case we are in the browser (i.e. directories may start with \"http://\")\nfunction supportRelativeURL(file, url) {\n  if (!file) return url;\n  var dir = path.dirname(file);\n  var match = /^\\w+:\\/\\/[^\\/]*/.exec(dir);\n  var protocol = match ? match[0] : '';\n  return protocol + path.resolve(dir.slice(protocol.length), url);\n}\n\nfunction retrieveSourceMapURL(source) {\n  var fileData;\n\n  if (isInBrowser()) {\n     try {\n       var xhr = new XMLHttpRequest();\n       xhr.open('GET', source, false);\n       xhr.send(null);\n       fileData = xhr.readyState === 4 ? xhr.responseText : null;\n\n       // Support providing a sourceMappingURL via the SourceMap header\n       var sourceMapHeader = xhr.getResponseHeader(\"SourceMap\") ||\n                             xhr.getResponseHeader(\"X-SourceMap\");\n       if (sourceMapHeader) {\n         return sourceMapHeader;\n       }\n     } catch (e) {\n     }\n  }\n\n  // Get the URL of the source map\n  fileData = retrieveFile(source);\n  var re = /(?:\\/\\/[@#][ \\t]+sourceMappingURL=([^\\s'\"]+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/)[ \\t]*$)/mg;\n  // Keep executing the search to find the *last* sourceMappingURL to avoid\n  // picking up sourceMappingURLs from comments, strings, etc.\n  var lastMatch, match;\n  while (match = re.exec(fileData)) lastMatch = match;\n  if (!lastMatch) return null;\n  return lastMatch[1];\n};\n\n// Can be overridden by the retrieveSourceMap option to install. Takes a\n// generated source filename; returns a {map, optional url} object, or null if\n// there is no source map.  The map field may be either a string or the parsed\n// JSON object (ie, it must be a valid argument to the SourceMapConsumer\n// constructor).\nvar retrieveSourceMap = handlerExec(retrieveMapHandlers);\nretrieveMapHandlers.push(function(source) {\n  var sourceMappingURL = retrieveSourceMapURL(source);\n  if (!sourceMappingURL) return null;\n\n  // Read the contents of the source map\n  var sourceMapData;\n  if (reSourceMap.test(sourceMappingURL)) {\n    // Support source map URL as a data url\n    var rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(',') + 1);\n    sourceMapData = new Buffer(rawData, \"base64\").toString();\n    sourceMappingURL = source;\n  } else {\n    // Support source map URLs relative to the source URL\n    sourceMappingURL = supportRelativeURL(source, sourceMappingURL);\n    sourceMapData = retrieveFile(sourceMappingURL);\n  }\n\n  if (!sourceMapData) {\n    return null;\n  }\n\n  return {\n    url: sourceMappingURL,\n    map: sourceMapData\n  };\n});\n\nfunction mapSourcePosition(position) {\n  var sourceMap = sourceMapCache[position.source];\n  if (!sourceMap) {\n    // Call the (overrideable) retrieveSourceMap function to get the source map.\n    var urlAndMap = retrieveSourceMap(position.source);\n    if (urlAndMap) {\n      sourceMap = sourceMapCache[position.source] = {\n        url: urlAndMap.url,\n        map: new SourceMapConsumer(urlAndMap.map)\n      };\n\n      // Load all sources stored inline with the source map into the file cache\n      // to pretend like they are already loaded. They may not exist on disk.\n      if (sourceMap.map.sourcesContent) {\n        sourceMap.map.sources.forEach(function(source, i) {\n          var contents = sourceMap.map.sourcesContent[i];\n          if (contents) {\n            var url = supportRelativeURL(sourceMap.url, source);\n            fileContentsCache[url] = contents;\n          }\n        });\n      }\n    } else {\n      sourceMap = sourceMapCache[position.source] = {\n        url: null,\n        map: null\n      };\n    }\n  }\n\n  // Resolve the source URL relative to the URL of the source map\n  if (sourceMap && sourceMap.map) {\n    var originalPosition = sourceMap.map.originalPositionFor(position);\n\n    // Only return the original position if a matching line was found. If no\n    // matching line is found then we return position instead, which will cause\n    // the stack trace to print the path and line for the compiled file. It is\n    // better to give a precise location in the compiled file than a vague\n    // location in the original file.\n    if (originalPosition.source !== null) {\n      originalPosition.source = supportRelativeURL(\n        sourceMap.url, originalPosition.source);\n      return originalPosition;\n    }\n  }\n\n  return position;\n}\n\n// Parses code generated by FormatEvalOrigin(), a function inside V8:\n// https://code.google.com/p/v8/source/browse/trunk/src/messages.js\nfunction mapEvalOrigin(origin) {\n  // Most eval() calls are in this format\n  var match = /^eval at ([^(]+) \\((.+):(\\d+):(\\d+)\\)$/.exec(origin);\n  if (match) {\n    var position = mapSourcePosition({\n      source: match[2],\n      line: +match[3],\n      column: match[4] - 1\n    });\n    return 'eval at ' + match[1] + ' (' + position.source + ':' +\n      position.line + ':' + (position.column + 1) + ')';\n  }\n\n  // Parse nested eval() calls using recursion\n  match = /^eval at ([^(]+) \\((.+)\\)$/.exec(origin);\n  if (match) {\n    return 'eval at ' + match[1] + ' (' + mapEvalOrigin(match[2]) + ')';\n  }\n\n  // Make sure we still return useful information if we didn't find anything\n  return origin;\n}\n\n// This is copied almost verbatim from the V8 source code at\n// https://code.google.com/p/v8/source/browse/trunk/src/messages.js. The\n// implementation of wrapCallSite() used to just forward to the actual source\n// code of CallSite.prototype.toString but unfortunately a new release of V8\n// did something to the prototype chain and broke the shim. The only fix I\n// could find was copy/paste.\nfunction CallSiteToString() {\n  var fileName;\n  var fileLocation = \"\";\n  if (this.isNative()) {\n    fileLocation = \"native\";\n  } else {\n    fileName = this.getScriptNameOrSourceURL();\n    if (!fileName && this.isEval()) {\n      fileLocation = this.getEvalOrigin();\n      fileLocation += \", \";  // Expecting source position to follow.\n    }\n\n    if (fileName) {\n      fileLocation += fileName;\n    } else {\n      // Source code does not originate from a file and is not native, but we\n      // can still get the source position inside the source string, e.g. in\n      // an eval string.\n      fileLocation += \"<anonymous>\";\n    }\n    var lineNumber = this.getLineNumber();\n    if (lineNumber != null) {\n      fileLocation += \":\" + lineNumber;\n      var columnNumber = this.getColumnNumber();\n      if (columnNumber) {\n        fileLocation += \":\" + columnNumber;\n      }\n    }\n  }\n\n  var line = \"\";\n  var functionName = this.getFunctionName();\n  var addSuffix = true;\n  var isConstructor = this.isConstructor();\n  var isMethodCall = !(this.isToplevel() || isConstructor);\n  if (isMethodCall) {\n    var typeName = this.getTypeName();\n    // Fixes shim to be backward compatable with Node v0 to v4\n    if (typeName === \"[object Object]\") {\n      typeName = \"null\";\n    }\n    var methodName = this.getMethodName();\n    if (functionName) {\n      if (typeName && functionName.indexOf(typeName) != 0) {\n        line += typeName + \".\";\n      }\n      line += functionName;\n      if (methodName && functionName.indexOf(\".\" + methodName) != functionName.length - methodName.length - 1) {\n        line += \" [as \" + methodName + \"]\";\n      }\n    } else {\n      line += typeName + \".\" + (methodName || \"<anonymous>\");\n    }\n  } else if (isConstructor) {\n    line += \"new \" + (functionName || \"<anonymous>\");\n  } else if (functionName) {\n    line += functionName;\n  } else {\n    line += fileLocation;\n    addSuffix = false;\n  }\n  if (addSuffix) {\n    line += \" (\" + fileLocation + \")\";\n  }\n  return line;\n}\n\nfunction cloneCallSite(frame) {\n  var object = {};\n  Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach(function(name) {\n    object[name] = /^(?:is|get)/.test(name) ? function() { return frame[name].call(frame); } : frame[name];\n  });\n  object.toString = CallSiteToString;\n  return object;\n}\n\nfunction wrapCallSite(frame) {\n  if(frame.isNative()) {\n    return frame;\n  }\n\n  // Most call sites will return the source file from getFileName(), but code\n  // passed to eval() ending in \"//# sourceURL=...\" will return the source file\n  // from getScriptNameOrSourceURL() instead\n  var source = frame.getFileName() || frame.getScriptNameOrSourceURL();\n  if (source) {\n    var line = frame.getLineNumber();\n    var column = frame.getColumnNumber() - 1;\n\n    // Fix position in Node where some (internal) code is prepended.\n    // See https://github.com/evanw/node-source-map-support/issues/36\n    var headerLength = 62;\n    if (line === 1 && column > headerLength && !isInBrowser() && !frame.isEval()) {\n      column -= headerLength;\n    }\n\n    var position = mapSourcePosition({\n      source: source,\n      line: line,\n      column: column\n    });\n    frame = cloneCallSite(frame);\n    frame.getFileName = function() { return position.source; };\n    frame.getLineNumber = function() { return position.line; };\n    frame.getColumnNumber = function() { return position.column + 1; };\n    frame.getScriptNameOrSourceURL = function() { return position.source; };\n    return frame;\n  }\n\n  // Code called using eval() needs special handling\n  var origin = frame.isEval() && frame.getEvalOrigin();\n  if (origin) {\n    origin = mapEvalOrigin(origin);\n    frame = cloneCallSite(frame);\n    frame.getEvalOrigin = function() { return origin; };\n    return frame;\n  }\n\n  // If we get here then we were unable to change the source position\n  return frame;\n}\n\n// This function is part of the V8 stack trace API, for more info see:\n// http://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\nfunction prepareStackTrace(error, stack) {\n  if (emptyCacheBetweenOperations) {\n    fileContentsCache = {};\n    sourceMapCache = {};\n  }\n\n  return error + stack.map(function(frame) {\n    return '\\n    at ' + wrapCallSite(frame);\n  }).join('');\n}\n\n// Generate position and snippet of original source with pointer\nfunction getErrorSource(error) {\n  var match = /\\n    at [^(]+ \\((.*):(\\d+):(\\d+)\\)/.exec(error.stack);\n  if (match) {\n    var source = match[1];\n    var line = +match[2];\n    var column = +match[3];\n\n    // Support the inline sourceContents inside the source map\n    var contents = fileContentsCache[source];\n\n    // Support files on disk\n    if (!contents && fs && fs.existsSync(source)) {\n      try {\n        contents = fs.readFileSync(source, 'utf8');\n      } catch (er) {\n        contents = '';\n      }\n    }\n\n    // Format the line from the original source code like node does\n    if (contents) {\n      var code = contents.split(/(?:\\r\\n|\\r|\\n)/)[line - 1];\n      if (code) {\n        return source + ':' + line + '\\n' + code + '\\n' +\n          new Array(column).join(' ') + '^';\n      }\n    }\n  }\n  return null;\n}\n\nfunction printErrorAndExit (error) {\n  var source = getErrorSource(error);\n\n  if (source) {\n    console.error();\n    console.error(source);\n  }\n\n  console.error(error.stack);\n  process.exit(1);\n}\n\nfunction shimEmitUncaughtException () {\n  var origEmit = process.emit;\n\n  process.emit = function (type) {\n    if (type === 'uncaughtException') {\n      var hasStack = (arguments[1] && arguments[1].stack);\n      var hasListeners = (this.listeners(type).length > 0);\n\n      if (hasStack && !hasListeners) {\n        return printErrorAndExit(arguments[1]);\n      }\n    }\n\n    return origEmit.apply(this, arguments);\n  };\n}\n\nexports.wrapCallSite = wrapCallSite;\nexports.getErrorSource = getErrorSource;\nexports.mapSourcePosition = mapSourcePosition;\nexports.retrieveSourceMap = retrieveSourceMap;\n\nexports.install = function(options) {\n  options = options || {};\n\n  if (options.environment) {\n    environment = options.environment;\n    if ([\"node\", \"browser\", \"auto\"].indexOf(environment) === -1) {\n      throw new Error(\"environment \" + environment + \" was unknown. Available options are {auto, browser, node}\")\n    }\n  }\n\n  // Allow sources to be found by methods other than reading the files\n  // directly from disk.\n  if (options.retrieveFile) {\n    if (options.overrideRetrieveFile) {\n      retrieveFileHandlers.length = 0;\n    }\n\n    retrieveFileHandlers.unshift(options.retrieveFile);\n  }\n\n  // Allow source maps to be found by methods other than reading the files\n  // directly from disk.\n  if (options.retrieveSourceMap) {\n    if (options.overrideRetrieveSourceMap) {\n      retrieveMapHandlers.length = 0;\n    }\n\n    retrieveMapHandlers.unshift(options.retrieveSourceMap);\n  }\n\n  // Support runtime transpilers that include inline source maps\n  if (options.hookRequire && !isInBrowser()) {\n    var Module;\n    try {\n      Module = require('module');\n    } catch (err) {\n      // NOP: Loading in catch block to convert webpack error to warning.\n    }\n    var $compile = Module.prototype._compile;\n\n    if (!$compile.__sourceMapSupport) {\n      Module.prototype._compile = function(content, filename) {\n        fileContentsCache[filename] = content;\n        sourceMapCache[filename] = undefined;\n        return $compile.call(this, content, filename);\n      };\n\n      Module.prototype._compile.__sourceMapSupport = true;\n    }\n  }\n\n  // Configure options\n  if (!emptyCacheBetweenOperations) {\n    emptyCacheBetweenOperations = 'emptyCacheBetweenOperations' in options ?\n      options.emptyCacheBetweenOperations : false;\n  }\n\n  // Install the error reformatter\n  if (!errorFormatterInstalled) {\n    errorFormatterInstalled = true;\n    Error.prepareStackTrace = prepareStackTrace;\n  }\n\n  if (!uncaughtShimInstalled) {\n    var installHandler = 'handleUncaughtExceptions' in options ?\n      options.handleUncaughtExceptions : true;\n\n    // Provide the option to not install the uncaught exception handler. This is\n    // to support other uncaught exception handlers (in test frameworks, for\n    // example). If this handler is not installed and there are no other uncaught\n    // exception handlers, uncaught exceptions will be caught by node's built-in\n    // exception handler and the process will still be terminated. However, the\n    // generated JavaScript code will be shown above the stack trace instead of\n    // the original source code.\n    if (installHandler && hasGlobalProcessEventEmitter()) {\n      uncaughtShimInstalled = true;\n      shimEmitUncaughtException();\n    }\n  }\n};\n","\n/**\n * Module dependencies.\n */\n\nvar sep = require('path').sep || '/';\n\n/**\n * Module exports.\n */\n\nmodule.exports = fileUriToPath;\n\n/**\n * File URI to Path function.\n *\n * @param {String} uri\n * @return {String} path\n * @api public\n */\n\nfunction fileUriToPath (uri) {\n  if ('string' != typeof uri ||\n      uri.length <= 7 ||\n      'file://' != uri.substring(0, 7)) {\n    throw new TypeError('must pass in a file:// URI to convert to a file path');\n  }\n\n  var rest = unescape(uri.substring(7));\n  var firstSlash = rest.indexOf('/');\n  var host = rest.substring(0, firstSlash);\n  var path = rest.substring(firstSlash + 1);\n\n  // 2.  Scheme Definition\n  // As a special case, <host> can be the string \"localhost\" or the empty\n  // string; this is interpreted as \"the machine from which the URL is\n  // being interpreted\".\n  if ('localhost' == host) host = '';\n\n  if (host) {\n    host = sep + sep + host;\n  }\n\n  // 3.2  Drives, drive letters, mount points, file system root\n  // Drive letters are mapped into the top of a file URI in various ways,\n  // depending on the implementation; some applications substitute\n  // vertical bar (\"|\") for the colon after the drive letter, yielding\n  // \"file:///c|/tmp/test.txt\".  In some cases, the colon is left\n  // unchanged, as in \"file:///c:/tmp/test.txt\".  In other cases, the\n  // colon is simply omitted, as in \"file:///c/tmp/test.txt\".\n  path = path.replace(/^(.+)\\|/, '$1:');\n\n  // for Windows, we need to invert the path separators from what a URI uses\n  if (sep == '\\\\') {\n    path = path.replace(/\\//g, '\\\\');\n  }\n\n  if (/^.+\\:/.test(path)) {\n    // has Windows drive at beginning of path\n  } else {\n    // unix path…\n    path = sep + path;\n  }\n\n  return host + path;\n}\n","import { formatError } from './format-error'\n\nexport function formatLogMessage(message: string, error?: Error) {\n  return error ? formatError(error, message) : message\n}\n","'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar util = require('util');\nvar common = require('winston/lib/winston/common');\nvar Transport = require('winston').Transport;\nvar Stream = require('stream').Stream;\nvar os = require('os');\nvar winston = require('winston');\nvar mkdirp = require('mkdirp');\nvar zlib = require('zlib');\n\nvar weekday = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n\n//\n// ### function DailyRotateFile (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the DailyRotateFile transport object responsible\n// for persisting log messages and metadata to one or more files.\n//\nvar DailyRotateFile = module.exports = function (options) {\n  Transport.call(this, options);\n\n  //\n  // Helper function which throws an `Error` in the event\n  // that any of the rest of the arguments is present in `options`.\n  //\n  function throwIf(target /* , illegal... */) {\n    Array.prototype.slice.call(arguments, 1).forEach(function (name) {\n      if (options[name]) {\n        throw new Error('Cannot set ' + name + ' and ' + target + 'together');\n      }\n    });\n  }\n\n  if (options.filename || options.dirname) {\n    throwIf('filename or dirname', 'stream');\n    this._basename = this.filename = options.filename ?\n      path.basename(options.filename) :\n      'winston.log';\n\n    this.dirname = options.dirname || path.dirname(options.filename);\n    this.options = options.options || {flags: 'a'};\n\n    //\n    // \"24 bytes\" is maybe a good value for logging lines.\n    //\n    this.options.highWaterMark = this.options.highWaterMark || 24;\n  } else if (options.stream) {\n    throwIf('stream', 'filename', 'maxsize');\n    this._stream = options.stream;\n    var self = this;\n    this._stream.on('error', function (error) {\n      self.emit('error', error);\n    });\n\n    //\n    // We need to listen for drain events when\n    // write() returns false. This can make node\n    // mad at times.\n    //\n    this._stream.setMaxListeners(Infinity);\n  } else {\n    throw new Error('Cannot log to file without filename or stream.');\n  }\n\n  this.json = options.json !== false;\n  this.colorize = options.colorize || false;\n  this.maxsize = options.maxsize || null;\n  this.logstash = options.logstash || null;\n  this.maxFiles = options.maxFiles || null;\n  this.label = options.label || null;\n  this.prettyPrint = options.prettyPrint || false;\n  this.showLevel = options.showLevel === undefined ? true : options.showLevel;\n  this.timestamp = options.timestamp === undefined ? true : options.timestamp;\n  this.datePattern = options.datePattern ? options.datePattern : '.yyyy-MM-dd';\n  this.depth = options.depth || null;\n  this.eol = options.eol || os.EOL;\n  this.maxRetries = options.maxRetries || 2;\n  this.prepend = options.prepend || false;\n  this.createTree = options.createTree || false;\n  this.localTime = options.localTime || false;\n  this.zippedArchive = options.zippedArchive || false;\n  this.maxDays = options.maxDays || 0;\n\n  if (this.json) {\n    this.stringify = options.stringify;\n  }\n\n  //\n  // Internal state variables representing the number\n  // of files this instance has created and the current\n  // size (in bytes) of the current logfile.\n  //\n  this._size = 0;\n  this._created = 0;\n  this._buffer = [];\n  this._draining = false;\n  this._failures = 0;\n  this._archive = false;\n\n  // Internal variable which will hold a record of all files\n  // belonging to this transport which are currently in the\n  // log directory in chronological order.\n  //\n  this._currentFiles = function () {\n    //\n    // Only proceed if maxsize is not configured for this transport.\n    if (!this.maxsize) {\n      try {\n        return fs.readdirSync(this.dirname).filter(function (file) {\n          return file.includes(this._basename);\n        }.bind(this)).map(function (file) {\n          return {\n            name: file,\n            time: fs.statSync(path.join(this.dirname, file)).mtime.getTime()\n          };\n        }.bind(this)).sort(function (a, b) {\n          return a.time - b.time;\n        }).map(function (v) {\n          return v.name;\n        });\n      } catch (e) {\n        // directory doesnt exist so there are no files. Do nothing.\n      }\n    }\n    return [];\n  }.bind(this)();\n\n  this._year = this._getTime('year');\n  this._month = this._getTime('month');\n  this._date = this._getTime('date');\n  this._hour = this._getTime('hour');\n  this._minute = this._getTime('minute');\n  this._weekday = weekday[this._getTime('day')];\n  var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhM])\\1?/g;\n  var pad = function (val, len) {\n    val = String(val);\n    len = len || 2;\n    while (val.length < len) {\n      val = '0' + val;\n    }\n    return val;\n  };\n\n  this.getFormattedDate = function () {\n    // update the year, month, date... variables\n    this._year = this._getTime('year');\n    this._month = this._getTime('month');\n    this._date = this._getTime('date');\n    this._hour = this._getTime('hour');\n    this._minute = this._getTime('minute');\n    this._weekday = weekday[this._getTime('day')];\n\n    var flags = {\n      yy: String(this._year).slice(2),\n      yyyy: this._year,\n      M: this._month + 1,\n      MM: pad(this._month + 1),\n      d: this._date,\n      dd: pad(this._date),\n      H: this._hour,\n      HH: pad(this._hour),\n      m: this._minute,\n      mm: pad(this._minute),\n      ddd: this._weekday\n    };\n    return this.datePattern.replace(token, function ($0) {\n      return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);\n    });\n  };\n};\n\n//\n// Inherit from `winston.Transport`.\n//\nutil.inherits(DailyRotateFile, Transport);\n\n/**\n * Define a getter so that `winston.transports.DailyRotateFile`\n * is available and thus backwards compatible.\n */\nwinston.transports.DailyRotateFile = DailyRotateFile;\n\n//\n// Expose the name of this Transport on the prototype\n//\nDailyRotateFile.prototype.name = 'dailyRotateFile';\n\n//\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\nDailyRotateFile.prototype.log = function (level, msg, meta, callback) {\n  if (this.silent) {\n    return callback(null, true);\n  }\n\n  //\n  // If failures exceeds maxRetries then we can't access the\n  // stream. In this case we need to perform a noop and return\n  // an error.\n  //\n  if (this._failures >= this.maxRetries) {\n    return callback(new Error('Transport is in a failed state.'));\n  }\n\n  var self = this;\n\n  var output = common.log({\n    level: level,\n    message: msg,\n    meta: meta,\n    json: this.json,\n    colorize: this.colorize,\n    logstash: this.logstash,\n    prettyPrint: this.prettyPrint,\n    timestamp: this.timestamp,\n    label: this.label,\n    stringify: this.stringify,\n    showLevel: this.showLevel,\n    depth: this.depth,\n    formatter: this.formatter,\n    humanReadableUnhandledException: this.humanReadableUnhandledException\n  }) + this.eol;\n\n  this._size += output.length;\n\n  if (this.filename) {\n    this.open(function (err) {\n      if (err) {\n        //\n        // If there was an error enqueue the message\n        //\n        return self._buffer.push([output, callback]);\n      }\n\n      self._write(output, callback);\n      self._lazyDrain();\n    });\n  } else {\n    //\n    // If there is no `filename` on this instance then it was configured\n    // with a raw `WriteableStream` instance and we should not perform any\n    // size restrictions.\n    //\n    this._write(output, callback);\n    this._lazyDrain();\n  }\n};\n\n//\n// ### function _write (data, cb)\n// #### @data {String|Buffer} Data to write to the instance's stream.\n// #### @cb {function} Continuation to respond to when complete.\n// Write to the stream, ensure execution of a callback on completion.\n//\nDailyRotateFile.prototype._write = function (data, callback) {\n  // If this is a file write stream, we could use the builtin\n  // callback functionality, however, the stream is not guaranteed\n  // to be an fs.WriteStream.\n  var ret = this._stream.write(data);\n  if (!callback) {\n    return;\n  }\n\n  if (ret === false) {\n    return this._stream.once('drain', function () {\n      callback(null, true);\n    });\n  }\n  callback(null, true);\n};\n\n//\n// ### function query (options, callback)\n// #### @options {Object} Loggly-like query options for this instance.\n// #### @callback {function} Continuation to respond to when complete.\n// Query the transport. Options object is optional.\n//\nDailyRotateFile.prototype.query = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  var self = this;\n\n  // TODO when maxfilesize rotate occurs\n  var createdFiles = self._currentFiles.slice(0); // Clone already sorted _currentFiles array\n  var results = [];\n  var row = 0;\n  options = self.normalizeQuery(options);\n\n  if (createdFiles.length === 0 && callback) {\n    callback(null, results);\n  }\n\n  // Edit so that all created files are read:\n  (function readNextFile(nextFile) {\n    if (!nextFile) {\n      return;\n    }\n    var file = path.join(self.dirname, nextFile);\n    var buff = '';\n\n    var stream = fs.createReadStream(file, {\n      encoding: 'utf8'\n    });\n\n    stream.on('error', function (err) {\n      if (stream.readable) {\n        stream.destroy();\n      }\n      if (!callback) {\n        return;\n      }\n      return err.code === 'ENOENT' ? callback(null, results) : callback(err);\n    });\n\n    stream.on('data', function (data) {\n      data = (buff + data).split(/\\n+/);\n      var l = data.length - 1;\n      var i = 0;\n\n      for (; i < l; i++) {\n        if (!options.start || row >= options.start) {\n          add(data[i]);\n        }\n        row++;\n      }\n\n      buff = data[l];\n    });\n\n    stream.on('close', function () {\n      if (buff) {\n        add(buff, true);\n      }\n      if (options.order === 'desc') {\n        results = results.reverse();\n      }\n\n      if (createdFiles.length) {\n        readNextFile(createdFiles.shift());\n      } else if (callback) {\n        callback(null, results);\n      }\n    });\n\n    function add(buff, attempt) {\n      try {\n        var log = JSON.parse(buff);\n        if (check(log)) {\n          push(log);\n        }\n      } catch (e) {\n        if (!attempt) {\n          stream.emit('error', e);\n        }\n      }\n    }\n\n    function push(log) {\n      if (options.rows && results.length >= options.rows && options.order !== 'desc') {\n        if (stream.readable) {\n          stream.destroy();\n        }\n        return;\n      }\n\n      if (options.fields) {\n        var obj = {};\n        options.fields.forEach(function (key) {\n          obj[key] = log[key];\n        });\n        log = obj;\n      }\n\n      if (options.order === 'desc') {\n        if (results.length >= options.rows) {\n          results.shift();\n        }\n      }\n      results.push(log);\n    }\n\n    function check(log) {\n      if (!log) {\n        return;\n      }\n\n      if (typeof log !== 'object') {\n        return;\n      }\n\n      var time = new Date(log.timestamp);\n      if ((options.from && time < options.from) ||\n        (options.until && time > options.until)) {\n        return;\n      }\n\n      return true;\n    }\n  })(createdFiles.shift());// executes the function\n};\n\n//\n// ### function stream (options)\n// #### @options {Object} Stream options for this instance.\n// Returns a log stream for this transport. Options object is optional.\n//\nDailyRotateFile.prototype.stream = function (options) {\n  var file = path.join(this.dirname, this._getFilename());\n  options = options || {};\n  var stream = new Stream();\n\n  var tail = {\n    file: file,\n    start: options.start\n  };\n\n  stream.destroy = common.tailFile(tail, function (err, line) {\n    if (err) {\n      return stream.emit('error', err);\n    }\n\n    try {\n      stream.emit('data', line);\n      line = JSON.parse(line);\n      stream.emit('log', line);\n    } catch (e) {\n      stream.emit('error', e);\n    }\n  });\n\n  if (stream.resume) {\n    stream.resume();\n  }\n\n  return stream;\n};\n\n//\n// ### function open (callback)\n// #### @callback {function} Continuation to respond to when complete\n// Checks to see if a new file needs to be created based on the `maxsize`\n// (if any) and the current size of the file used.\n//\nDailyRotateFile.prototype.open = function (callback) {\n  if (this.opening) {\n    //\n    // If we are already attempting to open the next\n    // available file then respond with a value indicating\n    // that the message should be buffered.\n    //\n    return callback(true);\n  } else if (!this._stream || (this.maxsize && this._size >= this.maxsize) ||\n    this._filenameHasExpired()) {\n    this._cleanOldFiles();\n    //\n    // If we dont have a stream or have exceeded our size, then create\n    // the next stream and respond with a value indicating that\n    // the message should be buffered.\n    //\n    callback(true);\n    return this._createStream();\n  }\n\n  //\n  // Otherwise we have a valid (and ready) stream.\n  //\n  callback();\n};\n\n//\n// ### function close ()\n// Closes the stream associated with this instance.\n//\nDailyRotateFile.prototype.close = function () {\n  var self = this;\n\n  if (this._stream) {\n    this._stream.end();\n    this._stream.destroySoon();\n\n    this._stream.once('drain', function () {\n      self.emit('flush');\n      self.emit('closed');\n    });\n  }\n};\n\n//\n// ### function flush ()\n// Flushes any buffered messages to the current `stream`\n// used by this instance.\n//\nDailyRotateFile.prototype.flush = function () {\n  var self = this;\n\n  //\n  // Iterate over the `_buffer` of enqueued messaged\n  // and then write them to the newly created stream.\n  //\n  this._buffer.forEach(function (item) {\n    var str = item[0];\n    var callback = item[1];\n\n    process.nextTick(function () {\n      self._write(str, callback);\n      self._size += str.length;\n    });\n  });\n\n  //\n  // Quickly truncate the `_buffer` once the write operations\n  // have been started\n  //\n  self._buffer.length = 0;\n\n  //\n  // When the stream has drained we have flushed\n  // our buffer.\n  //\n  self._stream.once('drain', function () {\n    self.emit('flush');\n    self.emit('logged');\n  });\n};\n\n//\n// ### @private function _createStream ()\n// Attempts to open the next appropriate file for this instance\n// based on the common state (such as `maxsize` and `_basename`).\n//\nDailyRotateFile.prototype._createStream = function () {\n  var self = this;\n  this.opening = true;\n\n  (function checkFile(target) {\n    var fullname = path.join(self.dirname, target);\n    //\n    // Creates the `WriteStream` and then flushes any\n    // buffered messages.\n    //\n    function createAndFlush(size) {\n      if (self._stream) {\n        self._archive = self.zippedArchive ? self._stream.path : false;\n\n        self._stream.end();\n        self._stream.destroySoon();\n      }\n\n      if (self.createTree) {\n        mkdirp.sync(path.dirname(fullname));\n      }\n\n      self._size = size;\n      self.filename = target;\n      self._stream = fs.createWriteStream(fullname, self.options);\n      self._stream.on('error', function (error) {\n        if (self._failures < self.maxRetries) {\n          self._createStream();\n          self._failures++;\n        } else {\n          self.emit('error', error);\n        }\n      });\n\n      //\n      // We need to listen for drain events when\n      // write() returns false. This can make node\n      // mad at times.\n      //\n      self._stream.setMaxListeners(Infinity);\n\n      //\n      // When the current stream has finished flushing\n      // then we can be sure we have finished opening\n      // and thus can emit the `open` event.\n      //\n      self.once('flush', function () {\n        // Because \"flush\" event is based on native stream \"drain\" event,\n        // logs could be written inbetween \"self.flush()\" and here\n        // Therefore, we need to flush again to make sure everything is flushed\n        self.flush();\n\n        self.opening = false;\n        self.emit('open', fullname);\n      });\n\n      //\n      // Remark: It is possible that in the time it has taken to find the\n      // next logfile to be written more data than `maxsize` has been buffered,\n      // but for sensible limits (10s - 100s of MB) this seems unlikely in less\n      // than one second.\n      //\n      self.flush();\n      compressFile();\n    }\n\n    function compressFile() {\n      var logfile = self._archive;\n      self._archive = false;\n      if (logfile && fs.existsSync(String(logfile))) {\n        var gzip = zlib.createGzip();\n\n        var inp = fs.createReadStream(String(logfile));\n        var out = fs.createWriteStream(logfile + '.gz');\n\n        inp.pipe(gzip).pipe(out);\n        fs.unlinkSync(String(logfile));\n      }\n    }\n\n    fs.stat(fullname, function (err, stats) {\n      if (err) {\n        if (err.code !== 'ENOENT') {\n          return self.emit('error', err);\n        }\n\n        return createAndFlush(0);\n      }\n\n      if (!stats || (self.maxsize && stats.size >= self.maxsize)) {\n        //\n        // If `stats.size` is greater than the `maxsize` for\n        // this instance then try again\n        //\n        return checkFile(self._getFile(true));\n      }\n\n      if (self._filenameHasExpired()) {\n        self._year = self._getTime('year');\n        self._month = self._getTime('month');\n        self._date = self._getTime('date');\n        self._hour = self._getTime('hour');\n        self._minute = self._getTime('minute');\n        self._weekday = weekday[self._getTime('day')];\n        self._created = 0;\n        return checkFile(self._getFile());\n      }\n\n      createAndFlush(stats.size);\n    });\n  })(this._getFile());\n};\n\n//\n// ### @private function _getFile ()\n// Gets the next filename to use for this instance\n// in the case that log filesizes are being capped.\n//\nDailyRotateFile.prototype._getFile = function (inc) {\n  var filename = this._getFilename();\n  var remaining;\n\n  if (inc) {\n    //\n    // Increment the number of files created or\n    // checked by this instance.\n    //\n    // Check for maxFiles option and delete file\n    if (this.maxFiles && (this._created >= (this.maxFiles - 1))) {\n      remaining = this._created - (this.maxFiles - 1);\n      if (remaining === 0) {\n        try {\n          fs.unlinkSync(path.join(this.dirname, filename));\n        } catch (e) {}\n      } else {\n        try {\n          fs.unlinkSync(path.join(this.dirname, filename + '.' + remaining));\n        } catch (e) {}\n      }\n    }\n\n    this._created += 1;\n  } else if (!this.maxsize) {\n    //\n    // If the filename does not exist in the _currentFiles array then add it.\n    if (this._currentFiles.indexOf(filename) === -1) {\n      this._currentFiles.push(filename);\n    }\n\n    // While the _currentFiles array contains more file names than is configured\n    // in maxFiles loop the _currentFiles array and delete the file found at el\n    // 0.\n    while (this.maxFiles && (this._currentFiles.length > this.maxFiles)) {\n      try {\n        fs.unlinkSync(path.join(this.dirname, this._currentFiles[0]));\n      } catch (e) {\n        // File isn't accessible, do nothing.\n      }\n\n      // Remove the filename that was just deleted from the _currentFiles array.\n      this._currentFiles = this._currentFiles.slice(1);\n    }\n  }\n\n  return this._created ? filename + '.' + this._created : filename;\n};\n\n//\n// ### @private function _getFilename ()\n// Returns the log filename depending on `this.prepend` option value\n//\nDailyRotateFile.prototype._getFilename = function () {\n  var formattedDate = this.getFormattedDate();\n\n  if (this.prepend) {\n    if (this.datePattern === '.yyyy-MM-dd') {\n      this.datePattern = 'yyyy-MM-dd.';\n      formattedDate = this.getFormattedDate();\n    }\n\n    return formattedDate + this._basename;\n  }\n\n  return this._basename + formattedDate;\n};\n\n//\n// ### @private function _lazyDrain ()\n// Lazily attempts to emit the `logged` event when `this.stream` has\n// drained. This is really just a simple mutex that only works because\n// Node.js is single-threaded.\n//\nDailyRotateFile.prototype._lazyDrain = function () {\n  var self = this;\n\n  if (!this._draining && this._stream) {\n    this._draining = true;\n\n    this._stream.once('drain', function () {\n      this._draining = false;\n      self.emit('logged');\n    });\n  }\n};\n\n//\n// ### @private function _filenameHasExpired ()\n// Checks whether the current log file is valid\n// based on given datepattern\n//\nDailyRotateFile.prototype._filenameHasExpired = function () {\n  // searching for m is enough to say minute in date pattern\n  if (this.datePattern.match(/m/)) {\n    return (this._year < this._getTime('year') || this._month < this._getTime('month') || this._date < this._getTime('date') || this._hour < this._getTime('hour') || this._minute < this._getTime('minute'));\n  } else if (this.datePattern.match(/H/)) {\n    return (this._year < this._getTime('year') || this._month < this._getTime('month') || this._date < this._getTime('date') || this._hour < this._getTime('hour'));\n  } else if (this.datePattern.match(/d/)) {\n    return (this._year < this._getTime('year') || this._month < this._getTime('month') || this._date < this._getTime('date'));\n  } else if (this.datePattern.match(/M/)) {\n    return (this._year < this._getTime('year') || this._month < this._getTime('month'));\n  } else if (this.datePattern.match(/yy/)) {\n    return (this._year < this._getTime('year'));\n  }\n  return false;\n};\n\n//\n// ### @private function _getTime ()\n// Get current date/time\n// based on localTime config\n//\nDailyRotateFile.prototype._getTime = function (timeType) {\n  var now = new Date();\n\n  if (this.localTime) {\n    if (timeType === 'year') {\n      return now.getFullYear();\n    } else if (timeType === 'month') {\n      return now.getMonth();\n    } else if (timeType === 'date') {\n      return now.getDate();\n    } else if (timeType === 'hour') {\n      return now.getHours();\n    } else if (timeType === 'minute') {\n      return now.getMinutes();\n    } else if (timeType === 'day') {\n      return now.getDay();\n    }\n  }\n  if (timeType === 'year') {\n    return now.getUTCFullYear();\n  } else if (timeType === 'month') {\n    return now.getUTCMonth();\n  } else if (timeType === 'date') {\n    return now.getUTCDate();\n  } else if (timeType === 'hour') {\n    return now.getUTCHours();\n  } else if (timeType === 'minute') {\n    return now.getUTCMinutes();\n  } else if (timeType === 'day') {\n    return now.getUTCDay();\n  }\n};\n\n// ### @private function _cleanOldFiles ()\n// Remove old log files\n// based on \"maxDays\" option\nDailyRotateFile.prototype._cleanOldFiles = function () {\n  var self = this;\n  var millisecondsInDay = 86400000;\n  var now = Date.now();\n\n  function removeOldFile(file) {\n    fs.unlink(self.dirname + path.sep + file, function (errUnlink) {\n      if (errUnlink) {\n        console.error('Error removing file ', file);\n      }\n    });\n  }\n\n  function tryToRemoveLogFile(file) {\n    var completeFileName = self.dirname + path.sep + file;\n    fs.stat(completeFileName, function (errStats, stats) {\n      if (errStats) {\n        console.error('Error stats file ', file, errStats);\n        return;\n      }\n\n      var lastChangeTimestamp = ((stats.mtime && stats.mtime.getTime()) || 0);\n      var lifeTime = now - lastChangeTimestamp;\n      if (stats.isFile() && lifeTime > (millisecondsInDay * self.maxDays)) {\n        removeOldFile(file);\n      }\n    });\n  }\n\n  // if not maxDays specified, do not remove old log files\n  if (self.maxDays) {\n    fs.readdir(self.dirname, function (err, files) {\n      if (err) {\n        console.error('Error reading directory ', self.dirname, err);\n        return;\n      }\n\n      var fileNameReg = new RegExp(self._basename, 'g');\n      files.forEach(function (file) {\n        if (/.log/.test(file) && fileNameReg.test(file)) {\n          tryToRemoveLogFile(file);\n        }\n      });\n    });\n  }\n};\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction outputFile (file, data, encoding, callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding\n    encoding = 'utf8'\n  }\n\n  const dir = path.dirname(file)\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return fs.writeFile(file, data, encoding, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n\n      fs.writeFile(file, data, encoding, callback)\n    })\n  })\n}\n\nfunction outputFileSync (file, ...args) {\n  const dir = path.dirname(file)\n  if (fs.existsSync(dir)) {\n    return fs.writeFileSync(file, ...args)\n  }\n  mkdir.mkdirsSync(dir)\n  fs.writeFileSync(file, ...args)\n}\n\nmodule.exports = {\n  outputFile: u(outputFile),\n  outputFileSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copy = require('../copy').copy\nconst remove = require('../remove').remove\nconst mkdirp = require('../mkdirs').mkdirp\nconst pathExists = require('../path-exists').pathExists\n\nfunction move (src, dest, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts\n    opts = {}\n  }\n\n  const overwrite = opts.overwrite || opts.clobber || false\n\n  src = path.resolve(src)\n  dest = path.resolve(dest)\n\n  if (src === dest) return fs.access(src, cb)\n\n  fs.stat(src, (err, st) => {\n    if (err) return cb(err)\n\n    if (st.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`))\n    }\n    mkdirp(path.dirname(dest), err => {\n      if (err) return cb(err)\n      return doRename(src, dest, overwrite, cb)\n    })\n  })\n}\n\nfunction doRename (src, dest, overwrite, cb) {\n  if (overwrite) {\n    return remove(dest, err => {\n      if (err) return cb(err)\n      return rename(src, dest, overwrite, cb)\n    })\n  }\n  pathExists(dest, (err, destExists) => {\n    if (err) return cb(err)\n    if (destExists) return cb(new Error('dest already exists.'))\n    return rename(src, dest, overwrite, cb)\n  })\n}\n\nfunction rename (src, dest, overwrite, cb) {\n  fs.rename(src, dest, err => {\n    if (!err) return cb()\n    if (err.code !== 'EXDEV') return cb(err)\n    return moveAcrossDevice(src, dest, overwrite, cb)\n  })\n}\n\nfunction moveAcrossDevice (src, dest, overwrite, cb) {\n  const opts = {\n    overwrite,\n    errorOnExist: true\n  }\n\n  copy(src, dest, opts, err => {\n    if (err) return cb(err)\n    return remove(src, cb)\n  })\n}\n\nfunction isSrcSubdir (src, dest) {\n  const srcArray = src.split(path.sep)\n  const destArray = dest.split(path.sep)\n\n  return srcArray.reduce((acc, current, i) => {\n    return acc && destArray[i] === current\n  }, true)\n}\n\nmodule.exports = {\n  move: u(move)\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst copySync = require('../copy-sync').copySync\nconst removeSync = require('../remove').removeSync\nconst mkdirpSync = require('../mkdirs').mkdirsSync\nconst buffer = require('../util/buffer')\n\nfunction moveSync (src, dest, options) {\n  options = options || {}\n  const overwrite = options.overwrite || options.clobber || false\n\n  src = path.resolve(src)\n  dest = path.resolve(dest)\n\n  if (src === dest) return fs.accessSync(src)\n\n  if (isSrcSubdir(src, dest)) throw new Error(`Cannot move '${src}' into itself '${dest}'.`)\n\n  mkdirpSync(path.dirname(dest))\n  tryRenameSync()\n\n  function tryRenameSync () {\n    if (overwrite) {\n      try {\n        return fs.renameSync(src, dest)\n      } catch (err) {\n        if (err.code === 'ENOTEMPTY' || err.code === 'EEXIST' || err.code === 'EPERM') {\n          removeSync(dest)\n          options.overwrite = false // just overwriteed it, no need to do it again\n          return moveSync(src, dest, options)\n        }\n\n        if (err.code !== 'EXDEV') throw err\n        return moveSyncAcrossDevice(src, dest, overwrite)\n      }\n    } else {\n      try {\n        fs.linkSync(src, dest)\n        return fs.unlinkSync(src)\n      } catch (err) {\n        if (err.code === 'EXDEV' || err.code === 'EISDIR' || err.code === 'EPERM' || err.code === 'ENOTSUP') {\n          return moveSyncAcrossDevice(src, dest, overwrite)\n        }\n        throw err\n      }\n    }\n  }\n}\n\nfunction moveSyncAcrossDevice (src, dest, overwrite) {\n  const stat = fs.statSync(src)\n\n  if (stat.isDirectory()) {\n    return moveDirSyncAcrossDevice(src, dest, overwrite)\n  } else {\n    return moveFileSyncAcrossDevice(src, dest, overwrite)\n  }\n}\n\nfunction moveFileSyncAcrossDevice (src, dest, overwrite) {\n  const BUF_LENGTH = 64 * 1024\n  const _buff = buffer(BUF_LENGTH)\n\n  const flags = overwrite ? 'w' : 'wx'\n\n  const fdr = fs.openSync(src, 'r')\n  const stat = fs.fstatSync(fdr)\n  const fdw = fs.openSync(dest, flags, stat.mode)\n  let pos = 0\n\n  while (pos < stat.size) {\n    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n  return fs.unlinkSync(src)\n}\n\nfunction moveDirSyncAcrossDevice (src, dest, overwrite) {\n  const options = {\n    overwrite: false\n  }\n\n  if (overwrite) {\n    removeSync(dest)\n    tryCopySync()\n  } else {\n    tryCopySync()\n  }\n\n  function tryCopySync () {\n    copySync(src, dest, options)\n    return removeSync(src)\n  }\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// extract dest base dir and check if that is the same as src basename\nfunction isSrcSubdir (src, dest) {\n  try {\n    return fs.statSync(src).isDirectory() &&\n           src !== dest &&\n           dest.indexOf(src) > -1 &&\n           dest.split(path.dirname(src) + path.sep)[1].split(path.sep)[0] === path.basename(src)\n  } catch (e) {\n    return false\n  }\n}\n\nmodule.exports = {\n  moveSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst jsonFile = require('./jsonfile')\n\nfunction outputJsonSync (file, data, options) {\n  const dir = path.dirname(file)\n\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  jsonFile.writeJsonSync(file, data, options)\n}\n\nmodule.exports = outputJsonSync\n","'use strict'\n\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\nconst jsonFile = require('./jsonfile')\n\nfunction outputJson (file, data, options, callback) {\n  if (typeof options === 'function') {\n    callback = options\n    options = {}\n  }\n\n  const dir = path.dirname(file)\n\n  pathExists(dir, (err, itDoes) => {\n    if (err) return callback(err)\n    if (itDoes) return jsonFile.writeJson(file, data, options, callback)\n\n    mkdir.mkdirs(dir, err => {\n      if (err) return callback(err)\n      jsonFile.writeJson(file, data, options, callback)\n    })\n  })\n}\n\nmodule.exports = outputJson\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst jsonFile = require('./jsonfile')\n\njsonFile.outputJson = u(require('./output-json'))\njsonFile.outputJsonSync = require('./output-json-sync')\n// aliases\njsonFile.outputJSON = jsonFile.outputJson\njsonFile.outputJSONSync = jsonFile.outputJsonSync\njsonFile.writeJSON = jsonFile.writeJson\njsonFile.writeJSONSync = jsonFile.writeJsonSync\njsonFile.readJSON = jsonFile.readJson\njsonFile.readJSONSync = jsonFile.readJsonSync\n\nmodule.exports = jsonFile\n","'use strict'\n\nconst fs = require('graceful-fs')\n\nfunction symlinkType (srcpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n  if (type) return callback(null, type)\n  fs.lstat(srcpath, (err, stats) => {\n    if (err) return callback(null, 'file')\n    type = (stats && stats.isDirectory()) ? 'dir' : 'file'\n    callback(null, type)\n  })\n}\n\nfunction symlinkTypeSync (srcpath, type) {\n  let stats\n\n  if (type) return type\n  try {\n    stats = fs.lstatSync(srcpath)\n  } catch (e) {\n    return 'file'\n  }\n  return (stats && stats.isDirectory()) ? 'dir' : 'file'\n}\n\nmodule.exports = {\n  symlinkType,\n  symlinkTypeSync\n}\n","'use strict'\n\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst pathExists = require('../path-exists').pathExists\n\n/**\n * Function that returns two types of paths, one relative to symlink, and one\n * relative to the current working directory. Checks if path is absolute or\n * relative. If the path is relative, this function checks if the path is\n * relative to symlink or relative to current working directory. This is an\n * initiative to find a smarter `srcpath` to supply when building symlinks.\n * This allows you to determine which path to use out of one of three possible\n * types of source paths. The first is an absolute path. This is detected by\n * `path.isAbsolute()`. When an absolute path is provided, it is checked to\n * see if it exists. If it does it's used, if not an error is returned\n * (callback)/ thrown (sync). The other two options for `srcpath` are a\n * relative url. By default Node's `fs.symlink` works by creating a symlink\n * using `dstpath` and expects the `srcpath` to be relative to the newly\n * created symlink. If you provide a `srcpath` that does not exist on the file\n * system it results in a broken symlink. To minimize this, the function\n * checks to see if the 'relative to symlink' source file exists, and if it\n * does it will use it. If it does not, it checks if there's a file that\n * exists that is relative to the current working directory, if does its used.\n * This preserves the expectations of the original fs.symlink spec and adds\n * the ability to pass in `relative to current working direcotry` paths.\n */\n\nfunction symlinkPaths (srcpath, dstpath, callback) {\n  if (path.isAbsolute(srcpath)) {\n    return fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureSymlink')\n        return callback(err)\n      }\n      return callback(null, {\n        'toCwd': srcpath,\n        'toDst': srcpath\n      })\n    })\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    return pathExists(relativeToDst, (err, exists) => {\n      if (err) return callback(err)\n      if (exists) {\n        return callback(null, {\n          'toCwd': relativeToDst,\n          'toDst': srcpath\n        })\n      } else {\n        return fs.lstat(srcpath, (err) => {\n          if (err) {\n            err.message = err.message.replace('lstat', 'ensureSymlink')\n            return callback(err)\n          }\n          return callback(null, {\n            'toCwd': srcpath,\n            'toDst': path.relative(dstdir, srcpath)\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction symlinkPathsSync (srcpath, dstpath) {\n  let exists\n  if (path.isAbsolute(srcpath)) {\n    exists = fs.existsSync(srcpath)\n    if (!exists) throw new Error('absolute srcpath does not exist')\n    return {\n      'toCwd': srcpath,\n      'toDst': srcpath\n    }\n  } else {\n    const dstdir = path.dirname(dstpath)\n    const relativeToDst = path.join(dstdir, srcpath)\n    exists = fs.existsSync(relativeToDst)\n    if (exists) {\n      return {\n        'toCwd': relativeToDst,\n        'toDst': srcpath\n      }\n    } else {\n      exists = fs.existsSync(srcpath)\n      if (!exists) throw new Error('relative srcpath does not exist')\n      return {\n        'toCwd': srcpath,\n        'toDst': path.relative(dstdir, srcpath)\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  symlinkPaths,\n  symlinkPathsSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst _mkdirs = require('../mkdirs')\nconst mkdirs = _mkdirs.mkdirs\nconst mkdirsSync = _mkdirs.mkdirsSync\n\nconst _symlinkPaths = require('./symlink-paths')\nconst symlinkPaths = _symlinkPaths.symlinkPaths\nconst symlinkPathsSync = _symlinkPaths.symlinkPathsSync\n\nconst _symlinkType = require('./symlink-type')\nconst symlinkType = _symlinkType.symlinkType\nconst symlinkTypeSync = _symlinkType.symlinkTypeSync\n\nconst pathExists = require('../path-exists').pathExists\n\nfunction createSymlink (srcpath, dstpath, type, callback) {\n  callback = (typeof type === 'function') ? type : callback\n  type = (typeof type === 'function') ? false : type\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    symlinkPaths(srcpath, dstpath, (err, relative) => {\n      if (err) return callback(err)\n      srcpath = relative.toDst\n      symlinkType(relative.toCwd, type, (err, type) => {\n        if (err) return callback(err)\n        const dir = path.dirname(dstpath)\n        pathExists(dir, (err, dirExists) => {\n          if (err) return callback(err)\n          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)\n          mkdirs(dir, err => {\n            if (err) return callback(err)\n            fs.symlink(srcpath, dstpath, type, callback)\n          })\n        })\n      })\n    })\n  })\n}\n\nfunction createSymlinkSync (srcpath, dstpath, type) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  const relative = symlinkPathsSync(srcpath, dstpath)\n  srcpath = relative.toDst\n  type = symlinkTypeSync(relative.toCwd, type)\n  const dir = path.dirname(dstpath)\n  const exists = fs.existsSync(dir)\n  if (exists) return fs.symlinkSync(srcpath, dstpath, type)\n  mkdirsSync(dir)\n  return fs.symlinkSync(srcpath, dstpath, type)\n}\n\nmodule.exports = {\n  createSymlink: u(createSymlink),\n  createSymlinkSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction createLink (srcpath, dstpath, callback) {\n  function makeLink (srcpath, dstpath) {\n    fs.link(srcpath, dstpath, err => {\n      if (err) return callback(err)\n      callback(null)\n    })\n  }\n\n  pathExists(dstpath, (err, destinationExists) => {\n    if (err) return callback(err)\n    if (destinationExists) return callback(null)\n    fs.lstat(srcpath, (err) => {\n      if (err) {\n        err.message = err.message.replace('lstat', 'ensureLink')\n        return callback(err)\n      }\n\n      const dir = path.dirname(dstpath)\n      pathExists(dir, (err, dirExists) => {\n        if (err) return callback(err)\n        if (dirExists) return makeLink(srcpath, dstpath)\n        mkdir.mkdirs(dir, err => {\n          if (err) return callback(err)\n          makeLink(srcpath, dstpath)\n        })\n      })\n    })\n  })\n}\n\nfunction createLinkSync (srcpath, dstpath) {\n  const destinationExists = fs.existsSync(dstpath)\n  if (destinationExists) return undefined\n\n  try {\n    fs.lstatSync(srcpath)\n  } catch (err) {\n    err.message = err.message.replace('lstat', 'ensureLink')\n    throw err\n  }\n\n  const dir = path.dirname(dstpath)\n  const dirExists = fs.existsSync(dir)\n  if (dirExists) return fs.linkSync(srcpath, dstpath)\n  mkdir.mkdirsSync(dir)\n\n  return fs.linkSync(srcpath, dstpath)\n}\n\nmodule.exports = {\n  createLink: u(createLink),\n  createLinkSync\n}\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst path = require('path')\nconst fs = require('graceful-fs')\nconst mkdir = require('../mkdirs')\nconst pathExists = require('../path-exists').pathExists\n\nfunction createFile (file, callback) {\n  function makeFile () {\n    fs.writeFile(file, '', err => {\n      if (err) return callback(err)\n      callback()\n    })\n  }\n\n  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err\n    if (!err && stats.isFile()) return callback()\n    const dir = path.dirname(file)\n    pathExists(dir, (err, dirExists) => {\n      if (err) return callback(err)\n      if (dirExists) return makeFile()\n      mkdir.mkdirs(dir, err => {\n        if (err) return callback(err)\n        makeFile()\n      })\n    })\n  })\n}\n\nfunction createFileSync (file) {\n  let stats\n  try {\n    stats = fs.statSync(file)\n  } catch (e) {}\n  if (stats && stats.isFile()) return\n\n  const dir = path.dirname(file)\n  if (!fs.existsSync(dir)) {\n    mkdir.mkdirsSync(dir)\n  }\n\n  fs.writeFileSync(file, '')\n}\n\nmodule.exports = {\n  createFile: u(createFile),\n  createFileSync\n}\n","'use strict'\n\nconst file = require('./file')\nconst link = require('./link')\nconst symlink = require('./symlink')\n\nmodule.exports = {\n  // file\n  createFile: file.createFile,\n  createFileSync: file.createFileSync,\n  ensureFile: file.createFile,\n  ensureFileSync: file.createFileSync,\n  // link\n  createLink: link.createLink,\n  createLinkSync: link.createLinkSync,\n  ensureLink: link.createLink,\n  ensureLinkSync: link.createLinkSync,\n  // symlink\n  createSymlink: symlink.createSymlink,\n  createSymlinkSync: symlink.createSymlinkSync,\n  ensureSymlink: symlink.createSymlink,\n  ensureSymlinkSync: symlink.createSymlinkSync\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst assert = require('assert')\n\nconst isWindows = (process.platform === 'win32')\n\nfunction defaults (options) {\n  const methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(m => {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n}\n\nfunction rimraf (p, options, cb) {\n  let busyTries = 0\n\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  rimraf_(p, options, function CB (er) {\n    if (er) {\n      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&\n          busyTries < options.maxBusyTries) {\n        busyTries++\n        const time = busyTries * 100\n        // try again, with the same exact callback as this one.\n        return setTimeout(() => rimraf_(p, options, CB), time)\n      }\n\n      // already gone\n      if (er.code === 'ENOENT') er = null\n    }\n\n    cb(er)\n  })\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, (er, st) => {\n    if (er && er.code === 'ENOENT') {\n      return cb(null)\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === 'EPERM' && isWindows) {\n      return fixWinEPERM(p, options, er, cb)\n    }\n\n    if (st && st.isDirectory()) {\n      return rmdir(p, options, er, cb)\n    }\n\n    options.unlink(p, er => {\n      if (er) {\n        if (er.code === 'ENOENT') {\n          return cb(null)\n        }\n        if (er.code === 'EPERM') {\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        }\n        if (er.code === 'EISDIR') {\n          return rmdir(p, options, er, cb)\n        }\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  options.chmod(p, 0o666, er2 => {\n    if (er2) {\n      cb(er2.code === 'ENOENT' ? null : er)\n    } else {\n      options.stat(p, (er3, stats) => {\n        if (er3) {\n          cb(er3.code === 'ENOENT' ? null : er)\n        } else if (stats.isDirectory()) {\n          rmdir(p, options, er, cb)\n        } else {\n          options.unlink(p, cb)\n        }\n      })\n    }\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  let stats\n\n  assert(p)\n  assert(options)\n  if (er) {\n    assert(er instanceof Error)\n  }\n\n  try {\n    options.chmodSync(p, 0o666)\n  } catch (er2) {\n    if (er2.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  try {\n    stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === 'ENOENT') {\n      return\n    } else {\n      throw er\n    }\n  }\n\n  if (stats.isDirectory()) {\n    rmdirSync(p, options, er)\n  } else {\n    options.unlinkSync(p)\n  }\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, er => {\n    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {\n      rmkids(p, options, cb)\n    } else if (er && er.code === 'ENOTDIR') {\n      cb(originalEr)\n    } else {\n      cb(er)\n    }\n  })\n}\n\nfunction rmkids (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, (er, files) => {\n    if (er) return cb(er)\n\n    let n = files.length\n    let errState\n\n    if (n === 0) return options.rmdir(p, cb)\n\n    files.forEach(f => {\n      rimraf(path.join(p, f), options, er => {\n        if (errState) {\n          return\n        }\n        if (er) return cb(errState = er)\n        if (--n === 0) {\n          options.rmdir(p, cb)\n        }\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  let st\n\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')\n\n  try {\n    st = options.lstatSync(p)\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    }\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er.code === 'EPERM' && isWindows) {\n      fixWinEPERMSync(p, options, er)\n    }\n  }\n\n  try {\n    // sunos lets the root user unlink directories, which is... weird.\n    if (st && st.isDirectory()) {\n      rmdirSync(p, options, null)\n    } else {\n      options.unlinkSync(p)\n    }\n  } catch (er) {\n    if (er.code === 'ENOENT') {\n      return\n    } else if (er.code === 'EPERM') {\n      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n    } else if (er.code !== 'EISDIR') {\n      throw er\n    }\n    rmdirSync(p, options, er)\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr) {\n    assert(originalEr instanceof Error)\n  }\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === 'ENOTDIR') {\n      throw originalEr\n    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {\n      rmkidsSync(p, options)\n    } else if (er.code !== 'ENOENT') {\n      throw er\n    }\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))\n\n  if (isWindows) {\n    // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n    const startTime = Date.now()\n    do {\n      try {\n        const ret = options.rmdirSync(p, options)\n        return ret\n      } catch (er) { }\n    } while (Date.now() - startTime < 500) // give up after 500ms\n  } else {\n    const ret = options.rmdirSync(p, options)\n    return ret\n  }\n}\n\nmodule.exports = rimraf\nrimraf.sync = rimrafSync\n","'use strict'\n\nconst u = require('universalify').fromCallback\nconst fs = require('fs')\nconst path = require('path')\nconst mkdir = require('../mkdirs')\nconst remove = require('../remove')\n\nconst emptyDir = u(function emptyDir (dir, callback) {\n  callback = callback || function () {}\n  fs.readdir(dir, (err, items) => {\n    if (err) return mkdir.mkdirs(dir, callback)\n\n    items = items.map(item => path.join(dir, item))\n\n    deleteItem()\n\n    function deleteItem () {\n      const item = items.pop()\n      if (!item) return callback()\n      remove.remove(item, err => {\n        if (err) return callback(err)\n        deleteItem()\n      })\n    }\n  })\n})\n\nfunction emptyDirSync (dir) {\n  let items\n  try {\n    items = fs.readdirSync(dir)\n  } catch (err) {\n    return mkdir.mkdirsSync(dir)\n  }\n\n  items.forEach(item => {\n    item = path.join(dir, item)\n    remove.removeSync(item)\n  })\n}\n\nmodule.exports = {\n  emptyDirSync,\n  emptydirSync: emptyDirSync,\n  emptyDir,\n  emptydir: emptyDir\n}\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirp = require('../mkdirs').mkdirs\nconst pathExists = require('../path-exists').pathExists\nconst utimes = require('../util/utimes').utimesMillis\n\nconst notExist = Symbol('notExist')\n\nfunction copy (src, dest, opts, cb) {\n  if (typeof opts === 'function' && !cb) {\n    cb = opts\n    opts = {}\n  } else if (typeof opts === 'function') {\n    opts = {filter: opts}\n  }\n\n  cb = cb || function () {}\n  opts = opts || {}\n\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  checkPaths(src, dest, (err, destStat) => {\n    if (err) return cb(err)\n    if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)\n    return checkParentDir(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction checkParentDir (destStat, src, dest, opts, cb) {\n  const destParent = path.dirname(dest)\n  pathExists(destParent, (err, dirExists) => {\n    if (err) return cb(err)\n    if (dirExists) return startCopy(destStat, src, dest, opts, cb)\n    mkdirp(destParent, err => {\n      if (err) return cb(err)\n      return startCopy(destStat, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  Promise.resolve(opts.filter(src, dest)).then(include => {\n    if (include) {\n      if (destStat) return onInclude(destStat, src, dest, opts, cb)\n      return onInclude(src, dest, opts, cb)\n    }\n    return cb()\n  }, error => cb(error))\n}\n\nfunction startCopy (destStat, src, dest, opts, cb) {\n  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)\n  return getStats(destStat, src, dest, opts, cb)\n}\n\nfunction getStats (destStat, src, dest, opts, cb) {\n  const stat = opts.dereference ? fs.stat : fs.lstat\n  stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n\n    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isFile() ||\n             srcStat.isCharacterDevice() ||\n             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)\n    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts, cb) {\n  if (destStat === notExist) return copyFile(srcStat, src, dest, opts, cb)\n  return mayCopyFile(srcStat, src, dest, opts, cb)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts, cb) {\n  if (opts.overwrite) {\n    fs.unlink(dest, err => {\n      if (err) return cb(err)\n      return copyFile(srcStat, src, dest, opts, cb)\n    })\n  } else if (opts.errorOnExist) {\n    return cb(new Error(`'${dest}' already exists`))\n  } else return cb()\n}\n\nfunction copyFile (srcStat, src, dest, opts, cb) {\n  if (typeof fs.copyFile === 'function') {\n    return fs.copyFile(src, dest, err => {\n      if (err) return cb(err)\n      return setDestModeAndTimestamps(srcStat, dest, opts, cb)\n    })\n  }\n  return copyFileFallback(srcStat, src, dest, opts, cb)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts, cb) {\n  const rs = fs.createReadStream(src)\n  rs.on('error', err => cb(err)).once('open', () => {\n    const ws = fs.createWriteStream(dest, { mode: srcStat.mode })\n    ws.on('error', err => cb(err))\n      .on('open', () => rs.pipe(ws))\n      .once('close', () => setDestModeAndTimestamps(srcStat, dest, opts, cb))\n  })\n}\n\nfunction setDestModeAndTimestamps (srcStat, dest, opts, cb) {\n  fs.chmod(dest, srcStat.mode, err => {\n    if (err) return cb(err)\n    if (opts.preserveTimestamps) {\n      return utimes(dest, srcStat.atime, srcStat.mtime, cb)\n    }\n    return cb()\n  })\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts, cb) {\n  if (destStat === notExist) return mkDirAndCopy(srcStat, src, dest, opts, cb)\n  if (destStat && !destStat.isDirectory()) {\n    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n  }\n  return copyDir(src, dest, opts, cb)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts, cb) {\n  fs.mkdir(dest, err => {\n    if (err) return cb(err)\n    copyDir(src, dest, opts, err => {\n      if (err) return cb(err)\n      return fs.chmod(dest, srcStat.mode, cb)\n    })\n  })\n}\n\nfunction copyDir (src, dest, opts, cb) {\n  fs.readdir(src, (err, items) => {\n    if (err) return cb(err)\n    return copyDirItems(items, src, dest, opts, cb)\n  })\n}\n\nfunction copyDirItems (items, src, dest, opts, cb) {\n  const item = items.pop()\n  if (!item) return cb()\n  return copyDirItem(items, item, src, dest, opts, cb)\n}\n\nfunction copyDirItem (items, item, src, dest, opts, cb) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  checkPaths(srcItem, destItem, (err, destStat) => {\n    if (err) return cb(err)\n    startCopy(destStat, srcItem, destItem, opts, err => {\n      if (err) return cb(err)\n      return copyDirItems(items, src, dest, opts, cb)\n    })\n  })\n}\n\nfunction onLink (destStat, src, dest, opts, cb) {\n  fs.readlink(src, (err, resolvedSrc) => {\n    if (err) return cb(err)\n\n    if (opts.dereference) {\n      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n    }\n\n    if (destStat === notExist) {\n      return fs.symlink(resolvedSrc, dest, cb)\n    } else {\n      fs.readlink(dest, (err, resolvedDest) => {\n        if (err) {\n          // dest exists and is a regular file or directory,\n          // Windows may throw UNKNOWN error. If dest already exists,\n          // fs throws error anyway, so no need to guard against it here.\n          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)\n          return cb(err)\n        }\n        if (opts.dereference) {\n          resolvedDest = path.resolve(process.cwd(), resolvedDest)\n        }\n        if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))\n        }\n\n        // do not copy if src is a subdir of dest since unlinking\n        // dest in this case would result in removing src contents\n        // and therefore a broken symlink would be created.\n        if (destStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))\n        }\n        return copyLink(resolvedSrc, dest, cb)\n      })\n    }\n  })\n}\n\nfunction copyLink (resolvedSrc, dest, cb) {\n  fs.unlink(dest, err => {\n    if (err) return cb(err)\n    return fs.symlink(resolvedSrc, dest, cb)\n  })\n}\n\n// return true if dest is a subdir of src, otherwise false.\nfunction isSrcSubdir (src, dest) {\n  const srcArray = path.resolve(src).split(path.sep)\n  const destArray = path.resolve(dest).split(path.sep)\n  return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true)\n}\n\nfunction checkStats (src, dest, cb) {\n  fs.stat(src, (err, srcStat) => {\n    if (err) return cb(err)\n    fs.stat(dest, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb(null, {srcStat, destStat: notExist})\n        return cb(err)\n      }\n      return cb(null, {srcStat, destStat})\n    })\n  })\n}\n\nfunction checkPaths (src, dest, cb) {\n  checkStats(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const {srcStat, destStat} = stats\n    if (destStat.ino && destStat.ino === srcStat.ino) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`))\n    }\n    return cb(null, destStat)\n  })\n}\n\nmodule.exports = copy\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst invalidWin32Path = require('./win32').invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirsSync (p, opts, made) {\n  if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    throw errInval\n  }\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  p = path.resolve(p)\n\n  try {\n    xfs.mkdirSync(p, mode)\n    made = made || p\n  } catch (err0) {\n    if (err0.code === 'ENOENT') {\n      if (path.dirname(p) === p) throw err0\n      made = mkdirsSync(path.dirname(p), opts, made)\n      mkdirsSync(p, opts, made)\n    } else {\n      // In the case of any other error, just see if there's a dir there\n      // already. If so, then hooray!  If not, then something is borked.\n      let stat\n      try {\n        stat = xfs.statSync(p)\n      } catch (err1) {\n        throw err0\n      }\n      if (!stat.isDirectory()) throw err0\n    }\n  }\n\n  return made\n}\n\nmodule.exports = mkdirsSync\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst invalidWin32Path = require('./win32').invalidWin32Path\n\nconst o777 = parseInt('0777', 8)\n\nfunction mkdirs (p, opts, callback, made) {\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = {}\n  } else if (!opts || typeof opts !== 'object') {\n    opts = { mode: opts }\n  }\n\n  if (process.platform === 'win32' && invalidWin32Path(p)) {\n    const errInval = new Error(p + ' contains invalid WIN32 path characters.')\n    errInval.code = 'EINVAL'\n    return callback(errInval)\n  }\n\n  let mode = opts.mode\n  const xfs = opts.fs || fs\n\n  if (mode === undefined) {\n    mode = o777 & (~process.umask())\n  }\n  if (!made) made = null\n\n  callback = callback || function () {}\n  p = path.resolve(p)\n\n  xfs.mkdir(p, mode, er => {\n    if (!er) {\n      made = made || p\n      return callback(null, made)\n    }\n    switch (er.code) {\n      case 'ENOENT':\n        if (path.dirname(p) === p) return callback(er)\n        mkdirs(path.dirname(p), opts, (er, made) => {\n          if (er) callback(er, made)\n          else mkdirs(p, opts, callback, made)\n        })\n        break\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        xfs.stat(p, (er2, stat) => {\n          // if the stat fails, then that's super weird.\n          // let the original error be the failure reason.\n          if (er2 || !stat.isDirectory()) callback(er, made)\n          else callback(null, made)\n        })\n        break\n    }\n  })\n}\n\nmodule.exports = mkdirs\n","'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\nconst mkdirpSync = require('../mkdirs').mkdirsSync\nconst utimesSync = require('../util/utimes.js').utimesMillisSync\n\nconst notExist = Symbol('notExist')\n\nfunction copySync (src, dest, opts) {\n  if (typeof opts === 'function') {\n    opts = {filter: opts}\n  }\n\n  opts = opts || {}\n  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now\n  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber\n\n  // Warn about using preserveTimestamps on 32-bit node\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\\n\n    see https://github.com/jprichardson/node-fs-extra/issues/269`)\n  }\n\n  const destStat = checkPaths(src, dest)\n\n  if (opts.filter && !opts.filter(src, dest)) return\n\n  const destParent = path.dirname(dest)\n  if (!fs.existsSync(destParent)) mkdirpSync(destParent)\n  return startCopy(destStat, src, dest, opts)\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter && !opts.filter(src, dest)) return\n  return getStats(destStat, src, dest, opts)\n}\n\nfunction getStats (destStat, src, dest, opts) {\n  const statSync = opts.dereference ? fs.statSync : fs.lstatSync\n  const srcStat = statSync(src)\n\n  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isFile() ||\n           srcStat.isCharacterDevice() ||\n           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)\n  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (destStat === notExist) return copyFile(srcStat, src, dest, opts)\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nfunction mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.overwrite) {\n    fs.unlinkSync(dest)\n    return copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new Error(`'${dest}' already exists`)\n  }\n}\n\nfunction copyFile (srcStat, src, dest, opts) {\n  if (typeof fs.copyFileSync === 'function') {\n    fs.copyFileSync(src, dest)\n    fs.chmodSync(dest, srcStat.mode)\n    if (opts.preserveTimestamps) {\n      return utimesSync(dest, srcStat.atime, srcStat.mtime)\n    }\n    return\n  }\n  return copyFileFallback(srcStat, src, dest, opts)\n}\n\nfunction copyFileFallback (srcStat, src, dest, opts) {\n  const BUF_LENGTH = 64 * 1024\n  const _buff = require('../util/buffer')(BUF_LENGTH)\n\n  const fdr = fs.openSync(src, 'r')\n  const fdw = fs.openSync(dest, 'w', srcStat.mode)\n  let pos = 0\n\n  while (pos < srcStat.size) {\n    const bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos)\n    fs.writeSync(fdw, _buff, 0, bytesRead)\n    pos += bytesRead\n  }\n\n  if (opts.preserveTimestamps) fs.futimesSync(fdw, srcStat.atime, srcStat.mtime)\n\n  fs.closeSync(fdr)\n  fs.closeSync(fdw)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (destStat === notExist) return mkDirAndCopy(srcStat, src, dest, opts)\n  if (destStat && !destStat.isDirectory()) {\n    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n  }\n  return copyDir(src, dest, opts)\n}\n\nfunction mkDirAndCopy (srcStat, src, dest, opts) {\n  fs.mkdirSync(dest)\n  copyDir(src, dest, opts)\n  return fs.chmodSync(dest, srcStat.mode)\n}\n\nfunction copyDir (src, dest, opts) {\n  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))\n}\n\nfunction copyDirItem (item, src, dest, opts) {\n  const srcItem = path.join(src, item)\n  const destItem = path.join(dest, item)\n  const destStat = checkPaths(srcItem, destItem)\n  return startCopy(destStat, srcItem, destItem, opts)\n}\n\nfunction onLink (destStat, src, dest, opts) {\n  let resolvedSrc = fs.readlinkSync(src)\n\n  if (opts.dereference) {\n    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)\n  }\n\n  if (destStat === notExist) {\n    return fs.symlinkSync(resolvedSrc, dest)\n  } else {\n    let resolvedDest\n    try {\n      resolvedDest = fs.readlinkSync(dest)\n    } catch (err) {\n      // dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)\n      throw err\n    }\n    if (opts.dereference) {\n      resolvedDest = path.resolve(process.cwd(), resolvedDest)\n    }\n    if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)\n    }\n\n    // prevent copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    if (fs.statSync(dest).isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)\n    }\n    return copyLink(resolvedSrc, dest)\n  }\n}\n\nfunction copyLink (resolvedSrc, dest) {\n  fs.unlinkSync(dest)\n  return fs.symlinkSync(resolvedSrc, dest)\n}\n\n// return true if dest is a subdir of src, otherwise false.\nfunction isSrcSubdir (src, dest) {\n  const srcArray = path.resolve(src).split(path.sep)\n  const destArray = path.resolve(dest).split(path.sep)\n  return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true)\n}\n\nfunction checkStats (src, dest) {\n  const srcStat = fs.statSync(src)\n  let destStat\n  try {\n    destStat = fs.statSync(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return {srcStat, destStat: notExist}\n    throw err\n  }\n  return {srcStat, destStat}\n}\n\nfunction checkPaths (src, dest) {\n  const {srcStat, destStat} = checkStats(src, dest)\n  if (destStat.ino && destStat.ino === srcStat.ino) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`)\n  }\n  return destStat\n}\n\nmodule.exports = copySync\n","'use strict'\n\nmodule.exports = clone\n\nfunction clone (obj) {\n  if (obj === null || typeof obj !== 'object')\n    return obj\n\n  if (obj instanceof Object)\n    var copy = { __proto__: obj.__proto__ }\n  else\n    var copy = Object.create(null)\n\n  Object.getOwnPropertyNames(obj).forEach(function (key) {\n    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))\n  })\n\n  return copy\n}\n","var Stream = require('stream').Stream\n\nmodule.exports = legacy\n\nfunction legacy (fs) {\n  return {\n    ReadStream: ReadStream,\n    WriteStream: WriteStream\n  }\n\n  function ReadStream (path, options) {\n    if (!(this instanceof ReadStream)) return new ReadStream(path, options);\n\n    Stream.call(this);\n\n    var self = this;\n\n    this.path = path;\n    this.fd = null;\n    this.readable = true;\n    this.paused = false;\n\n    this.flags = 'r';\n    this.mode = 438; /*=0666*/\n    this.bufferSize = 64 * 1024;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.encoding) this.setEncoding(this.encoding);\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.end === undefined) {\n        this.end = Infinity;\n      } else if ('number' !== typeof this.end) {\n        throw TypeError('end must be a Number');\n      }\n\n      if (this.start > this.end) {\n        throw new Error('start must be <= end');\n      }\n\n      this.pos = this.start;\n    }\n\n    if (this.fd !== null) {\n      process.nextTick(function() {\n        self._read();\n      });\n      return;\n    }\n\n    fs.open(this.path, this.flags, this.mode, function (err, fd) {\n      if (err) {\n        self.emit('error', err);\n        self.readable = false;\n        return;\n      }\n\n      self.fd = fd;\n      self.emit('open', fd);\n      self._read();\n    })\n  }\n\n  function WriteStream (path, options) {\n    if (!(this instanceof WriteStream)) return new WriteStream(path, options);\n\n    Stream.call(this);\n\n    this.path = path;\n    this.fd = null;\n    this.writable = true;\n\n    this.flags = 'w';\n    this.encoding = 'binary';\n    this.mode = 438; /*=0666*/\n    this.bytesWritten = 0;\n\n    options = options || {};\n\n    // Mixin options into this\n    var keys = Object.keys(options);\n    for (var index = 0, length = keys.length; index < length; index++) {\n      var key = keys[index];\n      this[key] = options[key];\n    }\n\n    if (this.start !== undefined) {\n      if ('number' !== typeof this.start) {\n        throw TypeError('start must be a Number');\n      }\n      if (this.start < 0) {\n        throw new Error('start must be >= zero');\n      }\n\n      this.pos = this.start;\n    }\n\n    this.busy = false;\n    this._queue = [];\n\n    if (this.fd === null) {\n      this._open = fs.open;\n      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);\n      this.flush();\n    }\n  }\n}\n","module.exports = require(\"constants\");","var constants = require('constants')\n\nvar origCwd = process.cwd\nvar cwd = null\n\nvar platform = process.env.GRACEFUL_FS_PLATFORM || process.platform\n\nprocess.cwd = function() {\n  if (!cwd)\n    cwd = origCwd.call(process)\n  return cwd\n}\ntry {\n  process.cwd()\n} catch (er) {}\n\nvar chdir = process.chdir\nprocess.chdir = function(d) {\n  cwd = null\n  chdir.call(process, d)\n}\n\nmodule.exports = patch\n\nfunction patch (fs) {\n  // (re-)implement some things that are known busted or missing.\n\n  // lchmod, broken prior to 0.6.2\n  // back-port the fix here.\n  if (constants.hasOwnProperty('O_SYMLINK') &&\n      process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {\n    patchLchmod(fs)\n  }\n\n  // lutimes implementation, or no-op\n  if (!fs.lutimes) {\n    patchLutimes(fs)\n  }\n\n  // https://github.com/isaacs/node-graceful-fs/issues/4\n  // Chown should not fail on einval or eperm if non-root.\n  // It should not fail on enosys ever, as this just indicates\n  // that a fs doesn't support the intended operation.\n\n  fs.chown = chownFix(fs.chown)\n  fs.fchown = chownFix(fs.fchown)\n  fs.lchown = chownFix(fs.lchown)\n\n  fs.chmod = chmodFix(fs.chmod)\n  fs.fchmod = chmodFix(fs.fchmod)\n  fs.lchmod = chmodFix(fs.lchmod)\n\n  fs.chownSync = chownFixSync(fs.chownSync)\n  fs.fchownSync = chownFixSync(fs.fchownSync)\n  fs.lchownSync = chownFixSync(fs.lchownSync)\n\n  fs.chmodSync = chmodFixSync(fs.chmodSync)\n  fs.fchmodSync = chmodFixSync(fs.fchmodSync)\n  fs.lchmodSync = chmodFixSync(fs.lchmodSync)\n\n  fs.stat = statFix(fs.stat)\n  fs.fstat = statFix(fs.fstat)\n  fs.lstat = statFix(fs.lstat)\n\n  fs.statSync = statFixSync(fs.statSync)\n  fs.fstatSync = statFixSync(fs.fstatSync)\n  fs.lstatSync = statFixSync(fs.lstatSync)\n\n  // if lchmod/lchown do not exist, then make them no-ops\n  if (!fs.lchmod) {\n    fs.lchmod = function (path, mode, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchmodSync = function () {}\n  }\n  if (!fs.lchown) {\n    fs.lchown = function (path, uid, gid, cb) {\n      if (cb) process.nextTick(cb)\n    }\n    fs.lchownSync = function () {}\n  }\n\n  // on Windows, A/V software can lock the directory, causing this\n  // to fail with an EACCES or EPERM if the directory contains newly\n  // created files.  Try again on failure, for up to 60 seconds.\n\n  // Set the timeout this long because some Windows Anti-Virus, such as Parity\n  // bit9, may lock files for up to a minute, causing npm package install\n  // failures. Also, take care to yield the scheduler. Windows scheduling gives\n  // CPU to a busy looping process, which can cause the program causing the lock\n  // contention to be starved of CPU by node, so the contention doesn't resolve.\n  if (platform === \"win32\") {\n    fs.rename = (function (fs$rename) { return function (from, to, cb) {\n      var start = Date.now()\n      var backoff = 0;\n      fs$rename(from, to, function CB (er) {\n        if (er\n            && (er.code === \"EACCES\" || er.code === \"EPERM\")\n            && Date.now() - start < 60000) {\n          setTimeout(function() {\n            fs.stat(to, function (stater, st) {\n              if (stater && stater.code === \"ENOENT\")\n                fs$rename(from, to, CB);\n              else\n                cb(er)\n            })\n          }, backoff)\n          if (backoff < 100)\n            backoff += 10;\n          return;\n        }\n        if (cb) cb(er)\n      })\n    }})(fs.rename)\n  }\n\n  // if read() returns EAGAIN, then just try it again.\n  fs.read = (function (fs$read) {\n    function read (fd, buffer, offset, length, position, callback_) {\n      var callback\n      if (callback_ && typeof callback_ === 'function') {\n        var eagCounter = 0\n        callback = function (er, _, __) {\n          if (er && er.code === 'EAGAIN' && eagCounter < 10) {\n            eagCounter ++\n            return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n          }\n          callback_.apply(this, arguments)\n        }\n      }\n      return fs$read.call(fs, fd, buffer, offset, length, position, callback)\n    }\n\n    // This ensures `util.promisify` works as it does for native `fs.read`.\n    read.__proto__ = fs$read\n    return read\n  })(fs.read)\n\n  fs.readSync = (function (fs$readSync) { return function (fd, buffer, offset, length, position) {\n    var eagCounter = 0\n    while (true) {\n      try {\n        return fs$readSync.call(fs, fd, buffer, offset, length, position)\n      } catch (er) {\n        if (er.code === 'EAGAIN' && eagCounter < 10) {\n          eagCounter ++\n          continue\n        }\n        throw er\n      }\n    }\n  }})(fs.readSync)\n\n  function patchLchmod (fs) {\n    fs.lchmod = function (path, mode, callback) {\n      fs.open( path\n             , constants.O_WRONLY | constants.O_SYMLINK\n             , mode\n             , function (err, fd) {\n        if (err) {\n          if (callback) callback(err)\n          return\n        }\n        // prefer to return the chmod error, if one occurs,\n        // but still try to close, and report closing errors if they occur.\n        fs.fchmod(fd, mode, function (err) {\n          fs.close(fd, function(err2) {\n            if (callback) callback(err || err2)\n          })\n        })\n      })\n    }\n\n    fs.lchmodSync = function (path, mode) {\n      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)\n\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      var threw = true\n      var ret\n      try {\n        ret = fs.fchmodSync(fd, mode)\n        threw = false\n      } finally {\n        if (threw) {\n          try {\n            fs.closeSync(fd)\n          } catch (er) {}\n        } else {\n          fs.closeSync(fd)\n        }\n      }\n      return ret\n    }\n  }\n\n  function patchLutimes (fs) {\n    if (constants.hasOwnProperty(\"O_SYMLINK\")) {\n      fs.lutimes = function (path, at, mt, cb) {\n        fs.open(path, constants.O_SYMLINK, function (er, fd) {\n          if (er) {\n            if (cb) cb(er)\n            return\n          }\n          fs.futimes(fd, at, mt, function (er) {\n            fs.close(fd, function (er2) {\n              if (cb) cb(er || er2)\n            })\n          })\n        })\n      }\n\n      fs.lutimesSync = function (path, at, mt) {\n        var fd = fs.openSync(path, constants.O_SYMLINK)\n        var ret\n        var threw = true\n        try {\n          ret = fs.futimesSync(fd, at, mt)\n          threw = false\n        } finally {\n          if (threw) {\n            try {\n              fs.closeSync(fd)\n            } catch (er) {}\n          } else {\n            fs.closeSync(fd)\n          }\n        }\n        return ret\n      }\n\n    } else {\n      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }\n      fs.lutimesSync = function () {}\n    }\n  }\n\n  function chmodFix (orig) {\n    if (!orig) return orig\n    return function (target, mode, cb) {\n      return orig.call(fs, target, mode, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chmodFixSync (orig) {\n    if (!orig) return orig\n    return function (target, mode) {\n      try {\n        return orig.call(fs, target, mode)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n\n  function chownFix (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid, cb) {\n      return orig.call(fs, target, uid, gid, function (er) {\n        if (chownErOk(er)) er = null\n        if (cb) cb.apply(this, arguments)\n      })\n    }\n  }\n\n  function chownFixSync (orig) {\n    if (!orig) return orig\n    return function (target, uid, gid) {\n      try {\n        return orig.call(fs, target, uid, gid)\n      } catch (er) {\n        if (!chownErOk(er)) throw er\n      }\n    }\n  }\n\n  function statFix (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options, cb) {\n      if (typeof options === 'function') {\n        cb = options\n        options = null\n      }\n      function callback (er, stats) {\n        if (stats) {\n          if (stats.uid < 0) stats.uid += 0x100000000\n          if (stats.gid < 0) stats.gid += 0x100000000\n        }\n        if (cb) cb.apply(this, arguments)\n      }\n      return options ? orig.call(fs, target, options, callback)\n        : orig.call(fs, target, callback)\n    }\n  }\n\n  function statFixSync (orig) {\n    if (!orig) return orig\n    // Older versions of Node erroneously returned signed integers for\n    // uid + gid.\n    return function (target, options) {\n      var stats = options ? orig.call(fs, target, options)\n        : orig.call(fs, target)\n      if (stats.uid < 0) stats.uid += 0x100000000\n      if (stats.gid < 0) stats.gid += 0x100000000\n      return stats;\n    }\n  }\n\n  // ENOSYS means that the fs doesn't support the op. Just ignore\n  // that, because it doesn't matter.\n  //\n  // if there's no getuid, or if getuid() is something other\n  // than 0, and the error is EINVAL or EPERM, then just ignore\n  // it.\n  //\n  // This specific case is a silent failure in cp, install, tar,\n  // and most other unix tools that manage permissions.\n  //\n  // When running as root, or if other types of errors are\n  // encountered, then it's strict.\n  function chownErOk (er) {\n    if (!er)\n      return true\n\n    if (er.code === \"ENOSYS\")\n      return true\n\n    var nonroot = !process.getuid || process.getuid() !== 0\n    if (nonroot) {\n      if (er.code === \"EINVAL\" || er.code === \"EPERM\")\n        return true\n    }\n\n    return false\n  }\n}\n","/*\n * logger.js: Core logger object used by winston.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar events = require('events'),\n    util = require('util'),\n    async = require('async'),\n    config = require('./config'),\n    common = require('./common'),\n    exception = require('./exception'),\n    Stream = require('stream').Stream;\n\nvar formatRegExp = /%[sdj%]/g;\n\n//\n// ### function Logger (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Logger object responsible\n// for persisting log messages and metadata to one or more transports.\n//\nvar Logger = exports.Logger = function (options) {\n  events.EventEmitter.call(this);\n  this.configure(options);\n};\n\n//\n// Inherit from `events.EventEmitter`.\n//\nutil.inherits(Logger, events.EventEmitter);\n\n//\n// ### function configure (options)\n// This will wholesale reconfigure this instance by:\n// 1. Resetting all transports. Older transports will be removed implicitly.\n// 2. Set all other options including levels, colors, rewriters, filters,\n//    exceptionHandlers, etc.\n//\nLogger.prototype.configure = function (options) {\n  var self = this;\n\n  //\n  // If we have already been setup with transports\n  // then remove them before proceeding.\n  //\n  if (Array.isArray(this._names) && this._names.length) {\n    this.clear();\n  }\n\n  options = options || {};\n  this.transports = {};\n  this._names     = [];\n\n  if (options.transports) {\n    options.transports.forEach(function (transport) {\n      self.add(transport, null, true);\n    });\n  }\n\n  //\n  // Set Levels and default logging level\n  //\n  this.padLevels = options.padLevels || false;\n  this.setLevels(options.levels);\n  if (options.colors) {\n    config.addColors(options.colors);\n  }\n\n  //\n  // Hoist other options onto this instance.\n  //\n  this.id          = options.id || null;\n  this.level       = options.level || 'info';\n  this.emitErrs    = options.emitErrs || false;\n  this.stripColors = options.stripColors || false;\n  this.exitOnError = typeof options.exitOnError !== 'undefined'\n    ? options.exitOnError\n    : true;\n\n  //\n  // Setup internal state as empty Objects even though it is\n  // defined lazily later to ensure a strong existential API contract.\n  //\n  this.exceptionHandlers = {};\n  this.profilers         = {};\n\n  ['rewriters', 'filters'].forEach(function (kind) {\n    self[kind] = Array.isArray(options[kind])\n      ? options[kind]\n      : [];\n  });\n\n  if (options.exceptionHandlers) {\n    this.handleExceptions(options.exceptionHandlers);\n  }\n};\n\n//\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\nLogger.prototype.log = function (level) {\n  var args = Array.prototype.slice.call(arguments, 1),\n      self = this,\n      transports;\n\n  while (args[args.length - 1] === null) {\n    args.pop();\n  }\n\n  //\n  // Determining what is `meta` and what are arguments for string interpolation\n  // turns out to be VERY tricky. e.g. in the cases like this:\n  //\n  //    logger.info('No interpolation symbols', 'ok', 'why', { meta: 'is-this' });\n  //\n  var callback  = typeof args[args.length - 1] === 'function'\n    ? args.pop()\n    : null;\n\n  //\n  // Handle errors appropriately.\n  //\n  function onError(err) {\n    if (callback) {\n      callback(err);\n    }\n    else if (self.emitErrs) {\n      self.emit('error', err);\n    }\n  }\n\n  if (this._names.length === 0) {\n    return onError(new Error('Cannot log with no transports.'));\n  }\n  else if (typeof self.levels[level] === 'undefined') {\n    return onError(new Error('Unknown log level: ' + level));\n  }\n\n  //\n  // If there are no transports that match the level\n  // then be eager and return. This could potentially be calculated\n  // during `setLevels` for more performance gains.\n  //\n  var targets = this._names.filter(function (name) {\n    var transport = self.transports[name];\n    return (transport.level && self.levels[transport.level] >= self.levels[level])\n      || (!transport.level && self.levels[self.level] >= self.levels[level]);\n  });\n\n  if (!targets.length) {\n    if (callback) { callback(); }\n    return;\n  }\n\n  //\n  // Determining what is `meta` and what are arguments for string interpolation\n  // turns out to be VERY tricky. e.g. in the cases like this:\n  //\n  //    logger.info('No interpolation symbols', 'ok', 'why', { meta: 'is-this' });\n  //\n  var msg, meta = {}, validMeta = false;\n  var hasFormat = args && args[0] && args[0].match && args[0].match(formatRegExp) !== null;\n  var tokens = (hasFormat) ? args[0].match(formatRegExp) : [];\n  var ptokens = tokens.filter(function(t) { return t === '%%' });\n  if (((args.length - 1) - (tokens.length - ptokens.length)) > 0 || args.length === 1) {\n    // last arg is meta\n    meta = args[args.length - 1] || args;\n    var metaType = Object.prototype.toString.call(meta);\n    validMeta = metaType === '[object Object]' ||\n      metaType === '[object Error]' || metaType === '[object Array]';\n    meta = validMeta ? args.pop() : {};\n  }\n  msg = util.format.apply(null, args);\n\n  //\n  // Respond to the callback.\n  //\n  function finish(err) {\n    if (callback) {\n      if (err) return callback(err);\n      callback(null, level, msg, meta);\n    }\n\n    callback = null;\n    if (!err) {\n      self.emit('logged', level, msg, meta);\n    }\n  }\n\n  // If we should pad for levels, do so\n  if (this.padLevels) {\n    msg = new Array(this.levelLength - level.length + 1).join(' ') + msg;\n  }\n\n  this.rewriters.forEach(function (rewriter) {\n    meta = rewriter(level, msg, meta, self);\n  });\n\n  this.filters.forEach(function(filter) {\n    var filtered = filter(level, msg, meta, self);\n    if (typeof filtered === 'string')\n      msg = filtered;\n    else {\n      msg = filtered.msg;\n      meta = filtered.meta;\n    }\n  });\n\n  //\n  // For consideration of terminal 'color\" programs like colors.js,\n  // which can add ANSI escape color codes to strings, we destyle the\n  // ANSI color escape codes when `this.stripColors` is set.\n  //\n  // see: http://en.wikipedia.org/wiki/ANSI_escape_code\n  //\n  if (this.stripColors) {\n    var code = /\\u001b\\[(\\d+(;\\d+)*)?m/g;\n    msg = ('' + msg).replace(code, '');\n  }\n\n  //\n  // Log for each transport and emit 'logging' event\n  //\n  function transportLog(name, next) {\n    var transport = self.transports[name];\n    transport.log(level, msg, meta, function (err) {\n      if (err) {\n        err.transport = transport;\n        finish(err);\n        return next();\n      }\n\n      self.emit('logging', transport, level, msg, meta);\n      next();\n    });\n  }\n\n  async.forEach(targets, transportLog, finish);\n  return this;\n};\n\n//\n// ### function query (options, callback)\n// #### @options {Object} Query options for this instance.\n// #### @callback {function} Continuation to respond to when complete.\n// Queries the all transports for this instance with the specified `options`.\n// This will aggregate each transport's results into one object containing\n// a property per transport.\n//\nLogger.prototype.query = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  var self = this,\n      options = options || {},\n      results = {},\n      query = common.clone(options.query) || {},\n      transports;\n\n  //\n  // Helper function to query a single transport\n  //\n  function queryTransport(transport, next) {\n    if (options.query) {\n      options.query = transport.formatQuery(query);\n    }\n\n    transport.query(options, function (err, results) {\n      if (err) {\n        return next(err);\n      }\n\n      next(null, transport.formatResults(results, options.format));\n    });\n  }\n\n  //\n  // Helper function to accumulate the results from\n  // `queryTransport` into the `results`.\n  //\n  function addResults(transport, next) {\n    queryTransport(transport, function (err, result) {\n      //\n      // queryTransport could potentially invoke the callback\n      // multiple times since Transport code can be unpredictable.\n      //\n      if (next) {\n        result = err || result;\n        if (result) {\n          results[transport.name] = result;\n        }\n\n        next();\n      }\n\n      next = null;\n    });\n  }\n\n  //\n  // If an explicit transport is being queried then\n  // respond with the results from only that transport\n  //\n  if (options.transport) {\n    options.transport = options.transport.toLowerCase();\n    return queryTransport(this.transports[options.transport], callback);\n  }\n\n  //\n  // Create a list of all transports for this instance.\n  //\n  transports = this._names.map(function (name) {\n    return self.transports[name];\n  }).filter(function (transport) {\n    return !!transport.query;\n  });\n\n  //\n  // Iterate over the transports in parallel setting the\n  // appropriate key in the `results`\n  //\n  async.forEach(transports, addResults, function () {\n    callback(null, results);\n  });\n};\n\n//\n// ### function stream (options)\n// #### @options {Object} Stream options for this instance.\n// Returns a log stream for all transports. Options object is optional.\n//\nLogger.prototype.stream = function (options) {\n  var self = this,\n      options = options || {},\n      out = new Stream,\n      streams = [],\n      transports;\n\n  if (options.transport) {\n    var transport = this.transports[options.transport];\n    delete options.transport;\n    if (transport && transport.stream) {\n      return transport.stream(options);\n    }\n  }\n\n  out._streams = streams;\n  out.destroy = function () {\n    var i = streams.length;\n    while (i--) streams[i].destroy();\n  };\n\n  //\n  // Create a list of all transports for this instance.\n  //\n  transports = this._names.map(function (name) {\n    return self.transports[name];\n  }).filter(function (transport) {\n    return !!transport.stream;\n  });\n\n  transports.forEach(function (transport) {\n    var stream = transport.stream(options);\n    if (!stream) return;\n\n    streams.push(stream);\n\n    stream.on('log', function (log) {\n      log.transport = log.transport || [];\n      log.transport.push(transport.name);\n      out.emit('log', log);\n    });\n\n    stream.on('error', function (err) {\n      err.transport = err.transport || [];\n      err.transport.push(transport.name);\n      out.emit('error', err);\n    });\n  });\n\n  return out;\n};\n\n//\n// ### function close ()\n// Cleans up resources (streams, event listeners) for all\n// transports associated with this instance (if necessary).\n//\nLogger.prototype.close = function () {\n  var self = this;\n\n  this._names.forEach(function (name) {\n    var transport = self.transports[name];\n    if (transport && transport.close) {\n      transport.close();\n    }\n  });\n\n  this.emit('close');\n};\n\n//\n// ### function handleExceptions ([tr0, tr1...] || tr0, tr1, ...)\n// Handles `uncaughtException` events for the current process by\n// ADDING any handlers passed in.\n//\nLogger.prototype.handleExceptions = function () {\n  var args = Array.prototype.slice.call(arguments),\n      handlers = [],\n      self = this;\n\n  args.forEach(function (a) {\n    if (Array.isArray(a)) {\n      handlers = handlers.concat(a);\n    }\n    else {\n      handlers.push(a);\n    }\n  });\n\n  this.exceptionHandlers = this.exceptionHandlers || {};\n  handlers.forEach(function (handler) {\n    self.exceptionHandlers[handler.name] = handler;\n  });\n\n  this._hnames = Object.keys(self.exceptionHandlers);\n\n  if (!this.catchExceptions) {\n    this.catchExceptions = this._uncaughtException.bind(this);\n    process.on('uncaughtException', this.catchExceptions);\n  }\n};\n\n//\n// ### function unhandleExceptions ()\n// Removes any handlers to `uncaughtException` events\n// for the current process\n//\nLogger.prototype.unhandleExceptions = function () {\n  var self = this;\n\n  if (this.catchExceptions) {\n    Object.keys(this.exceptionHandlers).forEach(function (name) {\n      var handler = self.exceptionHandlers[name];\n      if (handler.close) {\n        handler.close();\n      }\n    });\n\n    this.exceptionHandlers = {};\n    Object.keys(this.transports).forEach(function (name) {\n      var transport = self.transports[name];\n      if (transport.handleExceptions) {\n        transport.handleExceptions = false;\n      }\n    })\n\n    process.removeListener('uncaughtException', this.catchExceptions);\n    this.catchExceptions = false;\n  }\n};\n\n//\n// ### function add (transport, [options])\n// #### @transport {Transport} Prototype of the Transport object to add.\n// #### @options {Object} **Optional** Options for the Transport to add.\n// #### @instance {Boolean} **Optional** Value indicating if `transport` is already instantiated.\n// Adds a transport of the specified type to this instance.\n//\nLogger.prototype.add = function (transport, options, created) {\n  var instance = created ? transport : (new (transport)(options));\n\n  if (!instance.name && !instance.log) {\n    throw new Error('Unknown transport with no log() method');\n  }\n  else if (this.transports[instance.name]) {\n    throw new Error('Transport already attached: ' + instance.name + \", assign a different name\");\n  }\n\n  this.transports[instance.name] = instance;\n  this._names = Object.keys(this.transports);\n\n  //\n  // Listen for the `error` event on the new Transport\n  //\n  instance._onError = this._onError.bind(this, instance)\n  if (!created) {\n    instance.on('error', instance._onError);\n  }\n\n  //\n  // If this transport has `handleExceptions` set to `true`\n  // and we are not already handling exceptions, do so.\n  //\n  if (instance.handleExceptions && !this.catchExceptions) {\n    this.handleExceptions();\n  }\n\n  return this;\n};\n\n//\n// ### function clear ()\n// Remove all transports from this instance\n//\nLogger.prototype.clear = function () {\n  Object.keys(this.transports).forEach(function (name) {\n    this.remove({ name: name });\n  }, this);\n};\n\n//\n// ### function remove (transport)\n// #### @transport {Transport|String} Transport or Name to remove.\n// Removes a transport of the specified type from this instance.\n//\nLogger.prototype.remove = function (transport) {\n  var name = typeof transport !== 'string'\n    ? transport.name || transport.prototype.name\n    : transport;\n\n  if (!this.transports[name]) {\n    throw new Error('Transport ' + name + ' not attached to this instance');\n  }\n\n  var instance = this.transports[name];\n  delete this.transports[name];\n  this._names = Object.keys(this.transports);\n\n  if (instance.close) {\n    instance.close();\n  }\n\n  if (instance._onError) {\n    instance.removeListener('error', instance._onError);\n  }\n  return this;\n};\n\n//\n// ### function startTimer ()\n// Returns an object corresponding to a specific timing. When done\n// is called the timer will finish and log the duration. e.g.:\n//\n//    timer = winston.startTimer()\n//    setTimeout(function(){\n//      timer.done(\"Logging message\");\n//    }, 1000);\n//\nLogger.prototype.startTimer = function () {\n  return new ProfileHandler(this);\n};\n\n//\n// ### function profile (id, [msg, meta, callback])\n// #### @id {string} Unique id of the profiler\n// #### @msg {string} **Optional** Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} **Optional** Continuation to respond to when complete.\n// Tracks the time inbetween subsequent calls to this method\n// with the same `id` parameter. The second call to this method\n// will log the difference in milliseconds along with the message.\n//\nLogger.prototype.profile = function (id) {\n  var now = Date.now(), then, args,\n      msg, meta, callback;\n\n  if (this.profilers[id]) {\n    then = this.profilers[id];\n    delete this.profilers[id];\n\n    // Support variable arguments: msg, meta, callback\n    args     = Array.prototype.slice.call(arguments);\n    callback = typeof args[args.length - 1] === 'function' ? args.pop() : null;\n    meta     = typeof args[args.length - 1] === 'object' ? args.pop() : {};\n    msg      = args.length === 2 ? args[1] : id;\n\n    // Set the duration property of the metadata\n    meta.durationMs = now - then;\n    return this.info(msg, meta, callback);\n  }\n  else {\n    this.profilers[id] = now;\n  }\n\n  return this;\n};\n\n//\n// ### function setLevels (target)\n// #### @target {Object} Target levels to use on this instance\n// Sets the `target` levels specified on this instance.\n//\nLogger.prototype.setLevels = function (target) {\n  return common.setLevels(this, this.levels, target);\n};\n\n//\n// ### function cli ()\n// Configures this instance to have the default\n// settings for command-line interfaces: no timestamp,\n// colors enabled, padded output, and additional levels.\n//\nLogger.prototype.cli = function () {\n  this.padLevels = true;\n  this.setLevels(config.cli.levels);\n  config.addColors(config.cli.colors);\n\n  if (this.transports.console) {\n    this.transports.console.colorize = this.transports.console.colorize || true;\n    this.transports.console.timestamp = this.transports.console.timestamp || false;\n  }\n\n  return this;\n};\n\n//\n// ### @private function _uncaughtException (err)\n// #### @err {Error} Error to handle\n// Logs all relevant information around the `err` and\n// exits the current process.\n//\nLogger.prototype._uncaughtException = function (err) {\n  var self = this,\n      responded = false,\n      info = exception.getAllInfo(err),\n      handlers = this._getExceptionHandlers(),\n      timeout,\n      doExit;\n\n  //\n  // Calculate if we should exit on this error\n  //\n  doExit = typeof this.exitOnError === 'function'\n    ? this.exitOnError(err)\n    : this.exitOnError;\n\n  function logAndWait(transport, next) {\n    transport.logException('uncaughtException: ' + (err.message || err), info, next, err);\n  }\n\n  function gracefulExit() {\n    if (doExit && !responded) {\n      //\n      // Remark: Currently ignoring any exceptions from transports\n      //         when catching uncaught exceptions.\n      //\n      clearTimeout(timeout);\n      responded = true;\n      process.exit(1);\n    }\n  }\n\n  if (!handlers || handlers.length === 0) {\n    return gracefulExit();\n  }\n\n  //\n  // Log to all transports and allow the operation to take\n  // only up to `3000ms`.\n  //\n  async.forEach(handlers, logAndWait, gracefulExit);\n  if (doExit) {\n    timeout = setTimeout(gracefulExit, 3000);\n  }\n};\n\n//\n// ### @private function _getExceptionHandlers ()\n// Returns the list of transports and exceptionHandlers\n// for this instance.\n//\nLogger.prototype._getExceptionHandlers = function () {\n  var self = this;\n\n  return this._hnames.map(function (name) {\n    return self.exceptionHandlers[name];\n  }).concat(this._names.map(function (name) {\n    return self.transports[name].handleExceptions && self.transports[name];\n  })).filter(Boolean);\n};\n\n//\n// ### @private function _onError (transport, err)\n// #### @transport {Object} Transport on which the error occured\n// #### @err {Error} Error that occurred on the transport\n// Bubbles the error, `err`, that occured on the specified `transport`\n// up from this instance if `emitErrs` has been set.\n//\nLogger.prototype._onError = function (transport, err) {\n  if (this.emitErrs) {\n    this.emit('error', err, transport);\n  }\n};\n\n//\n// ### @private ProfileHandler\n// Constructor function for the ProfileHandler instance used by\n// `Logger.prototype.startTimer`. When done is called the timer\n// will finish and log the duration.\n//\nfunction ProfileHandler(logger) {\n  this.logger = logger;\n  this.start = Date.now();\n}\n\n//\n// ### function done (msg)\n// Ends the current timer (i.e. ProfileHandler) instance and\n// logs the `msg` along with the duration since creation.\n//\nProfileHandler.prototype.done = function (msg) {\n  var args     = Array.prototype.slice.call(arguments),\n      callback = typeof args[args.length - 1] === 'function' ? args.pop() : null,\n      meta     = typeof args[args.length - 1] === 'object' ? args.pop() : {};\n\n  meta.duration = (Date.now()) - this.start + 'ms';\n  return this.logger.info(msg, meta, callback);\n};\n","/*\n * container.js: Inversion of control container for winston logger instances\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar common = require('./common'),\n    winston = require('../winston'),\n    extend = require('util')._extend;\n\n//\n// ### function Container (options)\n// #### @options {Object} Default pass-thru options for Loggers\n// Constructor function for the Container object responsible for managing\n// a set of `winston.Logger` instances based on string ids.\n//\nvar Container = exports.Container = function (options) {\n  this.loggers = {};\n  this.options = options || {};\n  this.default = {\n    transports: [\n      new winston.transports.Console({\n        level: 'silly',\n        colorize: false\n      })\n    ]\n  }\n};\n\n//\n// ### function get / add (id, options)\n// #### @id {string} Id of the Logger to get\n// #### @options {Object} **Optional** Options for the Logger instance\n// Retreives a `winston.Logger` instance for the specified `id`. If\n// an instance does not exist, one is created.\n//\nContainer.prototype.get = Container.prototype.add = function (id, options) {\n  var self = this,\n      existing;\n\n  if (!this.loggers[id]) {\n    //\n    // Remark: Simple shallow clone for configuration options in case we pass in\n    // instantiated protoypal objects\n    //\n    options = extend({}, options || this.options || this.default);\n    existing = options.transports || this.options.transports;\n    //\n    // Remark: Make sure if we have an array of transports we slice it to make copies\n    // of those references.\n    //\n    options.transports = existing ? existing.slice() : [];\n\n    if (options.transports.length === 0 && (!options || !options['console'])) {\n      options.transports.push(this.default.transports[0]);\n    }\n\n    Object.keys(options).forEach(function (key) {\n      if (key === 'transports') {\n        return;\n      }\n\n      var name = common.capitalize(key);\n\n      if (!winston.transports[name]) {\n        throw new Error('Cannot add unknown transport: ' + name);\n      }\n\n      var namedOptions = options[key];\n      namedOptions.id = id;\n      options.transports.push(new (winston.transports[name])(namedOptions));\n    });\n\n    options.id = id;\n    this.loggers[id] = new winston.Logger(options);\n\n    this.loggers[id].on('close', function () {\n        self._delete(id);\n    });\n  }\n\n  return this.loggers[id];\n};\n\n//\n// ### function close (id)\n// #### @id {string} **Optional** Id of the Logger instance to find\n// Returns a boolean value indicating if this instance\n// has a logger with the specified `id`.\n//\nContainer.prototype.has = function (id) {\n  return !!this.loggers[id];\n};\n\n//\n// ### function close (id)\n// #### @id {string} **Optional** Id of the Logger instance to close\n// Closes a `Logger` instance with the specified `id` if it exists.\n// If no `id` is supplied then all Loggers are closed.\n//\nContainer.prototype.close = function (id) {\n  var self = this;\n\n  function _close (id) {\n    if (!self.loggers[id]) {\n      return;\n    }\n\n    self.loggers[id].close();\n    self._delete(id);\n  }\n\n  return id ? _close(id) : Object.keys(this.loggers).forEach(function (id) {\n    _close(id);\n  });\n};\n\n//\n// ### @private function _delete (id)\n// #### @id {string} Id of the Logger instance to delete from container\n// Deletes a `Logger` instance with the specified `id`.\n//\nContainer.prototype._delete = function (id) {\n    delete this.loggers[id];\n}\n\n","exports.get = function(belowFn) {\n  var oldLimit = Error.stackTraceLimit;\n  Error.stackTraceLimit = Infinity;\n\n  var dummyObject = {};\n\n  var v8Handler = Error.prepareStackTrace;\n  Error.prepareStackTrace = function(dummyObject, v8StackTrace) {\n    return v8StackTrace;\n  };\n  Error.captureStackTrace(dummyObject, belowFn || exports.get);\n\n  var v8StackTrace = dummyObject.stack;\n  Error.prepareStackTrace = v8Handler;\n  Error.stackTraceLimit = oldLimit;\n\n  return v8StackTrace;\n};\n\nexports.parse = function(err) {\n  if (!err.stack) {\n    return [];\n  }\n\n  var self = this;\n  var lines = err.stack.split('\\n').slice(1);\n\n  return lines\n    .map(function(line) {\n      if (line.match(/^\\s*[-]{4,}$/)) {\n        return self._createParsedCallSite({\n          fileName: line,\n          lineNumber: null,\n          functionName: null,\n          typeName: null,\n          methodName: null,\n          columnNumber: null,\n          'native': null,\n        });\n      }\n\n      var lineMatch = line.match(/at (?:(.+)\\s+\\()?(?:(.+?):(\\d+)(?::(\\d+))?|([^)]+))\\)?/);\n      if (!lineMatch) {\n        return;\n      }\n\n      var object = null;\n      var method = null;\n      var functionName = null;\n      var typeName = null;\n      var methodName = null;\n      var isNative = (lineMatch[5] === 'native');\n\n      if (lineMatch[1]) {\n        functionName = lineMatch[1];\n        var methodStart = functionName.lastIndexOf('.');\n        if (functionName[methodStart-1] == '.')\n          methodStart--;\n        if (methodStart > 0) {\n          object = functionName.substr(0, methodStart);\n          method = functionName.substr(methodStart + 1);\n          var objectEnd = object.indexOf('.Module');\n          if (objectEnd > 0) {\n            functionName = functionName.substr(objectEnd + 1);\n            object = object.substr(0, objectEnd);\n          }\n        }\n        typeName = null;\n      }\n\n      if (method) {\n        typeName = object;\n        methodName = method;\n      }\n\n      if (method === '<anonymous>') {\n        methodName = null;\n        functionName = null;\n      }\n\n      var properties = {\n        fileName: lineMatch[2] || null,\n        lineNumber: parseInt(lineMatch[3], 10) || null,\n        functionName: functionName,\n        typeName: typeName,\n        methodName: methodName,\n        columnNumber: parseInt(lineMatch[4], 10) || null,\n        'native': isNative,\n      };\n\n      return self._createParsedCallSite(properties);\n    })\n    .filter(function(callSite) {\n      return !!callSite;\n    });\n};\n\nfunction CallSite(properties) {\n  for (var property in properties) {\n    this[property] = properties[property];\n  }\n}\n\nvar strProperties = [\n  'this',\n  'typeName',\n  'functionName',\n  'methodName',\n  'fileName',\n  'lineNumber',\n  'columnNumber',\n  'function',\n  'evalOrigin'\n];\nvar boolProperties = [\n  'topLevel',\n  'eval',\n  'native',\n  'constructor'\n];\nstrProperties.forEach(function (property) {\n  CallSite.prototype[property] = null;\n  CallSite.prototype['get' + property[0].toUpperCase() + property.substr(1)] = function () {\n    return this[property];\n  }\n});\nboolProperties.forEach(function (property) {\n  CallSite.prototype[property] = false;\n  CallSite.prototype['is' + property[0].toUpperCase() + property.substr(1)] = function () {\n    return this[property];\n  }\n});\n\nexports._createParsedCallSite = function(properties) {\n  return new CallSite(properties);\n};\n","var events = require('events'),\n    util = require('util'),\n    common = require('../common'),\n    Transport = require('./transport').Transport;\n\n//\n// ### function Memory (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Memory transport object responsible\n// for persisting log messages and metadata to a memory array of messages.\n//\nvar Memory = exports.Memory = function (options) {\n  Transport.call(this, options);\n  options = options || {};\n\n  this.errorOutput = [];\n  this.writeOutput = [];\n\n  this.json        = options.json        || false;\n  this.colorize    = options.colorize    || false;\n  this.prettyPrint = options.prettyPrint || false;\n  this.timestamp   = typeof options.timestamp !== 'undefined' ? options.timestamp : false;\n  this.showLevel   = options.showLevel === undefined ? true : options.showLevel;\n  this.label       = options.label       || null;\n  this.depth       = options.depth       || null;\n\n  if (this.json) {\n    this.stringify = options.stringify || function (obj) {\n      return JSON.stringify(obj, null, 2);\n    };\n  }\n};\n\n//\n// Inherit from `winston.Transport`.\n//\nutil.inherits(Memory, Transport);\n\n//\n// Expose the name of this Transport on the prototype\n//\nMemory.prototype.name = 'memory';\n\n//\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\nMemory.prototype.log = function (level, msg, meta, callback) {\n  if (this.silent) {\n    return callback(null, true);\n  }\n\n  var self = this,\n      output;\n\n  output = common.log({\n    colorize:    this.colorize,\n    json:        this.json,\n    level:       level,\n    message:     msg,\n    meta:        meta,\n    stringify:   this.stringify,\n    timestamp:   this.timestamp,\n    prettyPrint: this.prettyPrint,\n    raw:         this.raw,\n    label:       this.label,\n    depth:       this.depth,\n    formatter:   this.formatter,\n    humanReadableUnhandledException: this.humanReadableUnhandledException\n  });\n\n  if (level === 'error' || level === 'debug') {\n    this.errorOutput.push(output);\n  } else {\n    this.writeOutput.push(output);\n  }\n\n  self.emit('logged');\n  callback(null, true);\n};\n\nMemory.prototype.clearLogs = function () {\n  this.errorOutput = [];\n  this.writeOutput = [];\n};\n","module.exports = require(\"https\");","module.exports = require(\"http\");","var util = require('util'),\n    winston = require('../../winston'),\n    http = require('http'),\n    https = require('https'),\n    Stream = require('stream').Stream,\n    Transport = require('./transport').Transport;\n\n//\n// ### function Http (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Http transport object responsible\n// for persisting log messages and metadata to a terminal or TTY.\n//\nvar Http = exports.Http = function (options) {\n  Transport.call(this, options);\n  options = options || {};\n\n  this.name = 'http';\n  this.ssl = !!options.ssl;\n  this.host = options.host || 'localhost';\n  this.port = options.port;\n  this.auth = options.auth;\n  this.path = options.path || '';\n  this.agent = options.agent;\n\n  if (!this.port) {\n    this.port = this.ssl ? 443 : 80;\n  }\n};\n\nutil.inherits(Http, winston.Transport);\n\n//\n// Expose the name of this Transport on the prototype\n//\nHttp.prototype.name = 'http';\n\n//\n// ### function _request (options, callback)\n// #### @callback {function} Continuation to respond to when complete.\n// Make a request to a winstond server or any http server which can\n// handle json-rpc.\n//\nHttp.prototype._request = function (options, callback) {\n  options = options || {};\n\n  var auth = options.auth || this.auth,\n      path = options.path || this.path || '',\n      req;\n\n  delete options.auth;\n  delete options.path;\n\n  // Prepare options for outgoing HTTP request\n  req = (this.ssl ? https : http).request({\n    host: this.host,\n    port: this.port,\n    path: '/' + path.replace(/^\\//, ''),\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    agent: this.agent,\n    auth: (auth) ? auth.username + ':' + auth.password : ''\n  });\n\n  req.on('error', callback);\n  req.on('response', function (res) {\n    var body = '';\n\n    res.on('data', function (chunk) {\n      body += chunk;\n    });\n\n    res.on('end', function () {\n      callback(null, res, body);\n    });\n\n    res.resume();\n  });\n\n  req.end(new Buffer(JSON.stringify(options), 'utf8'));\n};\n\n//\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\nHttp.prototype.log = function (level, msg, meta, callback) {\n  var self = this;\n\n  if (typeof meta === 'function') {\n    callback = meta;\n    meta = {};\n  }\n\n  var options = {\n    method: 'collect',\n    params: {\n      level: level,\n      message: msg,\n      meta: meta\n    }\n  };\n\n  if (meta) {\n    if (meta.path) {\n      options.path = meta.path;\n      delete meta.path;\n    }\n\n    if (meta.auth) {\n      options.auth = meta.auth;\n      delete meta.auth;\n    }\n  }\n\n  this._request(options, function (err, res) {\n    if (res && res.statusCode !== 200) {\n      err = new Error('HTTP Status Code: ' + res.statusCode);\n    }\n\n    if (err) return callback(err);\n\n    // TODO: emit 'logged' correctly,\n    // keep track of pending logs.\n    self.emit('logged');\n\n    if (callback) callback(null, true);\n  });\n};\n\n//\n// ### function query (options, callback)\n// #### @options {Object} Loggly-like query options for this instance.\n// #### @callback {function} Continuation to respond to when complete.\n// Query the transport. Options object is optional.\n//\nHttp.prototype.query = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  var self = this,\n      options = this.normalizeQuery(options);\n\n  options = {\n    method: 'query',\n    params: options\n  };\n\n  if (options.params.path) {\n    options.path = options.params.path;\n    delete options.params.path;\n  }\n\n  if (options.params.auth) {\n    options.auth = options.params.auth;\n    delete options.params.auth;\n  }\n\n  this._request(options, function (err, res, body) {\n    if (res && res.statusCode !== 200) {\n      err = new Error('HTTP Status Code: ' + res.statusCode);\n    }\n\n    if (err) return callback(err);\n\n    if (typeof body === 'string') {\n      try {\n        body = JSON.parse(body);\n      } catch (e) {\n        return callback(e);\n      }\n    }\n\n    callback(null, body);\n  });\n};\n\n//\n// ### function stream (options)\n// #### @options {Object} Stream options for this instance.\n// Returns a log stream for this transport. Options object is optional.\n//\nHttp.prototype.stream = function (options) {\n  options = options || {};\n  \n  var self = this,\n      stream = new Stream,\n      req,\n      buff;\n\n  stream.destroy = function () {\n    req.destroy();\n  };\n\n  options = {\n    method: 'stream',\n    params: options\n  };\n\n  if (options.params.path) {\n    options.path = options.params.path;\n    delete options.params.path;\n  }\n\n  if (options.params.auth) {\n    options.auth = options.params.auth;\n    delete options.params.auth;\n  }\n\n  req = this._request(options);\n  buff = '';\n\n  req.on('data', function (data) {\n    var data = (buff + data).split(/\\n+/),\n        l = data.length - 1,\n        i = 0;\n\n    for (; i < l; i++) {\n      try {\n        stream.emit('log', JSON.parse(data[i]));\n      } catch (e) {\n        stream.emit('error', e);\n      }\n    }\n\n    buff = data[l];\n  });\n\n  req.on('error', function (err) {\n    stream.emit('error', err);\n  });\n\n  return stream;\n};\n","var stream = require('stream')\n\n\nfunction isStream (obj) {\n  return obj instanceof stream.Stream\n}\n\n\nfunction isReadable (obj) {\n  return isStream(obj) && typeof obj._read == 'function' && typeof obj._readableState == 'object'\n}\n\n\nfunction isWritable (obj) {\n  return isStream(obj) && typeof obj._write == 'function' && typeof obj._writableState == 'object'\n}\n\n\nfunction isDuplex (obj) {\n  return isReadable(obj) && isWritable(obj)\n}\n\n\nmodule.exports            = isStream\nmodule.exports.isReadable = isReadable\nmodule.exports.isWritable = isWritable\nmodule.exports.isDuplex   = isDuplex\n","/*\n * file.js: Transport for outputting to a local log file\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar events = require('events'),\n    fs = require('fs'),\n    path = require('path'),\n    util = require('util'),\n    async = require('async'),\n    zlib = require('zlib'),\n    common = require('../common'),\n    Transport = require('./transport').Transport,\n    isWritable = require('isstream').isWritable,\n    Stream = require('stream').Stream,\n    os = require('os');\n\n//\n// ### function File (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the File transport object responsible\n// for persisting log messages and metadata to one or more files.\n//\nvar File = exports.File = function (options) {\n  var self = this;\n  Transport.call(this, options);\n\n  //\n  // Helper function which throws an `Error` in the event\n  // that any of the rest of the arguments is present in `options`.\n  //\n  function throwIf (target /*, illegal... */) {\n    Array.prototype.slice.call(arguments, 1).forEach(function (name) {\n      if (options[name]) {\n        throw new Error('Cannot set ' + name + ' and ' + target + 'together');\n      }\n    });\n  }\n\n  if (options.filename || options.dirname) {\n    throwIf('filename or dirname', 'stream');\n    this._basename = this.filename = options.filename\n      ? path.basename(options.filename)\n      : 'winston.log';\n\n    this.dirname = options.dirname || path.dirname(options.filename);\n    this.options = options.options || { flags: 'a' };\n\n    //\n    // \"24 bytes\" is maybe a good value for logging lines.\n    //\n    this.options.highWaterMark = this.options.highWaterMark || 24;\n  }\n  else if (options.stream) {\n    throwIf('stream', 'filename', 'maxsize');\n    this._stream = options.stream;\n    this._isStreams2 = isWritable(this._stream);\n    this._stream.on('error', function(error){\n      self.emit('error', error);\n    });\n    //\n    // We need to listen for drain events when\n    // write() returns false. This can make node\n    // mad at times.\n    //\n    this._stream.setMaxListeners(Infinity);\n  }\n  else {\n    throw new Error('Cannot log to file without filename or stream.');\n  }\n\n  this.json        = options.json !== false;\n  this.logstash    = options.logstash    || false;\n  this.colorize    = options.colorize    || false;\n  this.maxsize     = options.maxsize     || null;\n  this.rotationFormat = options.rotationFormat || false;\n  this.zippedArchive = options.zippedArchive || false;\n  this.maxFiles    = options.maxFiles    || null;\n  this.prettyPrint = options.prettyPrint || false;\n  this.label       = options.label       || null;\n  this.timestamp   = options.timestamp != null ? options.timestamp : true;\n  this.eol         = options.eol || os.EOL;\n  this.tailable    = options.tailable    || false;\n  this.depth       = options.depth       || null;\n  this.showLevel   = options.showLevel === undefined ? true : options.showLevel;\n  this.maxRetries  = options.maxRetries || 2;\n\n  if (this.json) {\n    this.stringify = options.stringify;\n  }\n\n  //\n  // Internal state variables representing the number\n  // of files this instance has created and the current\n  // size (in bytes) of the current logfile.\n  //\n  this._size     = 0;\n  this._created  = 0;\n  this._buffer   = [];\n  this._draining = false;\n  this._opening  = false;\n  this._failures = 0;\n  this._archive = null;\n};\n\n//\n// Inherit from `winston.Transport`.\n//\nutil.inherits(File, Transport);\n\n//\n// Expose the name of this Transport on the prototype\n//\nFile.prototype.name = 'file';\n\n//\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\nFile.prototype.log = function (level, msg, meta, callback) {\n  if (this.silent) {\n    return callback(null, true);\n  }\n\n  //\n  // If failures exceeds maxRetries then we can't access the\n  // stream. In this case we need to perform a noop and return\n  // an error.\n  //\n  if (this._failures >= this.maxRetries) {\n    return callback(new Error('Transport is in a failed state.'));\n  }\n\n  var self = this;\n\n  if (typeof msg !== 'string') {\n    msg = '' + msg;\n  }\n\n  var output = common.log({\n    level:       level,\n    message:     msg,\n    meta:        meta,\n    json:        this.json,\n    logstash:    this.logstash,\n    colorize:    this.colorize,\n    prettyPrint: this.prettyPrint,\n    timestamp:   this.timestamp,\n    showLevel:   this.showLevel,\n    stringify:   this.stringify,\n    label:       this.label,\n    depth:       this.depth,\n    formatter:   this.formatter,\n    humanReadableUnhandledException: this.humanReadableUnhandledException\n  });\n\n  if (typeof output === 'string') {\n    output += this.eol;\n  }\n\n  if (!this.filename) {\n    //\n    // If there is no `filename` on this instance then it was configured\n    // with a raw `WriteableStream` instance and we should not perform any\n    // size restrictions.\n    //\n    this._write(output, callback);\n    this._size += output.length;\n    this._lazyDrain();\n  }\n  else {\n    this.open(function (err) {\n      if (err) {\n        //\n        // If there was an error enqueue the message\n        //\n        return self._buffer.push([output, callback]);\n      }\n\n      self._write(output, callback);\n      self._size += output.length;\n      self._lazyDrain();\n    });\n  }\n};\n\n//\n// ### function _write (data, cb)\n// #### @data {String|Buffer} Data to write to the instance's stream.\n// #### @cb {function} Continuation to respond to when complete.\n// Write to the stream, ensure execution of a callback on completion.\n//\nFile.prototype._write = function(data, callback) {\n  if (this._isStreams2) {\n    this._stream.write(data);\n    return callback && process.nextTick(function () {\n      callback(null, true);\n    });\n  }\n\n  // If this is a file write stream, we could use the builtin\n  // callback functionality, however, the stream is not guaranteed\n  // to be an fs.WriteStream.\n  var ret = this._stream.write(data);\n  if (!callback) return;\n  if (ret === false) {\n    return this._stream.once('drain', function() {\n      callback(null, true);\n    });\n  }\n  process.nextTick(function () {\n    callback(null, true);\n  });\n};\n\n//\n// ### function query (options, callback)\n// #### @options {Object} Loggly-like query options for this instance.\n// #### @callback {function} Continuation to respond to when complete.\n// Query the transport. Options object is optional.\n//\nFile.prototype.query = function (options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  var file = path.join(this.dirname, this.filename),\n      options = this.normalizeQuery(options),\n      buff = '',\n      results = [],\n      row = 0;\n\n  var stream = fs.createReadStream(file, {\n    encoding: 'utf8'\n  });\n\n  stream.on('error', function (err) {\n    if (stream.readable) {\n      stream.destroy();\n    }\n    if (!callback) return;\n    return err.code !== 'ENOENT'\n      ? callback(err)\n      : callback(null, results);\n  });\n\n  stream.on('data', function (data) {\n    var data = (buff + data).split(/\\n+/),\n        l = data.length - 1,\n        i = 0;\n\n    for (; i < l; i++) {\n      if (!options.start || row >= options.start) {\n        add(data[i]);\n      }\n      row++;\n    }\n\n    buff = data[l];\n  });\n\n  stream.on('close', function () {\n    if (buff) add(buff, true);\n    if (options.order === 'desc') {\n      results = results.reverse();\n    }\n    if (callback) callback(null, results);\n  });\n\n  function add(buff, attempt) {\n    try {\n      var log = JSON.parse(buff);\n      if (check(log)) push(log);\n    } catch (e) {\n      if (!attempt) {\n        stream.emit('error', e);\n      }\n    }\n  }\n\n  function push(log) {\n    if (options.rows && results.length >= options.rows\n        && options.order != 'desc') {\n      if (stream.readable) {\n        stream.destroy();\n      }\n      return;\n    }\n\n    if (options.fields) {\n      var obj = {};\n      options.fields.forEach(function (key) {\n        obj[key] = log[key];\n      });\n      log = obj;\n    }\n\n    if (options.order === 'desc') {\n      if (results.length >= options.rows) {\n        results.shift();\n      }\n    }\n    results.push(log);\n  }\n\n  function check(log) {\n    if (!log) return;\n\n    if (typeof log !== 'object') return;\n\n    var time = new Date(log.timestamp);\n    if ((options.from && time < options.from)\n        || (options.until && time > options.until)) {\n      return;\n    }\n\n    return true;\n  }\n};\n\n//\n// ### function stream (options)\n// #### @options {Object} Stream options for this instance.\n// Returns a log stream for this transport. Options object is optional.\n//\nFile.prototype.stream = function (options) {\n  var file = path.join(this.dirname, this.filename),\n      options = options || {},\n      stream = new Stream;\n\n  var tail = {\n    file: file,\n    start: options.start\n  };\n\n  stream.destroy = common.tailFile(tail, function (err, line) {\n\n    if(err){\n      return stream.emit('error',err);\n    }\n\n    try {\n      stream.emit('data', line);\n      line = JSON.parse(line);\n      stream.emit('log', line);\n    } catch (e) {\n      stream.emit('error', e);\n    }\n  });\n\n  return stream;\n};\n\n//\n// ### function open (callback)\n// #### @callback {function} Continuation to respond to when complete\n// Checks to see if a new file needs to be created based on the `maxsize`\n// (if any) and the current size of the file used.\n//\nFile.prototype.open = function (callback) {\n  if (this.opening) {\n    //\n    // If we are already attempting to open the next\n    // available file then respond with a value indicating\n    // that the message should be buffered.\n    //\n    return callback(true);\n  }\n  else if (!this._stream || (this.maxsize && this._size >= this.maxsize)) {\n    //\n    // If we dont have a stream or have exceeded our size, then create\n    // the next stream and respond with a value indicating that\n    // the message should be buffered.\n    //\n    callback(true);\n    return this._createStream();\n  }\n\n  this._archive = this.zippedArchive ? this._stream.path : null;\n\n  //\n  // Otherwise we have a valid (and ready) stream.\n  //\n  callback();\n};\n\n//\n// ### function close ()\n// Closes the stream associated with this instance.\n//\nFile.prototype.close = function () {\n  var self = this;\n\n  if (this._stream) {\n    this._stream.end();\n    this._stream.destroySoon();\n\n    this._stream.once('finish', function () {\n      self.emit('flush');\n      self.emit('closed');\n    });\n  }\n};\n\n//\n// ### function flush ()\n// Flushes any buffered messages to the current `stream`\n// used by this instance.\n//\nFile.prototype.flush = function () {\n  var self = this;\n\n  // If nothing to flush, there will be no \"flush\" event from native stream\n  // Thus, the \"open\" event will never be fired (see _createStream.createAndFlush function)\n  // That means, self.opening will never set to false and no logs will be written to disk\n  if (!this._buffer.length) {\n    return self.emit('flush');\n  }\n\n  //\n  // Iterate over the `_buffer` of enqueued messaged\n  // and then write them to the newly created stream.\n  //\n  this._buffer.forEach(function (item) {\n    var str = item[0],\n        callback = item[1];\n\n    process.nextTick(function () {\n      self._write(str, callback);\n      self._size += str.length;\n    });\n  });\n\n  //\n  // Quickly truncate the `_buffer` once the write operations\n  // have been started\n  //\n  self._buffer.length = 0;\n\n  //\n  // When the stream has drained we have flushed\n  // our buffer.\n  //\n  self._stream.once('drain', function () {\n    self.emit('flush');\n    self.emit('logged');\n  });\n};\n\n//\n// ### @private function _createStream ()\n// Attempts to open the next appropriate file for this instance\n// based on the common state (such as `maxsize` and `_basename`).\n//\nFile.prototype._createStream = function () {\n  var self = this;\n  this.opening = true;\n\n  (function checkFile (target) {\n    var fullname = path.join(self.dirname, target);\n\n    //\n    // Creates the `WriteStream` and then flushes any\n    // buffered messages.\n    //\n    function createAndFlush (size) {\n      if (self._stream) {\n        self._stream.end();\n        self._stream.destroySoon();\n      }\n\n      self._size = size;\n      self.filename = target;\n      self._stream = fs.createWriteStream(fullname, self.options);\n      self._isStreams2 = isWritable(self._stream);\n      self._stream.on('error', function(error){\n        if (self._failures < self.maxRetries) {\n          self._createStream();\n          self._failures++;\n        }\n        else {\n          self.emit('error', error);\n        }\n      });\n      //\n      // We need to listen for drain events when\n      // write() returns false. This can make node\n      // mad at times.\n      //\n      self._stream.setMaxListeners(Infinity);\n\n      //\n      // When the current stream has finished flushing\n      // then we can be sure we have finished opening\n      // and thus can emit the `open` event.\n      //\n      self.once('flush', function () {\n        // Because \"flush\" event is based on native stream \"drain\" event,\n        // logs could be written inbetween \"self.flush()\" and here\n        // Therefore, we need to flush again to make sure everything is flushed\n        self.flush();\n\n        self.opening = false;\n        self.emit('open', fullname);\n      });\n      //\n      // Remark: It is possible that in the time it has taken to find the\n      // next logfile to be written more data than `maxsize` has been buffered,\n      // but for sensible limits (10s - 100s of MB) this seems unlikely in less\n      // than one second.\n      //\n      self.flush();\n      compressFile();\n    }\n\n    function compressFile() {\n      if (self._archive) {\n        var gzip = zlib.createGzip();\n\n        var inp = fs.createReadStream(String(self._archive));\n        var out = fs.createWriteStream(self._archive + '.gz');\n\n        inp.pipe(gzip).pipe(out);\n\n        fs.unlink(String(self._archive));\n        self._archive = '';\n      }\n    }\n\n    fs.stat(fullname, function (err, stats) {\n      if (err) {\n        if (err.code !== 'ENOENT') {\n          return self.emit('error', err);\n        }\n        return createAndFlush(0);\n      }\n\n      if (!stats || (self.maxsize && stats.size >= self.maxsize)) {\n        //\n        // If `stats.size` is greater than the `maxsize` for\n        // this instance then try again\n        //\n        return self._incFile(function() {\n          checkFile(self._getFile());\n        });\n      }\n\n      createAndFlush(stats.size);\n    });\n  })(this._getFile());\n};\n\n\nFile.prototype._incFile = function (callback) {\n  var ext = path.extname(this._basename),\n      basename = path.basename(this._basename, ext),\n      oldest,\n      target;\n\n  if (!this.tailable) {\n    this._created += 1;\n    this._checkMaxFilesIncrementing(ext, basename, callback);\n  }\n  else {\n    this._checkMaxFilesTailable(ext, basename, callback);\n  }\n};\n\n//\n// ### @private function _getFile ()\n// Gets the next filename to use for this instance\n// in the case that log filesizes are being capped.\n//\nFile.prototype._getFile = function () {\n  var ext = path.extname(this._basename),\n      basename = path.basename(this._basename, ext);\n\n  //\n  // Caveat emptor (indexzero): rotationFormat() was broken by design\n  // when combined with max files because the set of files to unlink\n  // is never stored.\n  //\n  return !this.tailable && this._created\n    ? basename + (this.rotationFormat ? this.rotationFormat() : this._created) + ext\n    : basename + ext;\n};\n\n//\n// ### @private function _checkMaxFilesIncrementing ()\n// Increment the number of files created or\n// checked by this instance.\n//\nFile.prototype._checkMaxFilesIncrementing = function (ext, basename, callback) {\n  var oldest, target,\n    self = this;\n\n  if (self.zippedArchive) {\n    self._archive = path.join(self.dirname, basename +\n        ((self._created === 1) ? '' : self._created-1) +\n        ext);\n  }\n\n\n  // Check for maxFiles option and delete file\n  if (!self.maxFiles || self._created < self.maxFiles) {\n    return callback();\n  }\n\n  oldest = self._created - self.maxFiles;\n  target = path.join(self.dirname, basename + (oldest !== 0 ? oldest : '') + ext +\n    (self.zippedArchive ? '.gz' : ''));\n  fs.unlink(target, callback);\n};\n\n//\n// ### @private function _checkMaxFilesTailable ()\n//\n// Roll files forward based on integer, up to maxFiles.\n// e.g. if base if file.log and it becomes oversized, roll\n//    to file1.log, and allow file.log to be re-used. If\n//    file is oversized again, roll file1.log to file2.log,\n//    roll file.log to file1.log, and so on.\nFile.prototype._checkMaxFilesTailable = function (ext, basename, callback) {\n  var tasks = [],\n      self = this;\n\n  if (!this.maxFiles)\n    return;\n\n  for (var x = this.maxFiles - 1; x > 0; x--) {\n    tasks.push(function (i) {\n      return function (cb) {\n        var tmppath = path.join(self.dirname, basename + (i - 1) + ext +\n          (self.zippedArchive ? '.gz' : ''));\n        fs.exists(tmppath, function (exists) {\n          if (!exists) {\n            return cb(null);\n          }\n\n          fs.rename(tmppath, path.join(self.dirname, basename + i + ext +\n            (self.zippedArchive ? '.gz' : '')), cb);\n        });\n      };\n    }(x));\n  }\n\n  if (self.zippedArchive) {\n    self._archive = path.join(self.dirname, basename + 1 + ext);\n  }\n  async.series(tasks, function (err) {\n    fs.rename(\n      path.join(self.dirname, basename + ext),\n      path.join(self.dirname, basename + 1 + ext),\n      callback\n    );\n  });\n};\n\n//\n// ### @private function _lazyDrain ()\n// Lazily attempts to emit the `logged` event when `this.stream` has\n// drained. This is really just a simple mutex that only works because\n// Node.js is single-threaded.\n//\nFile.prototype._lazyDrain = function () {\n  var self = this;\n\n  if (!this._draining && this._stream) {\n    this._draining = true;\n\n    this._stream.once('drain', function () {\n      this._draining = false;\n      self.emit('logged');\n    });\n  }\n};\n","/*\n * syslog-config.js: Config that conform to syslog logging levels.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar syslogConfig = exports;\n\nsyslogConfig.levels = {\n  emerg: 0,\n  alert: 1,\n  crit: 2,\n  error: 3,\n  warning: 4,\n  notice: 5,\n  info: 6,\n  debug: 7\n};\n\nsyslogConfig.colors = {\n  emerg: 'red',\n  alert: 'yellow',\n  crit: 'red',\n  error: 'red',\n  warning: 'red',\n  notice: 'yellow',\n  info: 'green',\n  debug: 'blue'\n};\n","/*\n * npm-config.js: Config that conform to npm logging levels.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar npmConfig = exports;\n\nnpmConfig.levels = {\n  error: 0,\n  warn: 1,\n  info: 2,\n  verbose: 3,\n  debug: 4,\n  silly: 5\n};\n\nnpmConfig.colors = {\n  error: 'red',\n  warn: 'yellow',\n  info: 'green',\n  verbose: 'cyan',\n  debug: 'blue',\n  silly: 'magenta'\n};\n","/*\n * cli-config.js: Config that conform to commonly used CLI logging levels.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar cliConfig = exports;\n\ncliConfig.levels = {\n  error: 0,\n  warn: 1,\n  help: 2,\n  data: 3,\n  info: 4,\n  debug: 5,\n  prompt: 6,\n  verbose: 7,\n  input: 8,\n  silly: 9,\n};\n\ncliConfig.colors = {\n  error: 'red',\n  warn: 'yellow',\n  help: 'cyan',\n  data: 'grey',\n  info: 'green',\n  debug: 'blue',\n  prompt: 'grey',\n  verbose: 'cyan',\n  input: 'grey',\n  silly: 'magenta'\n};\n","var colors = require('../colors');\n\nmodule['exports'] = (function () {\n  var available = ['underline', 'inverse', 'grey', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta'];\n  return function(letter, i, exploded) {\n    return letter === \" \" ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);\n  };\n})();","var colors = require('../colors');\n\nmodule['exports'] = (function () {\n  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV\n  return function (letter, i, exploded) {\n    if (letter === \" \") {\n      return letter;\n    } else {\n      return colors[rainbowColors[i++ % rainbowColors.length]](letter);\n    }\n  };\n})();\n\n","var colors = require('../colors');\n\nmodule['exports'] = function (letter, i, exploded) {\n  return i % 2 === 0 ? letter : colors.inverse(letter);\n};","var colors = require('../colors');\n\nmodule['exports'] = (function() {\n  return function (letter, i, exploded) {\n    if(letter === \" \") return letter;\n    switch(i%3) {\n      case 0: return colors.red(letter);\n      case 1: return colors.white(letter)\n      case 2: return colors.blue(letter)\n    }\n  }\n})();","// please no\nmodule['exports'] = function zalgo(text, options) {\n  text = text || \"   he is here   \";\n  var soul = {\n    \"up\" : [\n      '̍', '̎', '̄', '̅',\n      '̿', '̑', '̆', '̐',\n      '͒', '͗', '͑', '̇',\n      '̈', '̊', '͂', '̓',\n      '̈', '͊', '͋', '͌',\n      '̃', '̂', '̌', '͐',\n      '̀', '́', '̋', '̏',\n      '̒', '̓', '̔', '̽',\n      '̉', 'ͣ', 'ͤ', 'ͥ',\n      'ͦ', 'ͧ', 'ͨ', 'ͩ',\n      'ͪ', 'ͫ', 'ͬ', 'ͭ',\n      'ͮ', 'ͯ', '̾', '͛',\n      '͆', '̚'\n    ],\n    \"down\" : [\n      '̖', '̗', '̘', '̙',\n      '̜', '̝', '̞', '̟',\n      '̠', '̤', '̥', '̦',\n      '̩', '̪', '̫', '̬',\n      '̭', '̮', '̯', '̰',\n      '̱', '̲', '̳', '̹',\n      '̺', '̻', '̼', 'ͅ',\n      '͇', '͈', '͉', '͍',\n      '͎', '͓', '͔', '͕',\n      '͖', '͙', '͚', '̣'\n    ],\n    \"mid\" : [\n      '̕', '̛', '̀', '́',\n      '͘', '̡', '̢', '̧',\n      '̨', '̴', '̵', '̶',\n      '͜', '͝', '͞',\n      '͟', '͠', '͢', '̸',\n      '̷', '͡', ' ҉'\n    ]\n  },\n  all = [].concat(soul.up, soul.down, soul.mid),\n  zalgo = {};\n\n  function randomNumber(range) {\n    var r = Math.floor(Math.random() * range);\n    return r;\n  }\n\n  function is_char(character) {\n    var bool = false;\n    all.filter(function (i) {\n      bool = (i === character);\n    });\n    return bool;\n  }\n  \n\n  function heComes(text, options) {\n    var result = '', counts, l;\n    options = options || {};\n    options[\"up\"] = options[\"up\"] || true;\n    options[\"mid\"] = options[\"mid\"] || true;\n    options[\"down\"] = options[\"down\"] || true;\n    options[\"size\"] = options[\"size\"] || \"maxi\";\n    text = text.split('');\n    for (l in text) {\n      if (is_char(l)) {\n        continue;\n      }\n      result = result + text[l];\n      counts = {\"up\" : 0, \"down\" : 0, \"mid\" : 0};\n      switch (options.size) {\n      case 'mini':\n        counts.up = randomNumber(8);\n        counts.min = randomNumber(2);\n        counts.down = randomNumber(8);\n        break;\n      case 'maxi':\n        counts.up = randomNumber(16) + 3;\n        counts.min = randomNumber(4) + 1;\n        counts.down = randomNumber(64) + 3;\n        break;\n      default:\n        counts.up = randomNumber(8) + 1;\n        counts.mid = randomNumber(6) / 2;\n        counts.down = randomNumber(8) + 1;\n        break;\n      }\n\n      var arr = [\"up\", \"mid\", \"down\"];\n      for (var d in arr) {\n        var index = arr[d];\n        for (var i = 0 ; i <= counts[index]; i++) {\n          if (options[index]) {\n            result = result + soul[index][randomNumber(soul[index].length)];\n          }\n        }\n      }\n    }\n    return result;\n  }\n  // don't summon him\n  return heComes(text);\n}\n","module['exports'] = function runTheTrap (text, options) {\n  var result = \"\";\n  text = text || \"Run the trap, drop the bass\";\n  text = text.split('');\n  var trap = {\n    a: [\"\\u0040\", \"\\u0104\", \"\\u023a\", \"\\u0245\", \"\\u0394\", \"\\u039b\", \"\\u0414\"],\n    b: [\"\\u00df\", \"\\u0181\", \"\\u0243\", \"\\u026e\", \"\\u03b2\", \"\\u0e3f\"],\n    c: [\"\\u00a9\", \"\\u023b\", \"\\u03fe\"],\n    d: [\"\\u00d0\", \"\\u018a\", \"\\u0500\" , \"\\u0501\" ,\"\\u0502\", \"\\u0503\"],\n    e: [\"\\u00cb\", \"\\u0115\", \"\\u018e\", \"\\u0258\", \"\\u03a3\", \"\\u03be\", \"\\u04bc\", \"\\u0a6c\"],\n    f: [\"\\u04fa\"],\n    g: [\"\\u0262\"],\n    h: [\"\\u0126\", \"\\u0195\", \"\\u04a2\", \"\\u04ba\", \"\\u04c7\", \"\\u050a\"],\n    i: [\"\\u0f0f\"],\n    j: [\"\\u0134\"],\n    k: [\"\\u0138\", \"\\u04a0\", \"\\u04c3\", \"\\u051e\"],\n    l: [\"\\u0139\"],\n    m: [\"\\u028d\", \"\\u04cd\", \"\\u04ce\", \"\\u0520\", \"\\u0521\", \"\\u0d69\"],\n    n: [\"\\u00d1\", \"\\u014b\", \"\\u019d\", \"\\u0376\", \"\\u03a0\", \"\\u048a\"],\n    o: [\"\\u00d8\", \"\\u00f5\", \"\\u00f8\", \"\\u01fe\", \"\\u0298\", \"\\u047a\", \"\\u05dd\", \"\\u06dd\", \"\\u0e4f\"],\n    p: [\"\\u01f7\", \"\\u048e\"],\n    q: [\"\\u09cd\"],\n    r: [\"\\u00ae\", \"\\u01a6\", \"\\u0210\", \"\\u024c\", \"\\u0280\", \"\\u042f\"],\n    s: [\"\\u00a7\", \"\\u03de\", \"\\u03df\", \"\\u03e8\"],\n    t: [\"\\u0141\", \"\\u0166\", \"\\u0373\"],\n    u: [\"\\u01b1\", \"\\u054d\"],\n    v: [\"\\u05d8\"],\n    w: [\"\\u0428\", \"\\u0460\", \"\\u047c\", \"\\u0d70\"],\n    x: [\"\\u04b2\", \"\\u04fe\", \"\\u04fc\", \"\\u04fd\"],\n    y: [\"\\u00a5\", \"\\u04b0\", \"\\u04cb\"],\n    z: [\"\\u01b5\", \"\\u0240\"]\n  }\n  text.forEach(function(c){\n    c = c.toLowerCase();\n    var chars = trap[c] || [\" \"];\n    var rand = Math.floor(Math.random() * chars.length);\n    if (typeof trap[c] !== \"undefined\") {\n      result += trap[c][rand];\n    } else {\n      result += c;\n    }\n  });\n  return result;\n\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error('Cannot find module \"' + req + '\".');\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 124;","/*\nThe MIT License (MIT)\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\nvar argv = process.argv;\n\nmodule.exports = (function () {\n  if (argv.indexOf('--no-color') !== -1 ||\n    argv.indexOf('--color=false') !== -1) {\n    return false;\n  }\n\n  if (argv.indexOf('--color') !== -1 ||\n    argv.indexOf('--color=true') !== -1 ||\n    argv.indexOf('--color=always') !== -1) {\n    return true;\n  }\n\n  if (process.stdout && !process.stdout.isTTY) {\n    return false;\n  }\n\n  if (process.platform === 'win32') {\n    return true;\n  }\n\n  if ('COLORTERM' in process.env) {\n    return true;\n  }\n\n  if (process.env.TERM === 'dumb') {\n    return false;\n  }\n\n  if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n    return true;\n  }\n\n  return false;\n})();","/*\nThe MIT License (MIT)\n\nCopyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n*/\n\nvar styles = {};\nmodule['exports'] = styles;\n\nvar codes = {\n  reset: [0, 0],\n\n  bold: [1, 22],\n  dim: [2, 22],\n  italic: [3, 23],\n  underline: [4, 24],\n  inverse: [7, 27],\n  hidden: [8, 28],\n  strikethrough: [9, 29],\n\n  black: [30, 39],\n  red: [31, 39],\n  green: [32, 39],\n  yellow: [33, 39],\n  blue: [34, 39],\n  magenta: [35, 39],\n  cyan: [36, 39],\n  white: [37, 39],\n  gray: [90, 39],\n  grey: [90, 39],\n\n  bgBlack: [40, 49],\n  bgRed: [41, 49],\n  bgGreen: [42, 49],\n  bgYellow: [43, 49],\n  bgBlue: [44, 49],\n  bgMagenta: [45, 49],\n  bgCyan: [46, 49],\n  bgWhite: [47, 49],\n\n  // legacy styles for colors pre v1.0.0\n  blackBG: [40, 49],\n  redBG: [41, 49],\n  greenBG: [42, 49],\n  yellowBG: [43, 49],\n  blueBG: [44, 49],\n  magentaBG: [45, 49],\n  cyanBG: [46, 49],\n  whiteBG: [47, 49]\n\n};\n\nObject.keys(codes).forEach(function (key) {\n  var val = codes[key];\n  var style = styles[key] = [];\n  style.open = '\\u001b[' + val[0] + 'm';\n  style.close = '\\u001b[' + val[1] + 'm';\n});","//\n// Remark: Requiring this file will use the \"safe\" colors API which will not touch String.prototype\n//\n//   var colors = require('colors/safe);\n//   colors.red(\"foo\")\n//\n//\nvar colors = require('./lib/colors');\nmodule['exports'] = colors;","module.exports = require(\"string_decoder\");","/*\n    cycle.js\n    2013-02-19\n\n    Public Domain.\n\n    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n\n    This code should be minified before deployment.\n    See http://javascript.crockford.com/jsmin.html\n\n    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n    NOT CONTROL.\n*/\n\n/*jslint evil: true, regexp: true */\n\n/*members $ref, apply, call, decycle, hasOwnProperty, length, prototype, push,\n    retrocycle, stringify, test, toString\n*/\n\nvar cycle = exports;\n\ncycle.decycle = function decycle(object) {\n    'use strict';\n\n// Make a deep copy of an object or array, assuring that there is at most\n// one instance of each object or array in the resulting structure. The\n// duplicate references (which might be forming cycles) are replaced with\n// an object of the form\n//      {$ref: PATH}\n// where the PATH is a JSONPath string that locates the first occurance.\n// So,\n//      var a = [];\n//      a[0] = a;\n//      return JSON.stringify(JSON.decycle(a));\n// produces the string '[{\"$ref\":\"$\"}]'.\n\n// JSONPath is used to locate the unique object. $ indicates the top level of\n// the object or array. [NUMBER] or [STRING] indicates a child member or\n// property.\n\n    var objects = [],   // Keep a reference to each unique object or array\n        paths = [];     // Keep the path to each unique object or array\n\n    return (function derez(value, path) {\n\n// The derez recurses through the object, producing the deep copy.\n\n        var i,          // The loop counter\n            name,       // Property name\n            nu;         // The new object or array\n\n// typeof null === 'object', so go on if this value is really an object but not\n// one of the weird builtin objects.\n\n        if (typeof value === 'object' && value !== null &&\n                !(value instanceof Boolean) &&\n                !(value instanceof Date)    &&\n                !(value instanceof Number)  &&\n                !(value instanceof RegExp)  &&\n                !(value instanceof String)) {\n\n// If the value is an object or array, look to see if we have already\n// encountered it. If so, return a $ref/path object. This is a hard way,\n// linear search that will get slower as the number of unique objects grows.\n\n            for (i = 0; i < objects.length; i += 1) {\n                if (objects[i] === value) {\n                    return {$ref: paths[i]};\n                }\n            }\n\n// Otherwise, accumulate the unique value and its path.\n\n            objects.push(value);\n            paths.push(path);\n\n// If it is an array, replicate the array.\n\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                nu = [];\n                for (i = 0; i < value.length; i += 1) {\n                    nu[i] = derez(value[i], path + '[' + i + ']');\n                }\n            } else {\n\n// If it is an object, replicate the object.\n\n                nu = {};\n                for (name in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, name)) {\n                        nu[name] = derez(value[name],\n                            path + '[' + JSON.stringify(name) + ']');\n                    }\n                }\n            }\n            return nu;\n        }\n        return value;\n    }(object, '$'));\n};\n\n\ncycle.retrocycle = function retrocycle($) {\n    'use strict';\n\n// Restore an object that was reduced by decycle. Members whose values are\n// objects of the form\n//      {$ref: PATH}\n// are replaced with references to the value found by the PATH. This will\n// restore cycles. The object will be mutated.\n\n// The eval function is used to locate the values described by a PATH. The\n// root object is kept in a $ variable. A regular expression is used to\n// assure that the PATH is extremely well formed. The regexp contains nested\n// * quantifiers. That has been known to have extremely bad performance\n// problems on some browsers for very long strings. A PATH is expected to be\n// reasonably short. A PATH is allowed to belong to a very restricted subset of\n// Goessner's JSONPath.\n\n// So,\n//      var s = '[{\"$ref\":\"$\"}]';\n//      return JSON.retrocycle(JSON.parse(s));\n// produces an array containing a single element which is the array itself.\n\n    var px =\n        /^\\$(?:\\[(?:\\d+|\\\"(?:[^\\\\\\\"\\u0000-\\u001f]|\\\\([\\\\\\\"\\/bfnrt]|u[0-9a-zA-Z]{4}))*\\\")\\])*$/;\n\n    (function rez(value) {\n\n// The rez function walks recursively through the object looking for $ref\n// properties. When it finds one that has a value that is a path, then it\n// replaces the $ref object with a reference to the value that is found by\n// the path.\n\n        var i, item, name, path;\n\n        if (value && typeof value === 'object') {\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                for (i = 0; i < value.length; i += 1) {\n                    item = value[i];\n                    if (item && typeof item === 'object') {\n                        path = item.$ref;\n                        if (typeof path === 'string' && px.test(path)) {\n                            value[i] = eval(path);\n                        } else {\n                            rez(item);\n                        }\n                    }\n                }\n            } else {\n                for (name in value) {\n                    if (typeof value[name] === 'object') {\n                        item = value[name];\n                        if (item) {\n                            path = item.$ref;\n                            if (typeof path === 'string' && px.test(path)) {\n                                value[name] = eval(path);\n                            } else {\n                                rez(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }($));\n    return $;\n};\n","module.exports = require(\"crypto\");","/*\n * console.js: Transport for outputting to the console\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nvar events = require('events'),\n    os = require('os'),\n    util = require('util'),\n    common = require('../common'),\n    Transport = require('./transport').Transport;\n\n//\n// ### function Console (options)\n// #### @options {Object} Options for this instance.\n// Constructor function for the Console transport object responsible\n// for persisting log messages and metadata to a terminal or TTY.\n//\nvar Console = exports.Console = function (options) {\n  Transport.call(this, options);\n  options = options || {};\n\n  this.json         = options.json        || false;\n  this.colorize     = options.colorize    || false;\n  this.prettyPrint  = options.prettyPrint || false;\n  this.timestamp    = typeof options.timestamp !== 'undefined' ? options.timestamp : false;\n  this.showLevel    = options.showLevel === undefined ? true : options.showLevel;\n  this.label        = options.label       || null;\n  this.logstash     = options.logstash    || false;\n  this.depth        = options.depth       || null;\n  this.align        = options.align       || false;\n  this.stderrLevels = setStderrLevels(options.stderrLevels, options.debugStdout);\n  this.eol          = options.eol   || os.EOL;\n\n  if (this.json) {\n    this.stringify = options.stringify || function (obj) {\n      return JSON.stringify(obj, null, 2);\n    };\n  }\n\n  //\n  // Convert stderrLevels into an Object for faster key-lookup times than an Array.\n  //\n  // For backwards compatibility, stderrLevels defaults to ['error', 'debug']\n  // or ['error'] depending on whether options.debugStdout is true.\n  //\n  function setStderrLevels (levels, debugStdout) {\n    var defaultMsg = 'Cannot have non-string elements in stderrLevels Array';\n    if (debugStdout) {\n      if (levels) {\n        //\n        // Don't allow setting both debugStdout and stderrLevels together,\n        // since this could cause behaviour a programmer might not expect.\n        //\n        throw new Error('Cannot set debugStdout and stderrLevels together');\n      }\n\n      return common.stringArrayToSet(['error'], defaultMsg);\n    }\n\n    if (!levels) {\n      return common.stringArrayToSet(['error', 'debug'], defaultMsg);\n    } else if (!(Array.isArray(levels))) {\n      throw new Error('Cannot set stderrLevels to type other than Array');\n    }\n\n    return common.stringArrayToSet(levels, defaultMsg);\n  };\n};\n\n//\n// Inherit from `winston.Transport`.\n//\nutil.inherits(Console, Transport);\n\n//\n// Expose the name of this Transport on the prototype\n//\nConsole.prototype.name = 'console';\n\n//\n// ### function log (level, msg, [meta], callback)\n// #### @level {string} Level at which to log the message.\n// #### @msg {string} Message to log\n// #### @meta {Object} **Optional** Additional metadata to attach\n// #### @callback {function} Continuation to respond to when complete.\n// Core logging method exposed to Winston. Metadata is optional.\n//\nConsole.prototype.log = function (level, msg, meta, callback) {\n  if (this.silent) {\n    return callback(null, true);\n  }\n\n  var self = this,\n      output;\n\n  output = common.log({\n    colorize:    this.colorize,\n    json:        this.json,\n    level:       level,\n    message:     msg,\n    meta:        meta,\n    stringify:   this.stringify,\n    timestamp:   this.timestamp,\n    showLevel:   this.showLevel,\n    prettyPrint: this.prettyPrint,\n    raw:         this.raw,\n    label:       this.label,\n    logstash:    this.logstash,\n    depth:       this.depth,\n    formatter:   this.formatter,\n    align:       this.align,\n    humanReadableUnhandledException: this.humanReadableUnhandledException\n  });\n\n  if (this.stderrLevels[level]) {\n    process.stderr.write(output + this.eol);\n  } else {\n    process.stdout.write(output + this.eol);\n  }\n\n  //\n  // Emit the `logged` event immediately because the event loop\n  // will not exit until `process.stdout` has drained anyway.\n  //\n  self.emit('logged');\n  callback(null, true);\n};\n","/*\n * transports.js: Set of all transports Winston knows about\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n *\n */\n\nObject.defineProperty(exports, 'Console', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    return require('./transports/console').Console;\n  }\n});\nObject.defineProperty(exports, 'File', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    return require('./transports/file').File;\n  }\n});\nObject.defineProperty(exports, 'Http', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    return require('./transports/http').Http;\n  }\n});\nObject.defineProperty(exports, 'Memory', {\n  configurable: true,\n  enumerable: true,\n  get: function () {\n    return require('./transports/memory').Memory;\n  }\n});\n","import { log } from '../../../main-process/log'\nimport { formatLogMessage } from '../format-log-message'\n\nconst g = global as any\n\ng.log = {\n  error(message: string, error?: Error) {\n    log('error', '[main] ' + formatLogMessage(message, error))\n  },\n  warn(message: string, error?: Error) {\n    log('warn', '[main] ' + formatLogMessage(message, error))\n  },\n  info(message: string, error?: Error) {\n    log('info', '[main] ' + formatLogMessage(message, error))\n  },\n  debug(message: string, error?: Error) {\n    log('debug', '[main] ' + formatLogMessage(message, error))\n  },\n} as IDesktopLogger\n","import '../lib/logging/main/install'\n\nimport { app, Menu, ipcMain, BrowserWindow, shell } from 'electron'\nimport * as Fs from 'fs'\nimport * as URL from 'url'\n\nimport { MenuLabelsEvent } from '../models/menu-labels'\n\nimport { AppWindow } from './app-window'\nimport { buildDefaultMenu, MenuEvent, getAllMenuItems } from './menu'\nimport { shellNeedsPatching, updateEnvironmentForProcess } from '../lib/shell'\nimport { parseAppURL } from '../lib/parse-app-url'\nimport { handleSquirrelEvent } from './squirrel-updater'\nimport { fatalError } from '../lib/fatal-error'\n\nimport { IMenuItemState } from '../lib/menu-update'\nimport { LogLevel } from '../lib/logging/log-level'\nimport { log as writeLog } from './log'\nimport { openDirectorySafe } from './shell'\nimport { reportError } from './exception-reporting'\nimport {\n  enableSourceMaps,\n  withSourceMappedStack,\n} from '../lib/source-map-support'\nimport { now } from './now'\nimport { showUncaughtException } from './show-uncaught-exception'\nimport { IMenuItem } from '../lib/menu-item'\nimport { buildContextMenu } from './menu/build-context-menu'\nimport { sendNonFatalException } from '../lib/helpers/non-fatal-exception'\n\napp.setAppLogsPath()\nenableSourceMaps()\n\nlet mainWindow: AppWindow | null = null\n\nconst launchTime = now()\n\nlet preventQuit = false\nlet readyTime: number | null = null\n\ntype OnDidLoadFn = (window: AppWindow) => void\n/** See the `onDidLoad` function. */\nlet onDidLoadFns: Array<OnDidLoadFn> | null = []\n\nfunction handleUncaughtException(error: Error) {\n  preventQuit = true\n\n  // If we haven't got a window we'll assume it's because\n  // we've just launched and haven't created it yet.\n  // It could also be because we're encountering an unhandled\n  // exception on shutdown but that's less likely and since\n  // this only affects the presentation of the crash dialog\n  // it's a safe assumption to make.\n  const isLaunchError = mainWindow === null\n\n  if (mainWindow) {\n    mainWindow.destroy()\n    mainWindow = null\n  }\n\n  showUncaughtException(isLaunchError, error)\n}\n\n/**\n * Calculates the number of seconds the app has been running\n */\nfunction getUptimeInSeconds() {\n  return (now() - launchTime) / 1000\n}\n\nfunction getExtraErrorContext(): Record<string, string> {\n  return {\n    uptime: getUptimeInSeconds().toFixed(3),\n    time: new Date().toString(),\n  }\n}\n\n/** Extra argument for the protocol launcher on Windows */\nconst protocolLauncherArg = '--protocol-launcher'\n\nconst possibleProtocols = new Set(['x-github-client'])\nif (__DEV__) {\n  possibleProtocols.add('x-github-desktop-dev-auth')\n} else {\n  possibleProtocols.add('x-github-desktop-auth')\n}\n// Also support Desktop Classic's protocols.\nif (__DARWIN__) {\n  possibleProtocols.add('github-mac')\n} else if (__WIN32__) {\n  possibleProtocols.add('github-windows')\n}\n\napp.on('window-all-closed', () => {\n  // If we don't subscribe to this event and all windows are closed, the default\n  // behavior is to quit the app. We don't want that though, we control that\n  // behavior through the mainWindow onClose event such that on macOS we only\n  // hide the main window when a user attempts to close it.\n  //\n  // If we don't subscribe to this and change the default behavior we break\n  // the crash process window which is shown after the main window is closed.\n})\n\nprocess.on('uncaughtException', (error: Error) => {\n  error = withSourceMappedStack(error)\n  reportError(error, getExtraErrorContext())\n  handleUncaughtException(error)\n})\n\nlet handlingSquirrelEvent = false\nif (__WIN32__ && process.argv.length > 1) {\n  const arg = process.argv[1]\n\n  const promise = handleSquirrelEvent(arg)\n  if (promise) {\n    handlingSquirrelEvent = true\n    promise\n      .catch(e => {\n        log.error(`Failed handling Squirrel event: ${arg}`, e)\n      })\n      .then(() => {\n        app.quit()\n      })\n  } else {\n    handlePossibleProtocolLauncherArgs(process.argv)\n  }\n}\n\nfunction handleAppURL(url: string) {\n  log.info('Processing protocol url')\n  const action = parseAppURL(url)\n  onDidLoad(window => {\n    // This manual focus call _shouldn't_ be necessary, but is for Chrome on\n    // macOS. See https://github.com/desktop/desktop/issues/973.\n    window.focus()\n    window.sendURLAction(action)\n  })\n}\n\nlet isDuplicateInstance = false\n// If we're handling a Squirrel event we don't want to enforce single instance.\n// We want to let the updated instance launch and do its work. It will then quit\n// once it's done.\nif (!handlingSquirrelEvent) {\n  const gotSingleInstanceLock = app.requestSingleInstanceLock()\n  isDuplicateInstance = !gotSingleInstanceLock\n\n  app.on('second-instance', (event, args, workingDirectory) => {\n    // Someone tried to run a second instance, we should focus our window.\n    if (mainWindow) {\n      if (mainWindow.isMinimized()) {\n        mainWindow.restore()\n      }\n\n      if (!mainWindow.isVisible()) {\n        mainWindow.show()\n      }\n\n      mainWindow.focus()\n    }\n\n    handlePossibleProtocolLauncherArgs(args)\n  })\n\n  if (isDuplicateInstance) {\n    app.quit()\n  }\n}\n\nif (shellNeedsPatching(process)) {\n  updateEnvironmentForProcess()\n}\n\napp.on('will-finish-launching', () => {\n  // macOS only\n  app.on('open-url', (event, url) => {\n    event.preventDefault()\n    handleAppURL(url)\n  })\n})\n\nif (__DARWIN__) {\n  app.on('open-file', async (event, path) => {\n    event.preventDefault()\n\n    log.info(`[main] a path to ${path} was triggered`)\n\n    Fs.stat(path, (err, stats) => {\n      if (err) {\n        log.error(`Unable to open path '${path}' in Desktop`, err)\n        return\n      }\n\n      if (stats.isFile()) {\n        log.warn(\n          `A file at ${path} was dropped onto Desktop, but it can only handle folders. Ignoring this action.`\n        )\n        return\n      }\n\n      handleAppURL(\n        `x-github-client://openLocalRepo/${encodeURIComponent(path)}`\n      )\n    })\n  })\n}\n\n/**\n * Attempt to detect and handle any protocol handler arguments passed\n * either via the command line directly to the current process or through\n * IPC from a duplicate instance (see makeSingleInstance)\n *\n * @param args Essentially process.argv, i.e. the first element is the exec\n *             path\n */\nfunction handlePossibleProtocolLauncherArgs(args: ReadonlyArray<string>) {\n  log.info(`Received possible protocol arguments: ${args.length}`)\n\n  if (__WIN32__) {\n    // Desktop registers it's protocol handler callback on Windows as\n    // `[executable path] --protocol-launcher \"%1\"`. Note that extra command\n    // line arguments might be added by Chromium\n    // (https://electronjs.org/docs/api/app#event-second-instance).\n    // At launch Desktop checks for that exact scenario here before doing any\n    // processing. If there's more than one matching url argument because of a\n    // malformed or untrusted url then we bail out.\n\n    const matchingUrls = args.filter(arg => {\n      // sometimes `URL.parse` throws an error\n      try {\n        const url = URL.parse(arg)\n        // i think this `slice` is just removing a trailing `:`\n        return url.protocol && possibleProtocols.has(url.protocol.slice(0, -1))\n      } catch (e) {\n        log.error(`Unable to parse argument as URL: ${arg}`)\n        return false\n      }\n    })\n\n    if (args.includes(protocolLauncherArg) && matchingUrls.length === 1) {\n      handleAppURL(matchingUrls[0])\n    } else {\n      log.error(`Malformed launch arguments received: ${args}`)\n    }\n  } else if (args.length > 1) {\n    handleAppURL(args[1])\n  }\n}\n\n/**\n * Wrapper around app.setAsDefaultProtocolClient that adds our\n * custom prefix command line switches on Windows.\n */\nfunction setAsDefaultProtocolClient(protocol: string) {\n  if (__WIN32__) {\n    app.setAsDefaultProtocolClient(protocol, process.execPath, [\n      protocolLauncherArg,\n    ])\n  } else {\n    app.setAsDefaultProtocolClient(protocol)\n  }\n}\n\nif (process.env.GITHUB_DESKTOP_DISABLE_HARDWARE_ACCELERATION) {\n  log.info(\n    `GITHUB_DESKTOP_DISABLE_HARDWARE_ACCELERATION environment variable set, disabling hardware acceleration`\n  )\n  app.disableHardwareAcceleration()\n}\n\napp.on('ready', () => {\n  if (isDuplicateInstance || handlingSquirrelEvent) {\n    return\n  }\n\n  readyTime = now() - launchTime\n\n  possibleProtocols.forEach(protocol => setAsDefaultProtocolClient(protocol))\n\n  createWindow()\n\n  Menu.setApplicationMenu(\n    buildDefaultMenu({\n      selectedShell: null,\n      selectedExternalEditor: null,\n      askForConfirmationOnRepositoryRemoval: false,\n      askForConfirmationOnForcePush: false,\n    })\n  )\n\n  ipcMain.on(\n    'update-preferred-app-menu-item-labels',\n    (event: Electron.IpcMainEvent, labels: MenuLabelsEvent) => {\n      // The current application menu is mutable and we frequently\n      // change whether particular items are enabled or not through\n      // the update-menu-state IPC event. This menu that we're creating\n      // now will have all the items enabled so we need to merge the\n      // current state with the new in order to not get a temporary\n      // race conditions where menu items which shouldn't be enabled\n      // are.\n      const newMenu = buildDefaultMenu(labels)\n\n      const currentMenu = Menu.getApplicationMenu()\n\n      // This shouldn't happen but whenever one says that it does\n      // so here's the escape hatch when we can't merge the current\n      // menu with the new one; we just use the new one.\n      if (currentMenu === null) {\n        // https://github.com/electron/electron/issues/2717\n        Menu.setApplicationMenu(newMenu)\n\n        if (mainWindow !== null) {\n          mainWindow.sendAppMenu()\n        }\n\n        return\n      }\n\n      // It's possible that after rebuilding the menu we'll end up\n      // with the exact same structural menu as we had before so we\n      // keep track of whether anything has actually changed in order\n      // to avoid updating the global menu and telling the renderer\n      // about it.\n      let menuHasChanged = false\n\n      for (const newItem of getAllMenuItems(newMenu)) {\n        // Our menu items always have ids and Electron.MenuItem takes on whatever\n        // properties was defined on the MenuItemOptions template used to create it\n        // but doesn't surface those in the type declaration.\n        const id = (newItem as any).id\n\n        if (!id) {\n          continue\n        }\n\n        const currentItem = currentMenu.getMenuItemById(id)\n\n        // Unfortunately the type information for getMenuItemById\n        // doesn't specify if it'll return null or undefined when\n        // the item doesn't exist so we'll do a falsy check here.\n        if (!currentItem) {\n          menuHasChanged = true\n        } else {\n          if (currentItem.label !== newItem.label) {\n            menuHasChanged = true\n          }\n\n          // Copy the enabled property from the existing menu\n          // item since it'll be the most recent reflection of\n          // what the renderer wants.\n          if (currentItem.enabled !== newItem.enabled) {\n            newItem.enabled = currentItem.enabled\n            menuHasChanged = true\n          }\n        }\n      }\n\n      if (menuHasChanged && mainWindow) {\n        // https://github.com/electron/electron/issues/2717\n        Menu.setApplicationMenu(newMenu)\n        mainWindow.sendAppMenu()\n      }\n    }\n  )\n\n  ipcMain.on('menu-event', (event: Electron.IpcMainEvent, args: any[]) => {\n    const { name }: { name: MenuEvent } = event as any\n    if (mainWindow) {\n      mainWindow.sendMenuEvent(name)\n    }\n  })\n\n  /**\n   * An event sent by the renderer asking that the menu item with the given id\n   * is executed (ie clicked).\n   */\n  ipcMain.on(\n    'execute-menu-item',\n    (event: Electron.IpcMainEvent, { id }: { id: string }) => {\n      const currentMenu = Menu.getApplicationMenu()\n\n      if (currentMenu === null) {\n        return\n      }\n\n      const menuItem = currentMenu.getMenuItemById(id)\n      if (menuItem) {\n        const window = BrowserWindow.fromWebContents(event.sender)\n        const fakeEvent = { preventDefault: () => {}, sender: event.sender }\n        menuItem.click(fakeEvent, window, event.sender)\n      }\n    }\n  )\n\n  ipcMain.on(\n    'update-menu-state',\n    (\n      event: Electron.IpcMainEvent,\n      items: Array<{ id: string; state: IMenuItemState }>\n    ) => {\n      let sendMenuChangedEvent = false\n\n      const currentMenu = Menu.getApplicationMenu()\n\n      if (currentMenu === null) {\n        log.debug(`unable to get current menu, bailing out...`)\n        return\n      }\n\n      for (const item of items) {\n        const { id, state } = item\n\n        const menuItem = currentMenu.getMenuItemById(id)\n\n        if (menuItem) {\n          // Only send the updated app menu when the state actually changes\n          // or we might end up introducing a never ending loop between\n          // the renderer and the main process\n          if (\n            state.enabled !== undefined &&\n            menuItem.enabled !== state.enabled\n          ) {\n            menuItem.enabled = state.enabled\n            sendMenuChangedEvent = true\n          }\n        } else {\n          fatalError(`Unknown menu id: ${id}`)\n        }\n      }\n\n      if (sendMenuChangedEvent && mainWindow) {\n        Menu.setApplicationMenu(currentMenu)\n        mainWindow.sendAppMenu()\n      }\n    }\n  )\n\n  ipcMain.on(\n    'show-contextual-menu',\n    (event: Electron.IpcMainEvent, items: ReadonlyArray<IMenuItem>) => {\n      const menu = buildContextMenu(items, indices =>\n        event.sender.send('contextual-menu-action', indices)\n      )\n\n      const window = BrowserWindow.fromWebContents(event.sender)\n      menu.popup({ window })\n    }\n  )\n\n  /**\n   * An event sent by the renderer asking for a copy of the current\n   * application menu.\n   */\n  ipcMain.on('get-app-menu', () => {\n    if (mainWindow) {\n      mainWindow.sendAppMenu()\n    }\n  })\n\n  ipcMain.on(\n    'show-certificate-trust-dialog',\n    (\n      event: Electron.IpcMainEvent,\n      {\n        certificate,\n        message,\n      }: { certificate: Electron.Certificate; message: string }\n    ) => {\n      // This API is only implemented for macOS and Windows right now.\n      if (__DARWIN__ || __WIN32__) {\n        onDidLoad(window => {\n          window.showCertificateTrustDialog(certificate, message)\n        })\n      }\n    }\n  )\n\n  ipcMain.on(\n    'log',\n    (event: Electron.IpcMainEvent, level: LogLevel, message: string) => {\n      writeLog(level, message)\n    }\n  )\n\n  ipcMain.on(\n    'uncaught-exception',\n    (event: Electron.IpcMainEvent, error: Error) => {\n      handleUncaughtException(error)\n    }\n  )\n\n  ipcMain.on(\n    'send-error-report',\n    (\n      event: Electron.IpcMainEvent,\n      {\n        error,\n        extra,\n        nonFatal,\n      }: { error: Error; extra: { [key: string]: string }; nonFatal?: boolean }\n    ) => {\n      reportError(\n        error,\n        {\n          ...getExtraErrorContext(),\n          ...extra,\n        },\n        nonFatal\n      )\n    }\n  )\n\n  ipcMain.on(\n    'open-external',\n    async (event: Electron.IpcMainEvent, { path }: { path: string }) => {\n      const pathLowerCase = path.toLowerCase()\n      if (\n        pathLowerCase.startsWith('http://') ||\n        pathLowerCase.startsWith('https://')\n      ) {\n        log.info(`opening in browser: ${path}`)\n      }\n\n      let result\n      try {\n        await shell.openExternal(path)\n        result = true\n      } catch (e) {\n        log.error(`Call to openExternal failed: '${e}'`)\n        result = false\n      }\n      event.sender.send('open-external-result', { result })\n    }\n  )\n\n  ipcMain.on(\n    'show-item-in-folder',\n    (event: Electron.IpcMainEvent, { path }: { path: string }) => {\n      Fs.stat(path, (err, stats) => {\n        if (err) {\n          log.error(`Unable to find file at '${path}'`, err)\n          return\n        }\n\n        if (!__DARWIN__ && stats.isDirectory()) {\n          openDirectorySafe(path)\n        } else {\n          shell.showItemInFolder(path)\n        }\n      })\n    }\n  )\n})\n\napp.on('activate', () => {\n  onDidLoad(window => {\n    window.show()\n  })\n})\n\napp.on('web-contents-created', (event, contents) => {\n  contents.on('new-window', (event, url) => {\n    // Prevent links or window.open from opening new windows\n    event.preventDefault()\n    const errMsg = `Prevented new window to: ${url}`\n    log.warn(errMsg)\n    sendNonFatalException('newWindowPrevented', Error(errMsg))\n  })\n  // prevent link navigation within our windows\n  // see https://www.electronjs.org/docs/tutorial/security#12-disable-or-limit-navigation\n  contents.on('will-navigate', (event, url) => {\n    event.preventDefault()\n    const errMsg = `Prevented navigation to: ${url}`\n    log.warn(errMsg)\n    sendNonFatalException('willNavigatePrevented', Error(errMsg))\n  })\n})\n\napp.on(\n  'certificate-error',\n  (event, webContents, url, error, certificate, callback) => {\n    callback(false)\n\n    onDidLoad(window => {\n      window.sendCertificateError(certificate, error, url)\n    })\n  }\n)\n\nfunction createWindow() {\n  const window = new AppWindow()\n\n  if (__DEV__) {\n    const {\n      default: installExtension,\n      REACT_DEVELOPER_TOOLS,\n    } = require('electron-devtools-installer')\n\n    require('electron-debug')({ showDevTools: true })\n\n    const ChromeLens = {\n      id: 'idikgljglpfilbhaboonnpnnincjhjkd',\n      electron: '>=1.2.1',\n    }\n\n    const extensions = [REACT_DEVELOPER_TOOLS, ChromeLens]\n\n    for (const extension of extensions) {\n      try {\n        installExtension(extension)\n      } catch (e) {}\n    }\n  }\n\n  window.onClose(() => {\n    mainWindow = null\n    if (!__DARWIN__ && !preventQuit) {\n      app.quit()\n    }\n  })\n\n  window.onDidLoad(() => {\n    window.show()\n    window.sendLaunchTimingStats({\n      mainReadyTime: readyTime!,\n      loadTime: window.loadTime!,\n      rendererReadyTime: window.rendererReadyTime!,\n    })\n\n    const fns = onDidLoadFns!\n    onDidLoadFns = null\n    for (const fn of fns) {\n      fn(window)\n    }\n  })\n\n  window.load()\n\n  mainWindow = window\n}\n\n/**\n * Register a function to be called once the window has been loaded. If the\n * window has already been loaded, the function will be called immediately.\n */\nfunction onDidLoad(fn: OnDidLoadFn) {\n  if (onDidLoadFns) {\n    onDidLoadFns.push(fn)\n  } else {\n    if (mainWindow) {\n      fn(mainWindow)\n    }\n  }\n}\n"],"sourceRoot":""}